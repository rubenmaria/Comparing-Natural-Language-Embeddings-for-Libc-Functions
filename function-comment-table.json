{
    "argp_help(const struct argp *, FILE *, unsigned int, char *)": [],
    "argp_state_help(const struct argp_state *, FILE *, unsigned int)": [],
    "argp_error(const struct argp_state *, const char *, ...)": [],
    "argp_failure(const struct argp_state *, int, int, const char *, ...)": [],
    "argp_parse(const struct argp *, int, char **, unsigned int, int *, void *)": [
        "/* If true, then err == EBADKEY is a result of a non-option argument failing\n     to be parsed (which in some cases isn't actually an error).  */",
        "/* Add our own options.  */",
        "/* TOP_ARGP has no options, it just serves to group the user & default\n\t argps.  */",
        "/* Construct a parser for these arguments.  */",
        "/* Parse! */"
    ],
    "vprintf(const char *restrict, int)": [],
    "getchar()": [],
    "fgetc_unlocked(FILE *)": [],
    "getc_unlocked(FILE *)": [],
    "getchar_unlocked()": [],
    "putchar(int)": [],
    "fputc_unlocked(int, FILE *)": [],
    "putc_unlocked(int, FILE *)": [],
    "putchar_unlocked(int)": [],
    "feof_unlocked(FILE *)": [],
    "ferror_unlocked(FILE *)": [],
    "tolower(int)": [],
    "toupper(int)": [],
    "argp_usage(const struct argp_state *)": [],
    "__assert(const char *, const char *, int)": [],
    "__assert_perror_fail(int, const char *, unsigned int, const char *)": [],
    "__assert_fail(const char *, const char *, unsigned int, const char *)": [],
    "catgets(nl_catd, int, int, const char *)": [
        "/* Be generous if catalog which failed to be open is used.  */"
    ],
    "catclose(nl_catd)": [
        "/* Be generous if catalog which failed to be open is used.  */",
        "/* _POSIX_MAPPED_FILES */"
    ],
    "__errno_location()": [],
    "__gmon_start__()": [
        "/* We cannot use the normal constructor mechanism to call\n   __gmon_start__ because gcrt1.o appears before crtbegin.o in the link.\n   Instead crti.o calls it specially.  */",
        "/* Protect from being called more than once.  Since crti.o is linked\n     into every shared library, each of their init functions will call us.  */",
        "/* Start keeping profiling records.  */",
        "/* Call _mcleanup before exiting; it will write out gmon.out from the\n     collected data.  */"
    ],
    "__libc_init_first(int, char **, char **)": [
        "/* For DSOs we do not need __libc_init_first but an ELF constructor.  */",
        "/* Make sure we don't initialize twice.  */",
        "/* Set the FPU control word to the proper default value if the\n\t kernel would use a different value.  */",
        "/* Save the command-line arguments.  */",
        "/* First the initialization which normally would be done by the\n     dynamic linker.  */"
    ],
    "isblank(int)": [],
    "__isblank_l(int, locale_t)": [],
    "_tolower(int)": [],
    "_toupper(int)": [],
    "toascii(int)": [],
    "isalnum(int)": [],
    "isalpha(int)": [],
    "iscntrl(int)": [],
    "isdigit(int)": [],
    "islower(int)": [],
    "isgraph(int)": [],
    "isprint(int)": [],
    "ispunct(int)": [],
    "isspace(int)": [],
    "isupper(int)": [],
    "isxdigit(int)": [],
    "__isalnum_l(int, locale_t)": [],
    "__isctype(int, int)": [],
    "__backtrace(void **, int)": [
        "/* _Unwind_Backtrace seems to put NULL address above\n\t _start.  Fix it up here.  */"
    ],
    "__backtrace_symbols(void *const *, int)": [
        "/* Fill in the information we can get from `dladdr'.  */",
        "/* We have some info, compute the length of the string which will be\n\t     \"<file-name>(<sym-name>+offset) [address].  */",
        "/* The load bias is more useful to the user than the load\n\t     address.  The use of these addresses is to calculate an\n\t     address in the ELF file, so its prelinked bias is not\n\t     something we want to subtract out.  */",
        "/* Allocate memory for the result.  */",
        "/* We found no symbol name to use, so describe it as\n\t\t   relative to the file.  */"
    ],
    "__backtrace_symbols_fd(void *const *, int, int)": [
        "/* Name of the file.  */",
        "/* We have a symbol name.  */",
        "/* We have no symbol, so describe it as relative to the file.\n\t\t   The load bias is more useful to the user than the load\n\t\t   address.  The use of these addresses is to calculate an\n\t\t   address in the ELF file, so its prelinked bias is not\n\t\t   something we want to subtract out.  */"
    ],
    "__chk_fail()": [],
    "__confstr_chk(int, char *, int, int)": [],
    "__dprintf_chk(int, int, const char *, ...)": [],
    "__explicit_bzero_chk(void *, int, int)": [
        "/* Inline __memset_chk to avoid a PLT reference to __memset_chk.  */",
        "/* Compiler barrier.  */"
    ],
    "__fdelt_chk(long)": [],
    "__fgets_chk(char *, int, int, FILE *)": [
        "/* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */",
        "/* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */"
    ],
    "__fgets_unlocked_chk(char *, int, int, FILE *)": [
        "/* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */",
        "/* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */"
    ],
    "__fgetws_chk(int *, int, int, FILE *)": [
        "/* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */",
        "/* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */"
    ],
    "__fgetws_unlocked_chk(int *, int, int, FILE *)": [
        "/* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */",
        "/* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */"
    ],
    "__fortify_fail(const char *)": [],
    "__fread_chk(void *restrict, int, int, int, FILE *restrict)": [],
    "__fread_unlocked_chk(void *restrict, int, int, int, FILE *restrict)": [],
    "__fwprintf_chk(int *, int, const int *, ...)": [
        "/* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */"
    ],
    "__getcwd_chk(char *, int, int)": [],
    "__getdomainname_chk(char *, int, int)": [],
    "__getgroups_chk(int, __gid_t *, int)": [],
    "__gethostname_chk(char *, int, int)": [],
    "__gets_chk(char *, int)": [
        "/* This is very tricky since a file descriptor may be in the\n\t non-blocking mode. The error flag doesn't mean much in this\n\t case. We return an error only when there is a new error. */"
    ],
    "__getwd_chk(char *, int)": [],
    "__mbsnrtowcs_chk(int *, const char **, int, int, mbstate_t *, int)": [],
    "__mbsrtowcs_chk(int *, const char **, int, mbstate_t *, int)": [],
    "__mbstowcs_chk(int *, const char *, int, int)": [
        "/* Return how many we wrote (or maybe an error).  */"
    ],
    "__memcpy_chk(void *, const void *, int, int)": [],
    "__memmove_chk(void *, const void *, int, int)": [],
    "__mempcpy_chk(void *, const void *, int, int)": [],
    "__memset_chk(void *, int, int, int)": [],
    "__cyg_profile_func_enter(void *, void *)": [
        "/* Now write out the current position and that of the caller.  We do\n     this now, and don't cache the because we want real-time output.  */"
    ],
    "__obstack_printf_chk(struct obstack *, int, const char *, ...)": [
        "/* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */"
    ],
    "__poll_chk(struct pollfd *, nfds_t, int, unsigned long)": [],
    "__ppoll_chk(struct pollfd *, nfds_t, const struct timespec *, const int *, unsigned long)": [],
    "__pread64_chk(int, void *, int, int, int)": [],
    "__pread_chk(int, void *, int, off_t, int)": [],
    "__read_chk(int, void *, int, int)": [],
    "__readlink_chk(const char *restrict, char *restrict, int, int)": [],
    "__readlinkat_chk(int, const char *restrict, char *restrict, int, int)": [],
    "__realpath_chk(const char *, char *, int)": [
        "/* We do have a fixed limit.  */",
        "/* Since there is no fixed limit we check whether the size is large\n     enough.  */"
    ],
    "__recv_chk(int, void *, int, int, int)": [],
    "__recvfrom_chk(int, void *, int, int, int, struct sockaddr *restrict, socklen_t *)": [],
    "__stack_chk_fail()": [],
    "__stpcpy_chk(char *, const char *, int)": [],
    "__stpncpy_chk(char *, const char *, int, int)": [],
    "__strcat_chk(char *, const char *, int)": [
        "/* Find the end of the string.  */",
        "/* Make S1 point before the next character, so we can increment\n     it while memory is read (wins on pipelined cpus).  */"
    ],
    "__strcpy_chk(char *, const char *, int)": [],
    "__strlcat_chk(char *restrict, const char *restrict, int, int)": [],
    "__strlcpy_chk(char *restrict, const char *restrict, int, int)": [],
    "__strncat_chk(char *, const char *, int, int)": [
        "/* Find the end of S1.  */",
        "/* Make S1 point before next character, so we can increment\n     it while memory is read (wins on pipelined cpus).  */"
    ],
    "__strncpy_chk(char *, const char *, int, int)": [],
    "__swprintf_chk(int *, int, int, int, const int *, ...)": [
        "/* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */"
    ],
    "__ttyname_r_chk(int, char *, int, int)": [],
    "__vasprintf_chk(char **, int, const char *, int)": [
        "/* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */"
    ],
    "__vdprintf_chk(int, int, const char *, int)": [
        "/* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */"
    ],
    "__vfwprintf_chk(int *, int, const int *, int)": [
        "/* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */"
    ],
    "__obstack_vprintf_chk(struct obstack *, int, const char *, int)": [
        "/* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */"
    ],
    "__vswprintf_chk(int *, int, int, int, const int *, int)": [
        "/* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */"
    ],
    "__vwprintf_chk(int, const int *, int)": [
        "/* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */"
    ],
    "__wcpcpy_chk(int *, const int *, int)": [],
    "__wcpncpy_chk(int *, const int *, int, int)": [
        "/* This function is not often enough used to justify not using a\n     tail call.  */"
    ],
    "__wcrtomb_chk(char *, int, mbstate_t *, int)": [],
    "__wcscat_chk(int *, const int *, int)": [
        "/* Find the end of the string.  */",
        "/* Make S1 point before the next character, so we can increment\n     it while memory is read (wins on pipelined cpus).\t*/"
    ],
    "__wcscpy_chk(int *, const int *, int)": [],
    "__wcslcat_chk(int *restrict, const int *restrict, int, int)": [],
    "__wcslcpy_chk(int *restrict, const int *restrict, int, int)": [],
    "__wcsncat_chk(int *, const int *, int, int)": [
        "/* Find the end of DEST.  */",
        "/* Make DEST point before next character, so we can increment\n     it while memory is read (wins on pipelined cpus).\t*/"
    ],
    "__wcsncpy_chk(int *, const int *, int, int)": [
        "/* This function is not often enough used to justify not using a\n     tail call.  */"
    ],
    "__wcsnrtombs_chk(char *, const int **, int, int, mbstate_t *, int)": [],
    "__wcsrtombs_chk(char *, const int **, int, mbstate_t *, int)": [],
    "__wcstombs_chk(char *, const int *, int, int)": [
        "/* Return how many we wrote (or maybe an error).  */"
    ],
    "__wctomb_chk(char *, int, int)": [
        "/* We do not have to implement the full wctomb semantics since we\n     know that S cannot be NULL when we come here.  */"
    ],
    "__wmemcpy_chk(int *, const int *, int, int)": [],
    "__wmemmove_chk(int *, const int *, int, int)": [],
    "__wmempcpy_chk(int *, const int *, int, int)": [],
    "__wmemset_chk(int *, int, int, int)": [],
    "__wprintf_chk(int, const int *, ...)": [
        "/* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */"
    ],
    "alphasort64(const struct dirent64 **, const struct dirent64 **)": [],
    "getdirentries64(int, char *, int, int *)": [],
    "readdir64_r(DIR *, struct dirent64 *, struct dirent64 **)": [],
    "scandir64(const char *, struct dirent64 ***, int (*)(const struct dirent64 *), int (*)(const struct dirent64 **, const struct dirent64 **))": [],
    "scandirat64(int, const char *, struct dirent64 ***, int (*)(const struct dirent64 *), int (*)(const struct dirent64 **, const struct dirent64 **))": [],
    "seekdir(DIR *, long)": [],
    "telldir(DIR *)": [],
    "versionsort64(const struct dirent64 **, const struct dirent64 **)": [],
    "malloc(int)": [],
    "unsetenv(const char *)": [
        "/* Found it.  Remove this pointer by moving later ones back.  */",
        "/* Continue the loop in case NAME appears again.  */"
    ],
    "_dl_find_object(void *, struct dl_find_object *)": [],
    "_dl_mcount_wrapper(void *)": [],
    "_dl_mcount_wrapper_check(void *)": [],
    "__libc_early_init(_Bool)": [
        "/* Initialize ctype data.  */",
        "/* Only the outer namespace is marked as single-threaded.  */"
    ],
    "getpid()": [],
    "calloc(int, int)": [
        "/* malloc_internal uses mmap, so the memory is zeroed.  */"
    ],
    "access(int)": [],
    "__profile_frequency()": [],
    "__libc_alloca_cutoff(int)": [
        "/* The main thread, before the thread library is\n\t\t\t  initialized, has zero in the stackblock_size\n\t\t\t  element.  Since it is the main thread we can\n\t\t\t  assume the maximum available stack space.  */"
    ],
    "pthread_attr_init(pthread_attr_t *)": [],
    "pthread_attr_setschedparam(pthread_attr_t *, const struct sched_param *)": [],
    "pthread_attr_getscope(const pthread_attr_t *, int *)": [],
    "pthread_attr_setscope(pthread_attr_t *, int)": [],
    "pthread_condattr_destroy(pthread_condattr_t *)": [],
    "pthread_condattr_init(pthread_condattr_t *)": [],
    "pthread_cond_broadcast(pthread_cond_t *)": [],
    "pthread_cond_destroy(pthread_cond_t *)": [],
    "pthread_cond_init(pthread_cond_t *, const pthread_condattr_t *)": [],
    "pthread_cond_signal(pthread_cond_t *)": [],
    "pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *)": [],
    "pthread_cond_timedwait(pthread_cond_t *, pthread_mutex_t *, const struct timespec *)": [],
    "pthread_mutex_destroy(pthread_mutex_t *)": [
        "/* Use an alias to avoid warning, as pthread_exit is declared noreturn.  */"
    ],
    "pthread_mutex_init(pthread_mutex_t *, const pthread_mutexattr_t *)": [
        "/* Use an alias to avoid warning, as pthread_exit is declared noreturn.  */"
    ],
    "pthread_mutex_lock(pthread_mutex_t *)": [
        "/* Use an alias to avoid warning, as pthread_exit is declared noreturn.  */"
    ],
    "pthread_mutex_unlock(pthread_mutex_t *)": [
        "/* Use an alias to avoid warning, as pthread_exit is declared noreturn.  */"
    ],
    "pthread_setcanceltype(int, int *)": [
        "/* Use an alias to avoid warning, as pthread_exit is declared noreturn.  */"
    ],
    "__h_errno_location()": [],
    "pthread_yield()": [],
    "__gconv_get_cache()": [],
    "__gconv_create_spec(struct gconv_spec *, const char *, const char *)": [
        "/* We ignore suffixes in the fromcode because that is how the current\n     implementation has always handled them.  Only suffixes in the tocode are\n     processed and handled.  The reality is that invalid input in the input\n     character set should only be ignored if the fromcode specifies IGNORE.\n     The current implementation ignores invalid input in the input character\n     set if the tocode contains IGNORE.  We preserve this behavior for\n     backwards compatibility.  In the future we may split the handling of\n     IGNORE to allow a finer grained specification of ignoring invalid input\n     and/or ignoring invalid output.  */",
        "/* 3 extra bytes because 1 extra for '\\0', and 2 extra so strip might\n     be able to add one or two trailing '/' characters if necessary.  */",
        "/* Strip unrecognized characters and ensure that the code has two '/'\n     characters as per conversion code triplet specification.  */"
    ],
    "__gconv_get_modules_db()": [],
    "__gconv_get_alias_db()": [],
    "__gconv_open(struct gconv_spec *, __gconv_t *, int)": [
        "/* Find out whether any error handling method is specified.  */",
        "/* If the string is empty define this to mean the charset of the\n     currently selected locale.  */",
        "/* Allocate room for handle.  */",
        "/* Remember the list of steps.  */",
        "/* Clear the array for the step data.  */",
        "/* Call all initialization functions for the transformation\n\t     step implementations.  */",
        "/* Would have to be done if we would not clear the whole\n                 array above.  */",
        "/* Reset the counter.  */",
        "/* It's a regular use.  */",
        "/* We use the `mbstate_t' member in DATA.  */",
        "/* The builtin transliteration handling only\n\t\t supports the internal encoding.  */",
        "/* If this is the last step we must not allocate an\n\t\t output buffer.  */",
        "/* Allocate the buffer.  */",
        "/* Handle the last entry.  */",
        "/* Something went wrong.  Free all the resources.  */"
    ],
    "__gconv_transliterate(struct __gconv_step *, struct __gconv_step_data *, const unsigned char *, const unsigned char **, const unsigned char *, unsigned char **, int *)": [
        "/* Find out about the locale's transliteration.  */",
        "/* The input buffer.  There are actually 4-byte values.  */",
        "/* If there is no transliteration information in the locale don't do\n     anything and return the error.  */",
        "/* Get the rest of the values.  */",
        "/* Test whether there is enough input.  */",
        "/* The array starting at FROM_IDX contains indices to the string table\n     in FROM_TBL.  The indices are sorted wrt to the strings.  I.e., we\n     are doing binary search.  */",
        "/* Compare the string at this index with the string at the current\n\t position in the input buffer.  */",
        "/* Does not match.  */",
        "/* Found a matching input sequence.  Now try to convert the\n\t     possible replacements.  */",
        "/* Determine length of replacement.  */",
        "/* Try this input text.  */",
        "/* If the conversion succeeds we have to increment the\n\t\t     input buffer.  */",
        "/* Do not increment the output pointer if we could not\n\t\t     store the entire output. */",
        "/* Next replacement.  */",
        "/* Nothing found, continue searching.  */",
        "/* This means that the input buffer contents matches a prefix of\n\t   an entry.  Since we cannot match it unless we get more input,\n\t   we will tell the caller about it.  */",
        "/* Maybe the character is supposed to be ignored.  */",
        "/* Test whether there is enough input.  */",
        "/* Matches the range.  Ignore it.  */",
        "/* There cannot be any other matching range since they are\n             sorted.  */",
        "/* One last chance: use the default replacement.  */",
        "/* Test whether there is enough input.  */",
        "/* If the conversion succeeds we have to increment the\n\t     input buffer.  */",
        "/* This worked but is not reversible.  */",
        "/* Haven't found a match.  */"
    ],
    "iconv(iconv_t, char **, int *, char **, int *)": [
        "/* Nothing.  */"
    ],
    "iconv_close(iconv_t)": [],
    "iconv_open(const char *, const char *)": [
        "/* We must set the error number according to the specs.  */"
    ],
    "bindresvport(int, struct sockaddr_in *)": [
        "/* Initialize to make gcc happy.  */"
    ],
    "ether_aton(const char *)": [],
    "ether_aton_r(const char *, struct ether_addr *)": [
        "/* Store result.  */",
        "/* Skip ':'.  */"
    ],
    "ether_line(const char *, struct ether_addr *, char *)": [
        "/* Store result.  */",
        "/* Skip ':'.  */",
        "/* Skip initial whitespace.  */",
        "/* No hostname.  */",
        "/* The hostname is up to the next non-space character.  */",
        "/* XXX This can cause trouble because the hostname might be too long\n     but we have no possibility to check it here.  */"
    ],
    "ether_ntoa(const struct ether_addr *)": [],
    "ether_ntoa_r(const struct ether_addr *, char *)": [],
    "getipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t *, uint32_t *, struct in_addr *)": [
        "/* We have to create an struct ip_msfilter object which we can pass\n     to the kernel.  */",
        "/* If successful, copy the results to the places the caller wants\n     them in.  */"
    ],
    "getsourcefilter(int, uint32_t, const struct sockaddr *, socklen_t, uint32_t *, uint32_t *, struct sockaddr_storage *)": [
        "/* We have to create an struct ip_msfilter object which we can pass\n     to the kernel.  */",
        "/* We need to provide the appropriate socket level value.  */",
        "/* If successful, copy the results to the places the caller wants\n\t them in.  */"
    ],
    "htonl(uint32_t)": [],
    "htons(uint16_t)": [],
    "__idna_to_dns_encoding(const char *, char **)": [
        "/* Nothing to convert.  */",
        "/* Encoding needed.  Handled below.  */",
        "/* We report this as an encoding error (assuming that libidn2 is\n       not installed), although the root cause may be a temporary\n       error condition due to resource shortage.  */",
        "/* Assume that idn2_free is equivalent to free.  */"
    ],
    "inet6_opt_init(void *, socklen_t)": [
        "/* Fill in the length in units of 8 octets.  */",
        "/* RFC 2460 requires that the header extension length is the\n\t length of the option header in 8-byte units, not including\n\t the first 8 bytes.  Hence we have to subtract one.  */"
    ],
    "inet6_opt_append(void *, socklen_t, int, uint8_t, socklen_t, uint8_t, void **)": [
        "/* Check minimum offset.  */",
        "/* One cannot add padding options.  */",
        "/* The option length must fit in one octet.  */",
        "/* The alignment can only by 1, 2, 4, or 8 and must not exceed the\n     option length.  */",
        "/* Determine the needed padding for alignment.  Following the\n     current content of the buffer we have the is the IPv6 option type\n     and length, followed immediately by the data.  The data has the\n     alignment constraints.  Therefore padding must be inserted in the\n     form of padding options before the new option. */",
        "/* Now we can check whether the buffer is large enough.  */",
        "/* Now prepare the option itself.  */"
    ],
    "inet6_opt_finish(void *, socklen_t, int)": [
        "/* Check minimum offset.  */",
        "/* Required padding at the end.  */",
        "/* Make sure the buffer is large enough.  */"
    ],
    "inet6_opt_set_val(void *, int, void *, socklen_t)": [],
    "inet6_opt_next(void *, socklen_t, int, uint8_t *, socklen_t *, void **)": [
        "/* Single byte padding.  */",
        "/* Check whether the option is valid.  */"
    ],
    "inet6_opt_find(void *, socklen_t, int, uint8_t, socklen_t *, void **)": [
        "/* Single byte padding.  */",
        "/* Check whether the option is valid.  */"
    ],
    "inet6_opt_get_val(void *, int, void *, socklen_t)": [],
    "inet6_option_space(int)": [
        "/* Add room for the extension header.  */"
    ],
    "inet6_option_init(void *, struct cmsghdr **, int)": [
        "/* Only Hop-by-Hop or Destination options allowed.  */",
        "/* BP is a pointer to the previously allocated space.  */",
        "/* Initialize the message header.\n\n     Length: No data yet, only the cmsghdr struct.  */",
        "/* Originating protocol: obviously IPv6.  */",
        "/* Message type.  */",
        "/* Pass up the result.  */"
    ],
    "inet6_option_append(struct cmsghdr *, const uint8_t *, int, int)": [
        "/* typep is a pointer to the 8-bit option type.  It is assumed that this\n     field is immediately followed by the 8-bit option data length field,\n     which is then followed immediately by the option data.\n\n     The option types IP6OPT_PAD1 and IP6OPT_PADN also must be handled.  */",
        "/* Get the pointer to the space in the message.  */",
        "/* Some problem with the parameters.  */",
        "/* Copy the content.  */"
    ],
    "inet6_option_alloc(struct cmsghdr *, int, int, int)": [],
    "inet6_option_next(const struct cmsghdr *, uint8_t **)": [
        "/* Make sure it is an option of the right type.  */",
        "/* Pointer to the extension header.  We only compute the address, we\n     don't access anything yet.  */",
        "/* Make sure the message is long enough.  */",
        "/* Now we can access the extension header.  */",
        "/* Too small.  */",
        "/* Determine the address of the byte past the message.  */",
        "/* This is the first call, return the first option if there is one.  */",
        "/* Make sure *TPTRP points to a beginning of a new option in\n\t the message.  The upper limit is checked in get_opt_end.  */",
        "/* Get the beginning of the next option.  */",
        "/* We know where the next option starts.  */",
        "/* Check the option is fully represented in the message.  */"
    ],
    "inet6_option_find(const struct cmsghdr *, uint8_t **, int)": [
        "/* Make sure it is an option of the right type.  */",
        "/* Pointer to the extension header.  We only compute the address, we\n     don't access anything yet.  */",
        "/* Make sure the message is long enough.  */",
        "/* Now we can access the extension header.  */",
        "/* Too small.  */",
        "/* Determine the address of the byte past the message.  */",
        "/* This is the first call, return the first option if there is one.  */",
        "/* Make sure *TPTRP points to a beginning of a new option in\n\t the message.  The upper limit is checked in get_opt_end.  */",
        "/* Get the beginning of the next option.  */",
        "/* Now search for the appropriate typed entry.  */",
        "/* Get the end of this entry.  */",
        "/* We know where the next option starts.  */",
        "/* Success.  */"
    ],
    "inet6_rth_space(int, int)": [],
    "inet6_rth_init(void *, socklen_t, int, int)": [
        "/* Make sure the parameters are valid and the buffer is large enough.  */",
        "/* Some implementations seem to initialize the whole memory area.  */",
        "/* Length in units of 8 octets.  */"
    ],
    "inet6_rth_add(void *, const struct in6_addr *)": [],
    "inet6_rth_reverse(const void *, void *)": [
        "/* Copy header, not the addresses.  The memory regions can overlap.  */",
        "/* Remember, IN_RTHDR0 and OUT_RTHDR0 might overlap.  */"
    ],
    "inet6_rth_segments(const void *)": [],
    "inet6_rth_getaddr(const void *, int)": [],
    "__inet6_scopeid_pton(const struct in6_addr *, const char *, uint32_t *)": [
        "/*base */",
        "/* group */",
        "/* bin_cst */"
    ],
    "inet_lnaof(struct in_addr)": [],
    "inet_netof(struct in_addr)": [],
    "inet_ntoa(struct in_addr)": [],
    "rresvport_af(int *, sa_family_t)": [
        "/* NB: No SOCK_CLOEXEC for backwards compatibility.  */",
        "/* Ignore invalid values.  */"
    ],
    "ruserok_af(const char *, int, const char *, const char *, sa_family_t)": [],
    "iruserok_af(const void *, int, const char *, const char *, sa_family_t)": [],
    "rexec_af(char **, int, const char *, const char *, const char *, int *, sa_family_t)": [
        "/* XXX: set errno? */",
        "/* NB: No SOCK_CLOEXEC for backwards compatibility.  */",
        "/* should public key encrypt the password here */",
        "/* We don't need the memory allocated for the name and the password\n\t   in ruserpass anymore.  */"
    ],
    "ruserpass(const char *, const char **, const char **)": [
        "/* If we can't get HOME, fail instead of trying \".\",\n\t\t   which is no improvement. This really should call\n\t\t   getpwuid(getuid()).  */",
        "/*hdir = \".\";*/",
        "/* No threads use this stream.  */",
        "/* FALL THROUGH */",
        "/*\n\t\t\t * Allow match either for user's input host name\n\t\t\t * or official hostname.  Also allow match of\n\t\t\t * incompletely-specified host in local domain.\n\t\t\t */",
        "/*\t\t\tif (__strcasecmp(hostname, tokval) == 0)\n\t\t\t\tgoto match;\n\t\t\tif ((tmp = strchr(hostname, '.')) != NULL &&\n\t\t\t    __strcasecmp(tmp, mydomain) == 0 &&\n\t\t\t    __strncasecmp(hostname, tokval, tmp-hostname) == 0 &&\n\t\t\t    tokval[tmp - hostname] == '\\0')\n\t\t\t\tgoto match; */"
    ],
    "setipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t, uint32_t, const struct in_addr *)": [
        "/* We have to create an struct ip_msfilter object which we can pass\n     to the kernel.  */"
    ],
    "setsourcefilter(int, uint32_t, const struct sockaddr *, socklen_t, uint32_t, uint32_t, const struct sockaddr_storage *)": [
        "/* We have to create an struct ip_msfilter object which we can pass\n     to the kernel.  */",
        "/* We need to provide the appropriate socket level value.  */"
    ],
    "stpcpy(char *, const char *)": [
        "/* Do nothing. */"
    ],
    "mempcpy(void *, const void *, int)": [],
    "__close(int)": [],
    "copy_file_range(int, __off64_t *, int, __off64_t *, int, unsigned int)": [],
    "creat(const char *, mode_t)": [],
    "creat64(const char *, mode_t)": [],
    "__dup2(int, int)": [
        "/* For the degenerate case, check if the fd is valid (by trying to\n     get the file status flags) and return it, or else return EBADF.  */"
    ],
    "faccessat(int, const char *, int, int)": [],
    "fchmodat(int, const char *, mode_t, int)": [],
    "fchownat(int, const char *, uid_t, gid_t, int)": [],
    "__fcntl(int, int, ...)": [],
    "__file_is_unchanged(const struct file_change_detection *, const struct file_change_detection *)": [
        "/* Negative sizes are used as markers and never match.  */",
        "/* Both files are empty or do not exist, so they have the same\n       content, no matter what the other fields indicate.  */"
    ],
    "__fstat64(int, struct stat64 *)": [],
    "fts_open(char *const *, int, int (*)(const FTSENT **, const FTSENT **))": [
        "/* fts_build flags */",
        "/* fts_children */",
        "/* fts_children, names only */",
        "/* fts_read */",
        "/* Options check. */",
        "/* Allocate/initialize the stream */",
        "/* Logical walks turn on NOCHDIR; symbolic links are too hard. */",
        "/*\n\t * Start out with 1K of path space, and enough, in any case,\n\t * to hold the user's paths.\n\t */",
        "/* Allocate/initialize root's parent. */",
        "/* Allocate/initialize root(s). */",
        "/* Don't allow zero-length paths. */",
        "/* Command-line \".\" and \"..\" are real directories. */",
        "/*\n\t\t * If comparison routine supplied, traverse in sorted\n\t\t * order; otherwise traverse in the order specified.\n\t\t */",
        "/*\n\t * Allocate a dummy pointer and make fts_read think that we've just\n\t * finished the node before the root(s); set p->fts_info to FTS_INIT\n\t * so that everything about the \"current\" node is ignored.\n\t */",
        "/*\n\t * If using chdir(2), grab a file descriptor pointing to dot to ensure\n\t * that we can get back here; this could be avoided for some paths,\n\t * but almost certainly not worth the effort.  Slashes, symbolic links,\n\t * and \"..\" are all fairly nasty problems.  Note, if we can't get the\n\t * descriptor we run anyway, just more slowly.\n\t */"
    ],
    "fts_close(FTS *)": [
        "/*\n\t * This still works if we haven't read anything -- the dummy structure\n\t * points to the root list, so we step through to the end of the root\n\t * list which has a valid parent pointer.\n\t */",
        "/* Free up child linked list, sort array, path buffer. */",
        "/* Return to original directory, save errno if necessary. */",
        "/* Set errno and return. */",
        "/* Free up the stream pointer. */",
        "/* Free up the stream pointer. */"
    ],
    "fts_read(FTS *)": [
        "/* fts_build flags */",
        "/* fts_children */",
        "/* fts_children, names only */",
        "/* fts_read */",
        "/* Options check. */",
        "/* Allocate/initialize the stream */",
        "/* Logical walks turn on NOCHDIR; symbolic links are too hard. */",
        "/*\n\t * Start out with 1K of path space, and enough, in any case,\n\t * to hold the user's paths.\n\t */",
        "/* Allocate/initialize root's parent. */",
        "/* Allocate/initialize root(s). */",
        "/* Don't allow zero-length paths. */",
        "/* Command-line \".\" and \"..\" are real directories. */",
        "/*\n\t\t * If comparison routine supplied, traverse in sorted\n\t\t * order; otherwise traverse in the order specified.\n\t\t */",
        "/*\n\t * Allocate a dummy pointer and make fts_read think that we've just\n\t * finished the node before the root(s); set p->fts_info to FTS_INIT\n\t * so that everything about the \"current\" node is ignored.\n\t */",
        "/*\n\t * If using chdir(2), grab a file descriptor pointing to dot to ensure\n\t * that we can get back here; this could be avoided for some paths,\n\t * but almost certainly not worth the effort.  Slashes, symbolic links,\n\t * and \"..\" are all fairly nasty problems.  Note, if we can't get the\n\t * descriptor we run anyway, just more slowly.\n\t */",
        "/*\n\t * Load the stream structure for the next traversal.  Since we don't\n\t * actually enter the directory until after the preorder visit, set\n\t * the fts_accpath field specially so the chdir gets done to the right\n\t * place and the user can access the first node.  From fts_open it's\n\t * known that the path will fit.\n\t */",
        "/*\n\t * This still works if we haven't read anything -- the dummy structure\n\t * points to the root list, so we step through to the end of the root\n\t * list which has a valid parent pointer.\n\t */",
        "/* Free up child linked list, sort array, path buffer. */",
        "/* Return to original directory, save errno if necessary. */",
        "/* Set errno and return. */",
        "/* Free up the stream pointer. */",
        "/* Free up the stream pointer. */",
        "/*\n * Special case of \"/\" at the end of the path so that slashes aren't\n * appended which would cause paths to be written as \"....//foo\".\n */",
        "/* If finished or unrecoverable error, return NULL. */",
        "/* Set current node pointer. */",
        "/* Save and zero out user instructions. */",
        "/* Any type of file may be re-visited; re-stat and re-turn. */",
        "/*\n\t * Following a symlink -- SLNONE test allows application to see\n\t * SLNONE and recover.  If indirecting through a symlink, have\n\t * keep a pointer to current location.  If unable to get that\n\t * pointer, follow fails.\n\t */",
        "/* Directory in pre-order. */",
        "/* If skipped or crossed mount point, do post-order visit. */",
        "/* Rebuild if only read the names and now traversing. */",
        "/*\n\t\t * Cd to the subdirectory.\n\t\t *\n\t\t * If have already read and now fail to chdir, whack the list\n\t\t * to make the names come out right, and set the parent errno\n\t\t * so the application will eventually get an error condition.\n\t\t * Set the FTS_DONTCHDIR flag so that when we logically change\n\t\t * directories back to the parent we don't do a chdir.\n\t\t *\n\t\t * If haven't read do so.  If the read fails, fts_build sets\n\t\t * FTS_STOP or the fts_info field of the node.\n\t\t */",
        "/* Move to the next node on this level. */",
        "/*\n\t\t * If reached the top, return to the original directory (or\n\t\t * the root of the tree), and load the paths for the next root.\n\t\t */",
        "/*\n\t\t * User may have called fts_set on the node.  If skipped,\n\t\t * ignore.  If followed, get a file descriptor so we can\n\t\t * get back if necessary.\n\t\t */",
        "/* Move up to the parent node. */",
        "/*\n\t\t * Done; free everything up and set errno to 0 so the user\n\t\t * can distinguish between error and EOF.\n\t\t */",
        "/* NUL terminate the pathname. */",
        "/*\n\t * Return to the parent directory.  If at a root node or came through\n\t * a symlink, go back through the file descriptor.  Otherwise, cd up\n\t * one directory.\n\t */"
    ],
    "fts_set(FTS *, FTSENT *, int)": [],
    "fts_children(FTS *, int)": [
        "/* fts_build flags */",
        "/* fts_children */",
        "/* fts_children, names only */",
        "/* fts_read */",
        "/* Options check. */",
        "/* Allocate/initialize the stream */",
        "/* Logical walks turn on NOCHDIR; symbolic links are too hard. */",
        "/*\n\t * Start out with 1K of path space, and enough, in any case,\n\t * to hold the user's paths.\n\t */",
        "/* Allocate/initialize root's parent. */",
        "/* Allocate/initialize root(s). */",
        "/* Don't allow zero-length paths. */",
        "/* Command-line \".\" and \"..\" are real directories. */",
        "/*\n\t\t * If comparison routine supplied, traverse in sorted\n\t\t * order; otherwise traverse in the order specified.\n\t\t */",
        "/*\n\t * Allocate a dummy pointer and make fts_read think that we've just\n\t * finished the node before the root(s); set p->fts_info to FTS_INIT\n\t * so that everything about the \"current\" node is ignored.\n\t */",
        "/*\n\t * If using chdir(2), grab a file descriptor pointing to dot to ensure\n\t * that we can get back here; this could be avoided for some paths,\n\t * but almost certainly not worth the effort.  Slashes, symbolic links,\n\t * and \"..\" are all fairly nasty problems.  Note, if we can't get the\n\t * descriptor we run anyway, just more slowly.\n\t */",
        "/*\n\t * Load the stream structure for the next traversal.  Since we don't\n\t * actually enter the directory until after the preorder visit, set\n\t * the fts_accpath field specially so the chdir gets done to the right\n\t * place and the user can access the first node.  From fts_open it's\n\t * known that the path will fit.\n\t */",
        "/*\n\t * This still works if we haven't read anything -- the dummy structure\n\t * points to the root list, so we step through to the end of the root\n\t * list which has a valid parent pointer.\n\t */",
        "/* Free up child linked list, sort array, path buffer. */",
        "/* Return to original directory, save errno if necessary. */",
        "/* Set errno and return. */",
        "/* Free up the stream pointer. */",
        "/* Free up the stream pointer. */",
        "/*\n * Special case of \"/\" at the end of the path so that slashes aren't\n * appended which would cause paths to be written as \"....//foo\".\n */",
        "/* If finished or unrecoverable error, return NULL. */",
        "/* Set current node pointer. */",
        "/* Save and zero out user instructions. */",
        "/* Any type of file may be re-visited; re-stat and re-turn. */",
        "/*\n\t * Following a symlink -- SLNONE test allows application to see\n\t * SLNONE and recover.  If indirecting through a symlink, have\n\t * keep a pointer to current location.  If unable to get that\n\t * pointer, follow fails.\n\t */",
        "/* Directory in pre-order. */",
        "/* If skipped or crossed mount point, do post-order visit. */",
        "/* Rebuild if only read the names and now traversing. */",
        "/*\n\t\t * Cd to the subdirectory.\n\t\t *\n\t\t * If have already read and now fail to chdir, whack the list\n\t\t * to make the names come out right, and set the parent errno\n\t\t * so the application will eventually get an error condition.\n\t\t * Set the FTS_DONTCHDIR flag so that when we logically change\n\t\t * directories back to the parent we don't do a chdir.\n\t\t *\n\t\t * If haven't read do so.  If the read fails, fts_build sets\n\t\t * FTS_STOP or the fts_info field of the node.\n\t\t */",
        "/* Move to the next node on this level. */",
        "/*\n\t\t * If reached the top, return to the original directory (or\n\t\t * the root of the tree), and load the paths for the next root.\n\t\t */",
        "/*\n\t\t * User may have called fts_set on the node.  If skipped,\n\t\t * ignore.  If followed, get a file descriptor so we can\n\t\t * get back if necessary.\n\t\t */",
        "/* Move up to the parent node. */",
        "/*\n\t\t * Done; free everything up and set errno to 0 so the user\n\t\t * can distinguish between error and EOF.\n\t\t */",
        "/* NUL terminate the pathname. */",
        "/*\n\t * Return to the parent directory.  If at a root node or came through\n\t * a symlink, go back through the file descriptor.  Otherwise, cd up\n\t * one directory.\n\t */",
        "/*\n * Fts_set takes the stream as an argument although it's not used in this\n * implementation; it would be necessary if anyone wanted to add global\n * semantics to fts using fts_set.  An error return is allowed for similar\n * reasons.\n */",
        "/* ARGSUSED */",
        "/* Set current node pointer. */",
        "/*\n\t * Errno set to 0 so user can distinguish empty directory from\n\t * an error.\n\t */",
        "/* Fatal errors stop here. */",
        "/* Return logical hierarchy of user's arguments. */",
        "/*\n\t * If not a directory being visited in pre-order, stop here.  Could\n\t * allow FTS_DNR, assuming the user has fixed the problem, but the\n\t * same effect is available with FTS_AGAIN.\n\t */",
        "/* && p->fts_info != FTS_DNR */",
        "/* Free up any previous child list. */",
        "/*\n\t * If using chdir on a relative path and called BEFORE fts_read does\n\t * its chdir to the root of a traversal, we can lose -- we need to\n\t * chdir into the subdirectory, and we don't know where the current\n\t * directory is, so we can't get back so that the upcoming chdir by\n\t * fts_read will work.\n\t */"
    ],
    "fts64_open(char *const *, int, int (*)(const int **, const int **))": [],
    "fts64_close(int *)": [
        "/*\n\t * This still works if we haven't read anything -- the dummy structure\n\t * points to the root list, so we step through to the end of the root\n\t * list which has a valid parent pointer.\n\t */",
        "/* Free up child linked list, sort array, path buffer. */",
        "/* Return to original directory, save errno if necessary. */",
        "/* Set errno and return. */",
        "/* Free up the stream pointer. */",
        "/* Free up the stream pointer. */"
    ],
    "fts64_read(int *)": [],
    "fts64_set(int *, int *, int)": [],
    "fts64_children(int *, int)": [],
    "ftw(const char *, __ftw_func_t, int)": [],
    "ftw64(const char *, int, int)": [],
    "futimens(int, const struct timespec *)": [],
    "get_current_dir_name()": [
        "/* The PWD value is correct.  Use it.  */"
    ],
    "getwd(char *)": [
        "/* We use 1024 here since it should really be enough and because\n\t this is a safe value.  */",
        "/* This is completely unsafe.  Nobody can say how big the user\n     provided buffer is.  Perhaps the application and the libc\n     disagree about the value of PATH_MAX.  */"
    ],
    "lchmod(const char *, mode_t)": [],
    "linkat(int, const char *, int, const char *, int)": [],
    "mkdirat(int, const char *, mode_t)": [
        "/* Check FD is associated with a directory.  */"
    ],
    "mkfifo(const char *, mode_t)": [],
    "mkfifoat(int, const char *, mode_t)": [],
    "__open64_2(const char *, int)": [],
    "__open_2(const char *, int)": [],
    "__openat64_2(int, const char *, int)": [],
    "__openat_2(int, const char *, int)": [],
    "__pipe(int *)": [],
    "__poll(struct pollfd *, nfds_t, int)": [],
    "posix_fadvise(int, __off_t, __off_t, int)": [],
    "posix_fadvise64(int, __off64_t, __off64_t, int)": [],
    "posix_fallocate(int, __off_t, __off_t)": [],
    "posix_fallocate64(int, __off64_t, __off64_t)": [],
    "ppoll(struct pollfd *, nfds_t, const struct timespec *, const sigset_t *)": [],
    "readlinkat(int, const char *, char *, int)": [],
    "sendfile(int, int, off_t *, int)": [],
    "sendfile64(int, int, int *, int)": [],
    "__statfs(const char *, struct statfs *)": [],
    "statx(int, const char *, int, unsigned int, struct statx *)": [
        "/* Preserve non-error/non-ENOSYS return values.  */"
    ],
    "symlinkat(const char *, int, const char *)": [],
    "ttyname(int)": [],
    "unlinkat(int, const char *, int)": [],
    "utime(const char *, const struct utimbuf *)": [],
    "utimensat(int, const char *, const struct timespec *, int)": [],
    "__fbufsize(FILE *)": [],
    "__flbf(FILE *)": [],
    "__fpending(FILE *)": [],
    "__fpurge(FILE *)": [
        "/* Wide-char stream.  */",
        "/* Byte stream.  */"
    ],
    "__freadable(FILE *)": [],
    "__freading(FILE *)": [],
    "__fsetlocking(FILE *, int)": [],
    "__fwritable(FILE *)": [],
    "__fwriting(FILE *)": [],
    "clearerr(FILE *)": [
        "/*nothing*/"
    ],
    "clearerr_unlocked(FILE *)": [
        "/*nothing*/"
    ],
    "_IO_feof(FILE *)": [],
    "_IO_ferror(FILE *)": [],
    "_IO_file_doallocate(FILE *)": [
        "/* Possibly a tty.  */"
    ],
    "fputc(int, FILE *)": [],
    "fputwc(int, FILE *)": [],
    "fputwc_unlocked(int, FILE *)": [],
    "freopen(const char *, const char *, FILE *)": [
        "/* First flush the stream (failure should be ignored).  */",
        "/* If the shared C library is used by the application binary which\n\t was linked against the older version of libio, we just use the\n\t older one even for internal use to avoid trouble since a pointer\n\t to the old libio may be passed into shared C library and wind\n\t up here. */",
        "/* unbound stream orientation */",
        "/* At this point we have both file descriptors already allocated,\n\t     so __dup3 will not fail with EBADF, EINVAL, or EMFILE.  But\n\t     we still need to check for EINVAL and, due Linux internal\n\t     implementation, EBUSY.  It is because on how it internally opens\n\t     the file by splitting the buffer allocation operation and VFS\n\t     opening (a dup operation may run when a file is still pending\n\t     'install' on VFS).  */"
    ],
    "freopen64(const char *, const char *, FILE *)": [
        "/* First flush the stream (failure should be ignored).  */",
        "/* unbound stream orientation */",
        "/* At this point we have both file descriptors already allocated,\n\t     so __dup3 will not fail with EBADF, EINVAL, or EMFILE.  But\n\t     we still need to check for EINVAL and, due Linux internal\n\t     implementation, EBUSY.  It is because on how it internally opens\n\t     the file by splitting the buffer allocation operation and VFS\n\t     opening (a dup operation may run when a file is still pending\n\t     'install' on VFS).  */"
    ],
    "fseek(FILE *, long, int)": [],
    "fwide(FILE *, int)": [
        "/* Normalize the value.  */",
        "/* The caller simply wants to know about the current orientation\n       or the orientation already has been determined.  */"
    ],
    "_IO_un_link(struct _IO_FILE_plus *)": [],
    "_IO_switch_to_get_mode(FILE *)": [],
    "__underflow(FILE *)": [],
    "_IO_default_uflow(FILE *)": [],
    "_IO_enable_locks()": [],
    "_IO_default_finish(FILE *, int)": [],
    "_IO_init_marker(struct _IO_marker *, FILE *)": [
        "/* Should perhaps sort the chain? */"
    ],
    "_IO_remove_marker(struct _IO_marker *)": [
        "/* Unlink from sb's chain. */",
        "/* FIXME: if _sbuf has a backup area that is no longer needed,\n     should we delete it now, or wait until the next underflow? */"
    ],
    "_IO_marker_difference(struct _IO_marker *, struct _IO_marker *)": [],
    "_IO_marker_delta(struct _IO_marker *)": [],
    "_IO_seekmark(FILE *, struct _IO_marker *, int)": [],
    "_IO_unsave_markers(FILE *)": [],
    "_IO_getc(FILE *)": [],
    "getwchar()": [],
    "getwchar_unlocked()": [],
    "_IO_fflush(FILE *)": [],
    "_IO_fgets(char *, int, FILE *)": [
        "/* Another irregular case: since we have to store a NUL byte and\n\t there is only room for exactly one byte, we don't have to\n\t read anything.  */",
        "/* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */",
        "/* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */"
    ],
    "fgetws(int *, int, FILE *)": [
        "/* Another irregular case: since we have to store a NUL byte and\n\t there is only room for exactly one byte, we don't have to\n\t read anything.  */",
        "/* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */",
        "/* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */"
    ],
    "fgetws_unlocked(int *, int, FILE *)": [
        "/* Another irregular case: since we have to store a NUL byte and\n\t there is only room for exactly one byte, we don't have to\n\t read anything.  */",
        "/* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */",
        "/* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */"
    ],
    "_IO_fputs(const char *, FILE *)": [],
    "fputws(const int *, FILE *)": [],
    "fputws_unlocked(const int *, FILE *)": [],
    "_IO_fread(void *, int, int, FILE *)": [],
    "_IO_ftell(FILE *)": [],
    "_IO_fwrite(const void *, int, int, FILE *)": [
        "/* We have written all of the input in case the return value indicates\n     this or EOF is returned.  The latter is a special case where we\n     simply did not manage to flush the buffer.  But the data is in the\n     buffer and therefore written as far as fwrite is concerned.  */"
    ],
    "fwrite_unlocked(const void *, int, int, FILE *)": [
        "/* We have written all of the input in case the return value indicates\n\t this or EOF is returned.  The latter is a special case where we\n\t simply did not manage to flush the buffer.  But the data is in the\n\t buffer and therefore written as far as fwrite is concerned.  */"
    ],
    "__getdelim(char **, int *, int, FILE *)": [
        "/* Make enough space for len+1 (for final NUL) bytes.  */",
        "/* Be generous. */"
    ],
    "_IO_getline(FILE *, char *, int, int, int)": [],
    "_IO_gets(char *)": [
        "/* This is very tricky since a file descriptor may be in the\n\t non-blocking mode. The error flag doesn't mean much in this\n\t case. We return an error only when there is a new error. */"
    ],
    "_IO_padn(FILE *, int, ssize_t)": [],
    "_IO_puts(const char *)": [],
    "_IO_seekoff(FILE *, int, int, int)": [],
    "_IO_seekpos(FILE *, int, int)": [],
    "_IO_setbuffer(FILE *, char *, int)": [
        "/* We also have to set the buffer using the wide char function.  */"
    ],
    "_IO_setvbuf(FILE *, char *, int, int)": [
        "/* There is no flag to distinguish between \"fully buffered\n\t\t mode has been explicitly set\" as opposed to \"line\n\t\t buffering has not been explicitly set\".  In both\n\t\t cases, _IO_LINE_BUF is off.  If this is a tty, and\n\t\t _IO_filedoalloc later gets called, it cannot know if\n\t\t it should set the _IO_LINE_BUF flag (because that is\n\t\t the default), or not (because we have explicitly asked\n\t\t for fully buffered mode).  So we make sure a buffer\n\t\t gets allocated now, and explicitly turn off line\n\t\t buffering.\n\n\t\t A possibly cleaner alternative would be to add an\n\t\t extra flag, but then flags are a finite resource.  */"
    ],
    "ungetc(int, FILE *)": [],
    "ungetwc(wint_t, FILE *)": [],
    "__libc_fatal(const char *)": [
        "/* The loop is added only to keep gcc happy.  */"
    ],
    "_IO_peekc_locked(FILE *)": [],
    "_IO_putc(int, FILE *)": [],
    "putwc(int, FILE *)": [],
    "putwc_unlocked(int, FILE *)": [],
    "putwchar(int)": [],
    "putwchar_unlocked(int)": [],
    "rewind(FILE *)": [],
    "setbuf(FILE *, char *)": [],
    "setlinebuf(FILE *)": [],
    "_IO_str_init_static(_IO_strfile *, char *, int, char *)": [],
    "_IO_str_init_readonly(_IO_strfile *, const char *, int)": [],
    "_IO_str_overflow(FILE *, int)": [
        "/* not allowed to enlarge */",
        "/*\t  __ferror(fp) = 1; */",
        "/* Make sure _IO_setb won't try to delete _IO_buf_base. */"
    ],
    "_IO_str_seekoff(FILE *, int, int, int)": [
        "/* Move the get pointer, if requested. */",
        "/* case _IO_seek_end: */",
        "/* Move the put pointer, if requested. */",
        "/* case _IO_seek_end: */"
    ],
    "_IO_wdo_write(FILE *, const int *, int)": [
        "/* Make sure we have room for at least one multibyte\n\t\t character.  */",
        "/* Now convert from the internal format into the external buffer.  */",
        "/* Write out what we produced so far.  */",
        "/* Something went wrong.  */",
        "/* Next see whether we had problems during the conversion.  If yes,\n\t     we cannot go on.  */"
    ],
    "_IO_wfile_overflow(FILE *, wint_t)": [
        "/* SET ERROR */",
        "/* If currently reading or no buffer allocated. */",
        "/* Allocate a buffer if needed. */",
        "/* Otherwise must be currently reading.  If _IO_read_ptr\n\t     (and hence also _IO_read_end) is at the buffer end,\n\t     logically slide the buffer forwards one block (by setting\n\t     the read pointers to all point at the beginning of the\n\t     block).  This makes room for subsequent output.\n\t     Otherwise, set the read pointers to _IO_read_end (leaving\n\t     that alone, so it can continue to correspond to the\n\t     external position). */",
        "/* Buffer is really full */"
    ],
    "_IO_wfile_seekoff(FILE *, int, int, int)": [
        "/* Short-circuit into a separate function.  We don't want to mix any\n     functionality and we don't want to touch anything inside the FILE\n     object. */",
        "/* POSIX.1 8.2.3.7 says that after a call the fflush() the file\n     offset of the underlying file must be exact.  */",
        "/* Flush unwritten characters.\n     (This may do an unneeded write if we seek within the buffer.\n     But to be able to switch to reading, we would need to set\n     egptr to pptr.  That can't be done in the current design,\n     which assumes file_ptr() is eGptr.  Anyway, since we probably\n     end up flushing when we close(), it doesn't make much difference.)\n     FIXME: simulate mem-mapped files. */",
        "/* It could be that we already have a pushback buffer.  */",
        "/* Adjust for read-ahead (bytes is buffer).  To do this we must\n\t find out which position in the external buffer corresponds to\n\t the current position in the internal buffer.  */",
        "/* Adjust by readahead in external buffer.  */",
        "/* Make offset absolute, assuming current pointer is file_ptr(). */",
        "/* At this point, dir==_IO_seek_set. */",
        "/* If destination is within current buffer, optimize: */",
        "/* Try to seek to a block boundary, to improve kernel page management. */",
        "/* We weren't allowed to read, but try to seek the remainder. */",
        "/* We need to do it since it is possible that the file offset in\n     the kernel may be changed behind our back. It may happen when\n     we fopen a file and then do a fork. One process may access the\n     file and the kernel file offset will be changed. */"
    ],
    "_IO_least_wmarker(FILE *, int *)": [],
    "open_wmemstream(int **, int *)": [
        "/* Disable single thread optimization.  BZ 21735.  */"
    ],
    "__ctype_get_mb_cur_max()": [],
    "__duplocale(locale_t)": [
        "/* This static object is returned for newlocale (LC_ALL_MASK, \"C\").  */",
        "/* Handle a special value.  */",
        "/* Calculate the total space we need to store all the names.  */",
        "/* Get memory.  */",
        "/* We modify global data (the usage counts).  */",
        "/* Update the special members.  */",
        "/* It's done.  */"
    ],
    "__freelocale(locale_t)": [
        "/* This static object is returned for newlocale (LC_ALL_MASK, \"C\").  */",
        "/* We modify global data (the usage counts).  */",
        "/* We can remove the data.  */",
        "/* It's done.  */",
        "/* Free the locale_t handle itself.  */"
    ],
    "__newlocale(int, const char *, locale_t)": [
        "/* Intermediate memory for result.  */",
        "/* We treat LC_ALL in the same way as if all bits were set.  */",
        "/* Sanity check for CATEGORY argument.  */",
        "/* `newlocale' does not support asking for the locale name. */",
        "/* We're to modify BASE, returned for a previous call with \"C\".\n       We can't really modify the read-only structure, so instead\n       start over by copying it.  */",
        "/* Asking for the \"C\" locale needn't allocate a new object.  */",
        "/* Allocate memory for the result.  */",
        "/* Fill with pointers to C locale data.  */",
        "/* If no category is to be set we return BASE if available or a\n     dataset using the C locale data.  */",
        "/* We perhaps really have to load some data.  So we determine the\n     path in which to look for the data now.  The environment variable\n     `LOCPATH' must only be used when the binary has no SUID or SGID\n     bit set.  If using the default path, we tell _nl_find_locale\n     by passing null and it can check the canonical locale archive.  */",
        "/* Get the names for the locales we are interested in.  We either\n     allow a composite name or a single name.  */",
        "/* This is a composite name.  Make a copy and split it up.  */",
        "/* Bogus category name.  */",
        "/* Found the category this clause sets.  */",
        "/* Examine the next clause.  */",
        "/* This was the last clause.  We are done.  */",
        "/* The composite name did not specify all categories we need.  */",
        "/* Protect global data.  */",
        "/* Now process all categories we are interested in.  */",
        "/* We can remove the data.  */",
        "/* Critical section left.  */",
        "/* Tally up the unchanged names from BASE as well.  */",
        "/* We successfully loaded all required data.  Allocate a new structure.\n     We can't just reuse the BASE pointer, because the name strings are\n     changing and we need the old name string area intact so we can copy\n     out of it into the new one without overlap problems should some\n     category's name be getting longer.  */",
        "/* Fill in this new structure from scratch.  */",
        "/* Install copied new names in the new structure's __names array.\n\t If resolved to \"C\", that is already in RESULT.__names to start.  */",
        "/* We modify the base structure.  */",
        "/* We can remove the old data.  */",
        "/* The RESULT members point into the old BASE structure.  */",
        "/* Critical section left.  */",
        "/* Update the special members.  */"
    ],
    "nl_langinfo(nl_item)": [],
    "__nl_langinfo_l(nl_item, locale_t)": [
        "/* Bogus category: bogus item.  */",
        "/* Special case value for NL_LOCALE_NAME (category).\n     This is not a real item index in the string table.  */",
        "/* Make direct reference to every _nl_current_CATEGORY symbol,\n     since we know only at runtime which categories are used.  */",
        "/* Should be impossible.  */",
        "/* Bogus index for this category: bogus item.  */",
        "/* Return the string for the specified item.  */"
    ],
    "setlocale(int, const char *)": [
        "/* Sanity check for CATEGORY argument.  */",
        "/* Does user want name of current locale?  */",
        "/* Protect global data.  */",
        "/* Changing to the same thing.  */",
        "/* We perhaps really have to load some data.  So we determine the\n     path in which to look for the data now.  The environment variable\n     `LOCPATH' must only be used when the binary has no SUID or SGID\n     bit set.  If using the default path, we tell _nl_find_locale\n     by passing null and it can check the canonical locale archive.  */",
        "/* The user wants to set all categories.  The desired locales\n\t for the individual categories can be selected by using a\n\t composite locale name.  This is a semi-colon separated list\n\t of entries of the form `CATEGORY=VALUE'.  */",
        "/* Copy of the locale argument, for in-place splitting.  */",
        "/* Set all name pointers to the argument name.  */",
        "/* This is a composite name.  Make a copy and split it up.  */",
        "/* Bogus category name.  */",
        "/* Found the category this clause sets.  */",
        "/* Examine the next clause.  */",
        "/* This was the last clause.  We are done.  */",
        "/* The composite name did not specify all categories.  */",
        "/* Load the new data for each category.  */",
        "/* Null because it's the weak value of _nl_C_LC_FOO.  */",
        "/* We must not simply free a global locale since we have\n\t       no control over the usage.  So we mark it as\n\t       un-deletable.  And yes, the 'if' is needed, the data\n\t       might be in read-only memory.  */",
        "/* Make a copy of locale name.  */",
        "/* Create new composite name.  */",
        "/* Now we have loaded all the new data.  Put it in place.  */",
        "/* We successfully loaded a new locale.  Let the message catalog\n\t     functions know about this.  */",
        "/* Critical section left.  */",
        "/* Free the resources.  */",
        "/* Only actually load the data if anything will use it.  */",
        "/* We must not simply free a global locale since we have no\n\t     control over the usage.  So we mark it as un-deletable.\n\n\t     Note: do not remove the `if', it's necessary to cope with\n\t     the builtin locale data.  */",
        "/* Make a copy of locale name.  */",
        "/* Create new composite name.  */",
        "/* Say that we don't have any data loaded.  */",
        "/* We successfully loaded a new locale.  Let the message catalog\n\t     functions know about this.  */",
        "/* Critical section left.  */",
        "/* Free the resources (the locale path variable.  */"
    ],
    "__uselocale(locale_t)": [
        "/* Now we must update all the per-category thread-local variables to\n\t point into the new current locale for this thread.  The magic\n\t symbols _nl_current_LC_FOO_used are defined to meaningless values\n\t if _nl_current_LC_FOO was linked in.  By using weak references to\n\t both symbols and testing the address of _nl_current_LC_FOO_used,\n\t we can avoid accessing the _nl_current_LC_FOO thread-local\n\t variable at all when no code referring to it was linked in.  We\n\t need the special bogus symbol because while TLS symbols can be\n\t weak, there is no reasonable way to test for the default-zero\n\t value as with a heap symbol (taking the address would just use\n\t some bogus offset from our thread pointer).  */",
        "/* Update the special tsd cache of some locale data.  */"
    ],
    "endutxent()": [],
    "getlogin()": [],
    "__getlogin_r_chk(char *, int, int)": [],
    "getutmp(const struct utmpx *, struct utmp *)": [],
    "getutmpx(const struct utmp *, struct utmpx *)": [],
    "getutxent()": [],
    "getutxid(const struct utmpx *)": [],
    "getutxline(const struct utmpx *)": [],
    "grantpt(int)": [
        "/* Without pt_chown on Linux, we have delegated the creation of the\n     pty node with the right group and permission mode to the kernel, and\n     non-root users are unlikely to be able to change it. Therefore let's\n     consider that POSIX enforcement is the responsibility of the whole\n     system and not only the GNU libc.   */",
        "/* Verify that fd refers to a ptmx descriptor.  */",
        "/* POSIX requires EINVAL instead of ENOTTY provided by the kernel.  */"
    ],
    "ptsname(int)": [],
    "__ptsname_r_chk(int, char *, int, int)": [],
    "pututxline(const struct utmpx *)": [],
    "setlogin(const char *)": [],
    "setutxent()": [],
    "unlockpt(int)": [
        "/* POSIX mandates EINVAL for non-ptmx descriptors.  */"
    ],
    "updwtmpx(const char *, const struct utmpx *)": [],
    "utmpxname(const char *)": [],
    "__libc_alloc_buffer_alloc_array(struct alloc_buffer *, int, int, int)": [
        "/* The caller asserts that align is a power of two.  */",
        "/* Multiplication did not overflow.  */",
        "/* No overflow in align step.  */",
        "/* No overflow in size computation.  */",
        "/* Room in buffer.  */"
    ],
    "__libc_alloc_buffer_allocate(int, void **)": [],
    "__libc_alloc_buffer_copy_bytes(struct alloc_buffer, const void *, int)": [],
    "__libc_alloc_buffer_copy_string(struct alloc_buffer, const char *)": [],
    "__libc_alloc_buffer_create_failure(void *, int)": [],
    "__libc_dynarray_at_failure(int, int)": [],
    "__libc_dynarray_emplace_enlarge(struct dynarray_header *, void *, int)": [
        "/* No scratch buffer provided.  Choose a reasonable default\n         size.  */",
        "/* Increase the allocated size, using an exponential growth\n       policy.  */",
        "/* Overflow.  */",
        "/* The previous array was not heap-allocated.  */"
    ],
    "__libc_dynarray_finalize(struct dynarray_header *, void *, int, struct dynarray_finalize_result *)": [
        "/* The caller will reported the deferred error.  */",
        "/* Empty list.  */",
        "/* An empty list could still be backed by a heap-allocated\n         array.  Free it if necessary.  */",
        "/* The new array takes ownership of the strings.  */",
        "/* The caller will perform the freeing operation.  */"
    ],
    "__libc_dynarray_resize(struct dynarray_header *, int, void *, int)": [
        "/* The existing allocation provides sufficient room.  */",
        "/* Otherwise, use size as the new allocation size.  The caller is\n     expected to provide the final size of the array, so there is no\n     over-allocation here.  */",
        "/* Overflow.  */",
        "/* The previous array was not heap-allocated.  */"
    ],
    "__libc_mallopt(int, int)": [
        "/* We must consolidate main arena before changing max_fast\n     (see definition of set_max_fast).  */",
        "/* Many of these helper functions take a size_t.  We do not worry\n     about overflow here, because negative int values will wrap to\n     very large size_t values and the helpers have sufficient range\n     checking for such conversions.  Many of these helpers are also\n     used by the tunables macros in arena.c.  */"
    ],
    "mcheck_check_all()": [],
    "mcheck(void (*)(enum mcheck_status))": [],
    "mcheck_pedantic(void (*)(enum mcheck_status))": [],
    "mprobe(void *)": [],
    "mtrace()": [],
    "muntrace()": [],
    "realloc(void *, int)": [],
    "free(void *)": [],
    "mmap(void *, int, int, int, int, off_t)": [
        "/* Determine real implementation if not already happened.  */",
        "/* Always get a block.  We don't need extra memory.  */",
        "/* Keep track of number of calls.  */",
        "/* Keep track of total memory consumption for `malloc'.  */",
        "/* Keep track of total memory requirement.  */",
        "/* Remember the size of the request.  */",
        "/* Total number of calls of any of the functions.  */",
        "/* Check for failures.  */",
        "/* Update the allocation data and write out the records if\n           necessary.  Note the first parameter is NULL which means\n           the size is not tracked.  */",
        "/* Return the pointer to the user buffer.  */"
    ],
    "mmap64(void *, int, int, int, int, int)": [
        "/* Determine real implementation if not already happened.  */",
        "/* Always get a block.  We don't need extra memory.  */",
        "/* Keep track of number of calls.  */",
        "/* Keep track of total memory consumption for `malloc'.  */",
        "/* Keep track of total memory requirement.  */",
        "/* Remember the size of the request.  */",
        "/* Total number of calls of any of the functions.  */",
        "/* Check for failures.  */",
        "/* Update the allocation data and write out the records if\n           necessary.  Note the first parameter is NULL which means\n           the size is not tracked.  */",
        "/* Return the pointer to the user buffer.  */"
    ],
    "mremap(void *, int, int, int, ...)": [
        "/* Determine real implementation if not already happened.  */",
        "/* Always get a block.  We don't need extra memory.  */",
        "/* Keep track of number of calls.  */",
        "/* Keep track of total memory consumption for `malloc'.  */",
        "/* Keep track of total memory requirement.  */",
        "/* Remember the size of the request.  */",
        "/* Total number of calls of any of the functions.  */",
        "/* Check for failures.  */",
        "/* Record whether the reduction/increase happened in place.  */",
        "/* Was the buffer increased?  */",
        "/* Update the allocation data and write out the records if\n             necessary.  Note the first parameter is NULL which means\n             the size is not tracked.  */",
        "/* Return the pointer to the user buffer.  */"
    ],
    "munmap(void *, int)": [
        "/* Determine real implementation if not already happened.  */",
        "/* Do the real work.  */",
        "/* Keep track of number of calls.  */",
        "/* Keep track of total memory freed using `free'.  */",
        "/* Update the allocation data and write out the records if\n             necessary.  */"
    ],
    "__libc_reallocarray(void *, int, int)": [],
    "__libc_scratch_buffer_grow(struct scratch_buffer *)": [
        "/* Discard old buffer.  */",
        "/* Check for overflow.  */",
        "/* Buffer must remain valid to free.  */",
        "/* Install new heap-based buffer.  */"
    ],
    "__libc_scratch_buffer_grow_preserve(struct scratch_buffer *)": [
        "/* Move buffer to the heap.  No overflow is possible because\n\t buffer->length describes a small buffer on the stack.  */",
        "/* Buffer was already on the heap.  Check for overflow.  */",
        "/* Deallocate, but buffer must remain valid to free.  */",
        "/* Install new heap-based buffer.  */"
    ],
    "__libc_scratch_buffer_set_array_size(struct scratch_buffer *, int, int)": [
        "/* Avoid overflow check if both values are small. */",
        "/* Overflow.  Discard the old buffer, but it must remain valid\n\t to free.  */",
        "/* Discard old buffer.  */",
        "/* Buffer must remain valid to free.  */",
        "/* Install new heap-based buffer.  */"
    ],
    "__libc_freeres()": [
        "/* This function might be called from different places.  So better\n     protect for multiple executions since these are fatal.  */",
        "/* We run the resource freeing after IO cleanup.  */",
        "/* __res_thread_freeres deallocates the per-thread resolv_context);\n\t which in turn drop the reference count of the current global object.\n\t So it need to be before __libc_resolv_conf_freemem.  */"
    ],
    "twalk(const void *, void (*)(const void *, VISIT, int))": [],
    "fedisableexcept(int)": [
        "/* Get the current control word of the x87 FPU.  */",
        "/* And now the same for the SSE MXCSR register.  */",
        "/* The SSE exception masks are shifted by 7 bits.  */"
    ],
    "feenableexcept(int)": [
        "/* Get the current control word of the x87 FPU.  */",
        "/* And now the same for the SSE MXCSR register.  */",
        "/* The SSE exception masks are shifted by 7 bits.  */"
    ],
    "fegetexcept()": [
        "/* Get the current control word.  */"
    ],
    "fegetmode(int *)": [],
    "fesetexcept(int)": [],
    "fesetmode(const int *)": [
        "/* Preserve SSE exception flags but restore other state in\n     MXCSR.  */",
        "/* Default MXCSR state has all bits zero except for those\n\t masking exceptions.  */"
    ],
    "fetestexceptflag(const fexcept_t *, int)": [
        "/* Most versions of fegetexceptflag store exceptions in a form such\n     that this works.  */"
    ],
    "fetestexcept(int)": [
        "/* Get current exceptions.  */"
    ],
    "matherr(struct exception *)": [],
    "cos(double)": [],
    "acos(double)": [],
    "sin(double)": [],
    "asin(double)": [],
    "tan(double)": [],
    "atan(double)": [],
    "atan2(double, double)": [],
    "cosh(double)": [],
    "acosh(double)": [],
    "sinh(double)": [],
    "asinh(double)": [],
    "tanh(double)": [],
    "atanh(double)": [],
    "exp(double)": [],
    "log(double)": [],
    "log10(double)": [],
    "ldexp(double, int)": [],
    "frexp(double, int *)": [],
    "expm1(double)": [],
    "log1p(double)": [],
    "logb(double)": [],
    "exp10(double)": [],
    "exp2(double)": [],
    "log2(double)": [],
    "pow(double, double)": [],
    "sqrt(double)": [],
    "hypot(double, double)": [],
    "cbrt(double)": [],
    "ceil(double)": [],
    "fabs(double)": [],
    "floor(double)": [],
    "fmod(double, double)": [],
    "nearbyint(double)": [],
    "round(double)": [],
    "roundeven(double)": [],
    "trunc(double)": [],
    "remquo(double, double, int *)": [],
    "lrint(double)": [],
    "lround(double)": [],
    "llrint(double)": [],
    "llround(double)": [],
    "fromfp(double, int, unsigned int)": [],
    "fromfpx(double, int, unsigned int)": [],
    "ufromfp(double, int, unsigned int)": [],
    "ufromfpx(double, int, unsigned int)": [],
    "erf(double)": [],
    "erfc(double)": [],
    "tgamma(double)": [],
    "lgamma(double)": [],
    "rint(double)": [],
    "nextafter(double, double)": [],
    "nextdown(double)": [],
    "nexttoward(double, long double)": [],
    "nextup(double)": [],
    "remainder(double, double)": [],
    "scalb(double, double)": [],
    "scalbn(double, int)": [],
    "scalbln(double, long)": [],
    "ilogb(double)": [],
    "llogb(double)": [],
    "fdim(double, double)": [],
    "fmin(double, double)": [],
    "fmax(double, double)": [],
    "fminmag(double, double)": [],
    "fmaxmag(double, double)": [],
    "fminimum(double, double)": [],
    "fmaximum(double, double)": [],
    "fminimum_num(double, double)": [],
    "fmaximum_num(double, double)": [],
    "fminimum_mag(double, double)": [],
    "fmaximum_mag(double, double)": [],
    "fminimum_mag_num(double, double)": [],
    "fmaximum_mag_num(double, double)": [],
    "fma(double, double, double)": [],
    "cacos(_Complex double)": [],
    "casin(_Complex double)": [],
    "catan(_Complex double)": [],
    "ccos(_Complex double)": [],
    "csin(_Complex double)": [],
    "ctan(_Complex double)": [],
    "cacosh(_Complex double)": [],
    "casinh(_Complex double)": [],
    "catanh(_Complex double)": [],
    "ccosh(_Complex double)": [],
    "csinh(_Complex double)": [],
    "ctanh(_Complex double)": [],
    "cexp(_Complex double)": [],
    "clog(_Complex double)": [],
    "csqrt(_Complex double)": [],
    "cpow(_Complex double, _Complex double)": [],
    "cabs(_Complex double)": [],
    "carg(_Complex double)": [],
    "creal(_Complex double)": [],
    "cimag(_Complex double)": [],
    "conj(_Complex double)": [],
    "cproj(_Complex double)": [],
    "cosf(float)": [],
    "acosf(float)": [],
    "sinf(float)": [],
    "asinf(float)": [],
    "tanf(float)": [],
    "atanf(float)": [],
    "atan2f(float, float)": [],
    "coshf(float)": [],
    "acoshf(float)": [],
    "sinhf(float)": [],
    "asinhf(float)": [],
    "tanhf(float)": [],
    "atanhf(float)": [],
    "expf(float)": [],
    "logf(float)": [],
    "log10f(float)": [],
    "ldexpf(float, int)": [],
    "frexpf(float, int *)": [],
    "expm1f(float)": [],
    "log1pf(float)": [],
    "logbf(float)": [],
    "exp10f(float)": [],
    "exp2f(float)": [],
    "log2f(float)": [],
    "powf(float, float)": [],
    "sqrtf(float)": [],
    "hypotf(float, float)": [],
    "cbrtf(float)": [],
    "ceilf(float)": [],
    "fabsf(float)": [],
    "floorf(float)": [],
    "fmodf(float, float)": [],
    "nearbyintf(float)": [],
    "roundf(float)": [],
    "roundevenf(float)": [],
    "truncf(float)": [],
    "remquof(float, float, int *)": [],
    "lrintf(float)": [],
    "lroundf(float)": [],
    "llrintf(float)": [],
    "llroundf(float)": [],
    "fromfpf(float, int, unsigned int)": [],
    "fromfpxf(float, int, unsigned int)": [],
    "ufromfpf(float, int, unsigned int)": [],
    "ufromfpxf(float, int, unsigned int)": [],
    "erff(float)": [],
    "erfcf(float)": [],
    "tgammaf(float)": [],
    "lgammaf(float)": [],
    "rintf(float)": [],
    "nextafterf(float, float)": [],
    "nextdownf(float)": [],
    "nexttowardf(float, long double)": [],
    "nextupf(float)": [],
    "remainderf(float, float)": [],
    "scalbf(float, float)": [],
    "scalbnf(float, int)": [],
    "scalblnf(float, long)": [],
    "ilogbf(float)": [],
    "llogbf(float)": [],
    "fdimf(float, float)": [],
    "fminf(float, float)": [],
    "fmaxf(float, float)": [],
    "fminmagf(float, float)": [],
    "fmaxmagf(float, float)": [],
    "fminimumf(float, float)": [],
    "fmaximumf(float, float)": [],
    "fminimum_numf(float, float)": [],
    "fmaximum_numf(float, float)": [],
    "fminimum_magf(float, float)": [],
    "fmaximum_magf(float, float)": [],
    "fminimum_mag_numf(float, float)": [],
    "fmaximum_mag_numf(float, float)": [],
    "fmaf(float, float, float)": [],
    "cacosf(_Complex float)": [],
    "casinf(_Complex float)": [],
    "catanf(_Complex float)": [],
    "ccosf(_Complex float)": [],
    "csinf(_Complex float)": [],
    "ctanf(_Complex float)": [],
    "cacoshf(_Complex float)": [],
    "casinhf(_Complex float)": [],
    "catanhf(_Complex float)": [],
    "ccoshf(_Complex float)": [],
    "csinhf(_Complex float)": [],
    "ctanhf(_Complex float)": [],
    "cexpf(_Complex float)": [],
    "clogf(_Complex float)": [],
    "csqrtf(_Complex float)": [],
    "cpowf(_Complex float, _Complex float)": [],
    "cabsf(_Complex float)": [],
    "cargf(_Complex float)": [],
    "crealf(_Complex float)": [],
    "cimagf(_Complex float)": [],
    "conjf(_Complex float)": [],
    "cprojf(_Complex float)": [],
    "ccos(cdouble)": [],
    "cabs(cdouble)": [],
    "conj(cdouble)": [],
    "cpow(cdouble, cdouble)": [],
    "ccosf(cfloat)": [],
    "cabsf(cfloat)": [],
    "conjf(cfloat)": [],
    "cpowf(cfloat, cfloat)": [],
    "acct(const char *)": [],
    "__libc_allocate_once_slow(void **, void *(*)(void *), void (*)(void *, void *), void *)": [
        "/* This loop implements a strong CAS on *place, with acquire-release\n     MO semantics, from a weak CAS with relaxed-release MO.  */",
        "/* Synchronizes with the acquire MO load in allocate_once.  */",
        "/* The failed CAS has relaxed MO semantics, so perform another\n         acquire MO load.  */",
        "/* Spurious failure.  Try again.  */",
        "/* We lost the race.  Free what we allocated and return the\n         other result.  */"
    ],
    "chflags(const char *, unsigned long)": [],
    "chroot(const char *)": [
        "/* Append trailing \"/.\" to directory name to force ENOTDIR if it's not a\n     directory and EACCES if we don't have search permission.  */",
        "/* Special-case empty file name according to POSIX.  */",
        "/* Prevent going through DIR's ..  */"
    ],
    "daemon(int, int)": [
        "/* We must set an errno value since no function call\n                 actually failed.  */"
    ],
    "dirname(char *)": [
        "/* Find last '/'.  */",
        "/* Determine whether all remaining characters are slashes.  */",
        "/* The '/' is the last character, we have to look further.  */",
        "/* Determine whether all remaining characters are slashes.  */",
        "/* Terminate the path.  */",
        "/* The last slash is the first character in the string.  We have to\n\t     return \"/\".  As a special case we have to return \"//\" if there\n\t     are exactly two slashes at the beginning of the string.  See\n\t     XBD 4.10 Path Name Resolution for more information.  */",
        "/* This assignment is ill-designed but the XPG specs require to\n       return a string containing \".\" in any case no directory part is\n       found and so a static and constant string is required.  */"
    ],
    "vwarn(const char *, void *)": [],
    "errx(int, const char *, ...)": [],
    "error_at_line(int, int, const char *, unsigned int, const char *, ...)": [],
    "fchflags(int, unsigned long)": [],
    "fdatasync(int)": [
        "/* If the file descriptor does not support sync, return EINVAL\n\t   as POSIX specifies.  */"
    ],
    "fgetxattr(int, const char *, void *, int)": [],
    "flistxattr(int, char *, int)": [],
    "fremovexattr(int, const char *)": [],
    "fsetxattr(int, const char *, const void *, int, int)": [],
    "setfsent()": [],
    "getfsent()": [],
    "getfsspec(const char *)": [],
    "getfsfile(const char *)": [],
    "endfsent()": [],
    "fsync(int)": [
        "/* If the file descriptor does not support sync, return EINVAL\n\t   as POSIX specifies.  */"
    ],
    "futimesat(int, const char *, const struct timeval *)": [],
    "getdomainname(char *, int)": [
        "/* The NIS domain name is just the contents of the file /etc/nisdomain.  */"
    ],
    "gethostid()": [
        "/* First try to get the ID from a former invocation of sethostid.  */",
        "/* Getting from the file was not successful.  An intelligent guess\n     for a unique number of a host is its IP address.  To get the IP\n     address we need to know the host name.  */",
        "/* This also fails.  Return and arbitrary value.  */",
        "/* Determine the IP address of the host name.  */",
        "/* Enlarge the buffer on ERANGE.  */",
        "/* Other errors are a failure.  Return an arbitrary value.  */",
        "/* For the return value to be not exactly the IP address we do some\n     bit fiddling.  */"
    ],
    "getloadavg(double *, int)": [],
    "__getpagesize()": [
        "/* The only possible error is ENOSYS.  */"
    ],
    "getpass(const char *)": [
        "/* Try to write to and read from the terminal if we can.\n     If we can't open the terminal, use stderr and stdin.  */",
        "/* We do the locking ourselves.  */",
        "/* Make sure the stream we opened is closed even if the thread is\n     canceled.  */",
        "/* Turn echoing off if it is on now.  */",
        "/* Save the old one. */",
        "/* Tricky, tricky. */",
        "/* Write the prompt.  */",
        "/* Read the password.  */",
        "/* Remove the newline.  */",
        "/* Write the newline that was not echoed.  */",
        "/* Restore the original setting.  */",
        "/* We opened the terminal; now close it.  */"
    ],
    "getusershell()": [],
    "endusershell()": [],
    "setusershell()": [],
    "getxattr(const char *, const char *, void *, int)": [],
    "gtty(int, struct sgttyb *)": [],
    "hsearch(ENTRY, ACTION)": [],
    "hcreate(int)": [],
    "__libc_ifunc_impl_list(const char *, struct libc_ifunc_impl *, int)": [
        "/* Support sysdeps/x86_64/multiarch/memcmpeq.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/memchr.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/memcmp.c.  */",
        "/* NB: If any of these names change or if any new\n\t         implementations are added be sure to update\n\t         sysdeps/x86_64/memcmp-isa-default-impl.h.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/memmove_chk.c.  */",
        "/* By V3 we assume fast aligned copy.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */",
        "/* Support sysdeps/x86_64/multiarch/memmove.c.  */",
        "/* By V3 we assume fast aligned copy.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */",
        "/* Support sysdeps/x86_64/multiarch/memrchr.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/memset_chk.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/memset.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/rawmemchr.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/strlen.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/strnlen.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/stpncpy.c.  */",
        "/* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/stpcpy.c.  */",
        "/* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/strcasecmp_l.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/strcasecmp_l.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/strcat.c.  */",
        "/* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/strchr.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/strchrnul.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/strrchr.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/strcmp.c.  */",
        "/* ISA V2 wrapper for SSE2 implementations because the SSE2\n\t         implementations are also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/strcpy.c.  */",
        "/* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/strcspn.c.  */",
        "/* All implementations of strcspn are built at all ISA\n\t         levels.  */",
        "/* Support sysdeps/x86_64/multiarch/strncase_l.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/strncase_l.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/strncat.c.  */",
        "/* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/strncpy.c.  */",
        "/* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/strpbrk.c.  */",
        "/* All implementations of strpbrk are built at all ISA\n\t         levels.  */",
        "/* Support sysdeps/x86_64/multiarch/strspn.c.  */",
        "/* All implementations of strspn are built at all ISA\n\t         levels.  */",
        "/* Support sysdeps/x86_64/multiarch/strstr.c.  */",
        "/* Support sysdeps/x86_64/multiarch/wcschr.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/wcsrchr.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/wcscmp.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/wcsncmp.c.  */",
        "/* ISA V2 wrapper for GENERIC implementation because the\n\t         GENERIC implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/wcscpy.c.  */",
        "/* Support sysdeps/x86_64/multiarch/wcsncpy.c.  */",
        "/* Support sysdeps/x86_64/multiarch/wcpcpy.c.  */",
        "/* Support sysdeps/x86_64/multiarch/wcpncpy.c.  */",
        "/* Support sysdeps/x86_64/multiarch/wcscat.c.  */",
        "/* Support sysdeps/x86_64/multiarch/wcsncat.c.  */",
        "/* Support sysdeps/x86_64/multiarch/wcslen.c.  */",
        "/* Support sysdeps/x86_64/multiarch/wcsnlen.c.  */",
        "/* Support sysdeps/x86_64/multiarch/wmemchr.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/wmemcmp.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/wmemset.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/memcpy_chk.c.  */",
        "/* By V3 we assume fast aligned copy.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */",
        "/* Support sysdeps/x86_64/multiarch/memcpy.c.  */",
        "/* By V3 we assume fast aligned copy.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */",
        "/* Support sysdeps/x86_64/multiarch/mempcpy_chk.c.  */",
        "/* By V3 we assume fast aligned copy.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */",
        "/* Support sysdeps/x86_64/multiarch/mempcpy.c.  */",
        "/* By V3 we assume fast aligned copy.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */",
        "/* Support sysdeps/x86_64/multiarch/strncmp.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */",
        "/* Support sysdeps/x86_64/multiarch/wmemset_chk.c.  */",
        "/* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */"
    ],
    "insque(void *, void *)": [],
    "remque(void *)": [],
    "lgetxattr(const char *, const char *, void *, int)": [],
    "listxattr(const char *, char *, int)": [],
    "llistxattr(const char *, char *, int)": [],
    "lremovexattr(const char *, const char *)": [],
    "lsearch(const void *, void *, int *, int, __compar_fn_t)": [
        "/* Try to find it.  */",
        "/* Not available.  Insert at the end.  */"
    ],
    "lfind(const void *, const void *, int *, int, __compar_fn_t)": [],
    "lsetxattr(const char *, const char *, const void *, int, int)": [],
    "__madvise(void *, int, int)": [],
    "mincore(void *, int, unsigned char *)": [],
    "mkdtemp(char *)": [],
    "mkostemp(char *, int)": [],
    "mkostemps(char *, int, int)": [],
    "mkstemp(char *)": [],
    "mkstemps(char *, int)": [],
    "__mktemp(char *)": [
        "/* We return the null string if we can't find a unique file name.  */"
    ],
    "mlock(const void *, int)": [],
    "mlockall(int)": [],
    "__mmap(void *, int, int, int, int, off_t)": [
        "/* ADDR and OFFSET must be page-aligned.  */",
        "/* Allow, e.g., just MAP_SHARED.  */",
        "/* File descriptor doesn't support mmap.  */",
        "/* Although it apparently doesn't make sense to map a file with\n\t     protection set to PROT_NONE, it is actually sometimes done.\n\t     In particular, that's how localedef reserves some space for\n\t     the locale archive file, the rationale being that some\n\t     implementations take into account whether the mapping is\n\t     anonymous or not when selecting addresses.  */",
        "/* Remove extra reference.  */",
        "/* Not writable by mapping.  */",
        "/* The file can only be mapped for reading.  Since we are\n\t\t making a private mapping, we will never try to write the\n\t\t object anyway, so we don't care.  */",
        "/* XXX handle MAP_NOEXTEND */",
        "/* XXX handle MAP_INHERIT */",
        "/* When ANYWHERE is true but the caller has provided a preferred address,\n     try mapping at that address with anywhere = 0 first.  If this fails,\n     we'll retry with anywhere = 1 below.  */",
        "/* The region is already allocated; deallocate it first.  */",
        "/* XXX this is not atomic as it is in unix! */",
        "/* This mmap call is allowed to allocate anywhere,  */",
        "/* ...but above, we tried allocating at the specific address,\n           and failed to.  Now try again, with anywhere = 1 this time.  */"
    ],
    "getmntent(FILE *)": [
        "/* If no core is available we don't have a chance to run the\n       program successfully and so returning NULL is an acceptable\n       result.  */"
    ],
    "__setmntent(const char *, const char *)": [
        "/* Extend the mode parameter with \"c\" to disable cancellation in the\n     I/O functions and \"e\" to set FD_CLOEXEC.  */",
        "/* We do the locking ourselves.  */"
    ],
    "__mprotect(void *, int, int)": [],
    "msync(void *, int, int)": [
        "/* We were given an address before the first region,\n\t   or we found a hole.  */",
        "/* We were given an ending address within a hole. */"
    ],
    "munlock(const void *, int)": [],
    "munlockall()": [],
    "__munmap(void *, int)": [],
    "preadv(int, const struct iovec *, int, off_t)": [],
    "preadv2(int, const struct iovec *, int, off_t, int)": [],
    "preadv64(int, const struct iovec *, int, int)": [],
    "preadv64v2(int, const struct iovec *, int, int, int)": [],
    "ptrace(enum __ptrace_request, ...)": [],
    "pwritev(int, const struct iovec *, int, off_t)": [],
    "pwritev2(int, const struct iovec *, int, off_t, int)": [],
    "pwritev64(int, const struct iovec *, int, int)": [],
    "pwritev64v2(int, const struct iovec *, int, int, int)": [],
    "reboot(int)": [],
    "removexattr(const char *, const char *)": [],
    "__sbrk(intptr_t)": [],
    "__select(int, fd_set *, fd_set *, fd_set *, struct timeval *)": [],
    "setdomainname(const char *, int)": [
        "/* The NIS domain name is just the contents of the file /etc/nisdomain.  */"
    ],
    "setegid(__gid_t)": [],
    "seteuid(__uid_t)": [],
    "sethostid(long)": [
        "/* Test for appropriate rights to set host ID.  */",
        "/* Make sure the ID is not too large.  Needed for bi-arch support.   */",
        "/* Open file for writing.  Everybody is allowed to read this file.  */"
    ],
    "sethostname(const char *, int)": [
        "/* The host name is just the contents of the file /etc/hostname.  */"
    ],
    "setxattr(const char *, const char *, const void *, int, int)": [],
    "stty(int, const struct sgttyb *)": [],
    "swapoff(const char *)": [],
    "swapon(const char *, int)": [],
    "sync()": [
        "/* This is not actually synchronous; we don't wait.  */"
    ],
    "syncfs(int)": [],
    "syscall(long, ...)": [],
    "openlog(const char *, int, int)": [
        "/* Protect against multiple users and cancellation.  */"
    ],
    "closelog()": [
        "/* Protect against multiple users and cancellation.  */",
        "/* this is the default */",
        "/* Free the lock.  */"
    ],
    "setlogmask(int)": [
        "/* Protect against multiple users.  */"
    ],
    "truncate64(const char *, int)": [],
    "__tsearch(const void *, void **, __compar_fn_t)": [
        "/* No they might not, Mr Compiler.  */",
        "/* This saves some additional tests below.  */",
        "/* If that did any rotations, parentp and gparentp are now garbage.\n\t That doesn't matter, because the values they contain are never\n\t used again in that case.  */",
        "/* Make sure the malloc implementation returns naturally aligned\n\t memory blocks when expected.  Or at least even pointers, so we\n\t can use the low bit as red/black flag.  Even though we have a\n\t static_assert to make sure alignof (max_align_t) > 1 there could\n\t be an interposed malloc implementation that might cause havoc by\n\t not obeying the malloc contract.  */",
        "/* link new node to old */",
        "/* initialize new node */",
        "/* There may be two red edges in a row now, which we must avoid by\n\t   rotating the tree.  */"
    ],
    "ttyslot()": [
        "/* This should be enough if no fixed value is given.  */"
    ],
    "ualarm(useconds_t, useconds_t)": [],
    "usleep(useconds_t)": [
        "/* Note the usleep() is a cancellation point.  But since we call\n     nanosleep() which itself is a cancellation point we do not have\n     to do anything here.  */"
    ],
    "vhangup()": [],
    "__nptl_create_event()": [],
    "__lll_lock_wait_private(int *)": [
        "/* Wait if *futex == 2.  */"
    ],
    "clock_getcpuclockid(pid_t, clockid_t *)": [
        "/* We don't allow any process ID but our own.  */",
        "/* Store the number.  */",
        "/* We don't have a timer for that.  */"
    ],
    "clock_gettime(clockid_t, struct timespec *)": [
        "/* Get the current counter.  */",
        "/* Compute the seconds.  */",
        "/* And the nanoseconds.  This computation should be stable until\n\t   we get machines with about 16GHz frequency.  */"
    ],
    "pthread_attr_setsigmask_np(int *, const int *)": [
        "/* Filter out internal signals.  */"
    ],
    "thrd_current()": [],
    "thrd_yield()": [],
    "fgetgrent(FILE *)": [
        "/* Get lock.  */",
        "/* Allocate buffer if not yet available.  */",
        "/* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */",
        "/* Reset the stream.  */",
        "/* Release lock.  Preserve error value.  */"
    ],
    "fgetpwent(FILE *)": [
        "/* Get lock.  */",
        "/* Allocate buffer if not yet available.  */",
        "/* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */",
        "/* Reset the stream.  */",
        "/* Release lock.  Preserve error value.  */"
    ],
    "fgetsgent(FILE *)": [
        "/* Get lock.  */",
        "/* Allocate buffer if not yet available.  */",
        "/* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */",
        "/* Reset the stream.  */",
        "/* Release lock.  Preserve error value.  */"
    ],
    "fgetspent(FILE *)": [
        "/* Get lock.  */",
        "/* Allocate buffer if not yet available.  */",
        "/* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */",
        "/* Reset the stream.  */",
        "/* Release lock.  Preserve error value.  */"
    ],
    "getaddrinfo(const char *, const char *, const struct addrinfo *, struct addrinfo **)": [
        "/* We might need information about what interfaces are available.\n\t Also determine whether we have IPv4 or IPv6 interfaces or both.  We\n\t cannot cache the results since new interfaces could be added at\n\t any time.  */",
        "/* Now make a decision on what we return, if anything.  */",
        "/* If we haven't seen both IPv4 and IPv6 interfaces we can\n\t     narrow down the search.  */",
        "/* We cannot possibly return a valid answer.  */",
        "/* Read the config file.  */",
        "/* Sort results according to RFC 3484.  */",
        "/* Now we definitely need the interface information.  */",
        "/* If we have information about deprecated and temporary addresses\n\t sort the array now.  */",
        "/* If we just looked up the address for a different\n\t     protocol, reuse the result.  */",
        "/* We overwrite the type with SOCK_DGRAM since we do not\n\t\t want connect() to connect to the other side.  If we\n\t\t cannot determine the source address remember this\n\t\t fact.  */",
        "/* Reset the connection.  */",
        "/* See whether the source address is on the list of\n\t\t\t deprecated or temporary addresses.  */",
        "/* Special case for lo interface, the source address\n\t\t\t     being possibly different than the interface\n\t\t\t     address. */",
        "/* We have to convert the address.  The socket is\n\t\t\t IPv6 and the request is for IPv4.  */",
        "/* We do not have to initialize sin_port since this\n\t\t\t fields has the same position and size in the IPv6\n\t\t\t structure.  */",
        "/* Just make sure that if we have to process the same\n\t\t   address again we do not copy any memory.  */",
        "/* Remember the canonical name.  */",
        "/* We got all the source addresses we can get, now sort using\n\t the information.  */",
        "/* Queue the results up as they come out of sorting.  */",
        "/* Fill in the canonical name into the new first entry.  */"
    ],
    "endaliasent()": [
        "/* If the service has not been used before do not do anything.  */"
    ],
    "endgrent()": [
        "/* If the service has not been used before do not do anything.  */"
    ],
    "endhostent()": [
        "/* If the service has not been used before do not do anything.  */"
    ],
    "getnameinfo(const struct sockaddr *, socklen_t, char *, socklen_t, char *, socklen_t, int)": [],
    "endnetent()": [
        "/* If the service has not been used before do not do anything.  */"
    ],
    "getnetgrent(char **, char **, char **)": [],
    "__internal_setnetgrent(const char *, struct __netgrent *)": [
        "/* Free list of all netgroup names from last run.  */"
    ],
    "setnetgrent(const char *)": [],
    "__internal_endnetgrent(struct __netgrent *)": [
        "/* Now free list of all netgroup names from last run.  */"
    ],
    "__internal_getnetgrent_r(char **, char **, char **, struct __netgrent *, char *, int, int *)": [
        "/* Initialize status to return if no more functions are found.  */",
        "/* Run through available functions, starting with the same function last\n     run.  We will repeat each function as long as it succeeds, and then go\n     on to the next service action.  */",
        "/* This bogus function pointer is a special marker left by\n\t __nscd_setnetgrent to tell us to use the data it left\n\t before considering any modules.  */",
        "/* The service returned a NOTFOUND, but there are more groups that\n\t\t we need to resolve before we give up.  */",
        "/* This was the last one for this group.  Look at next group\n\t\t if available.  */",
        "/* The last entry was a name of another netgroup.  */",
        "/* Ignore if we've seen the name before.  */",
        "/* Really ignore.  */",
        "/* We are out of memory.  */",
        "/* And get the next entry.  */"
    ],
    "endprotoent()": [
        "/* If the service has not been used before do not do anything.  */"
    ],
    "endpwent()": [
        "/* If the service has not been used before do not do anything.  */"
    ],
    "endrpcent()": [
        "/* If the service has not been used before do not do anything.  */"
    ],
    "endservent()": [
        "/* If the service has not been used before do not do anything.  */"
    ],
    "endsgent()": [
        "/* If the service has not been used before do not do anything.  */"
    ],
    "endspent()": [
        "/* If the service has not been used before do not do anything.  */"
    ],
    "__copy_grp(const struct group, const int, struct group *, char *, char **)": [
        "/* Copy the GID.  */",
        "/* Copy the name.  */",
        "/* Copy the password.  */",
        "/* Count all of the members.  */",
        "/* Allocate a temporary holding area for the pointers to the member\n     contents, including space for a NULL-terminator.  */",
        "/* Copy all of the group members to destbuf and add a pointer to each of\n     them into the 'members' array.  */",
        "/* Align for pointers.  We can't simply align C because we need to\n     align destbuf[c].  */",
        "/* Copy the pointers from the members array into the buffer and assign them\n     to the gr_mem member of destgrp.  */",
        "/* Save the count of members at the end.  */"
    ],
    "getgrouplist(const char *, gid_t, gid_t *, int *)": [
        "/* No more memory.  */",
        "// XXX This is wrong.  The user provided memory, we have to use",
        "// XXX it.  The internal functions must be called with the user",
        "// XXX provided buffer and not try to increase the size if it is",
        "// XXX too small.  For initgroups a flag could say: increase size."
    ],
    "__nss_configure_lookup(const char *, const char *)": [
        "/* Convert named database to index.  */",
        "/* Not our database (e.g., sudoers).  */",
        "/* Force any load/cache/read whatever to happen, so we can override\n     it.  */"
    ],
    "__nss_database_get(enum nss_database, nss_action_list *)": [],
    "__nss_files_data_open(struct nss_files_per_file_data **, enum nss_files_file, const char *, int *, int *)": [
        "/* Be prepared that the set*ent function was not called before.  */"
    ],
    "__nss_files_fopen(const char *)": [
        "/* The stream is not shared across threads.  */",
        "/* This tells libio that the file is seekable, and that fp->_offset\n     is correct, ensuring that __ftello64 is efficient (bug 26257).  */",
        "/* nss_files requires seekable files, to deal with repeated\n         reads of the same line after reporting ERANGE.  */"
    ],
    "__nss_hash(const void *, int)": [
        "/* (uint32_t)(65599 ^ 0).  */",
        "/* (uint32_t)(65599 ^ 1).  */",
        "/* (uint32_t)(65599 ^ 2).  */",
        "/* (uint32_t)(65599 ^ 3).  */",
        "/* (uint32_t)(65599 ^ 4).  */",
        "/* h starts out as zero so no need to include the multiply. */",
        "/* FALLTHROUGH */",
        "/* FALLTHROUGH */",
        "/* FALLTHROUGH */",
        "/* FALLTHROUGH */"
    ],
    "__nss_parse_line_result(int *, int, int)": [
        "/* Success.  */",
        "/* Parse error.  */",
        "/* Out of buffer space.  */"
    ],
    "__nss_readline(int *, char *, int, int *)": [
        "/* We need space for at least one character, the line terminator,\n     and the NUL byte.  */",
        "/* Keep original offset for retries.  */",
        "/* Marker to recognize truncation.  */",
        "/* Any other error.  Do not return ERANGE in this case\n                 because the caller would retry.  */",
        "/* The buffer is too small.  Arrange for re-reading the same\n           line on the next call.  */",
        "/* __fgets_unlocked succeeded.  */",
        "/* Remove leading whitespace.  */",
        "/* Skip empty lines and comments.  */",
        "/* Return line to the caller.  */"
    ],
    "putgrent(const struct group *, FILE *)": [
        "/* What else can we do?  */"
    ],
    "putpwent(const struct passwd *, FILE *)": [],
    "putsgent(const struct sgrp *, FILE *)": [],
    "putspent(const struct spwd *, FILE *)": [],
    "sgetsgent(const char *)": [
        "/* Get lock.  */",
        "/* Allocate buffer if not yet available.  */",
        "/* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */",
        "/* Release lock.  Preserve error value.  */"
    ],
    "sgetspent(const char *)": [
        "/* Get lock.  */",
        "/* Allocate buffer if not yet available.  */",
        "/* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */",
        "/* Release lock.  Preserve error value.  */"
    ],
    "_nss_files_setaliasent()": [],
    "_nss_files_getaliasent_r(struct aliasent *, char *, int, int *)": [
        "/* Return next entry in host file.  */",
        "/* Read lines until we get a definite result.  */"
    ],
    "_nss_files_parse_etherent(char *, void *, struct parser_data *, int, int *)": [],
    "_nss_files_setetherent(int)": [],
    "_nss_files_getetherent_r(struct etherent *, char *, int, int *)": [
        "/* Return next entry in host file.  */"
    ],
    "_nss_files_setgrent(int)": [],
    "_nss_files_getgrent_r(struct group *, char *, int, int *)": [
        "/* Return next entry in host file.  */"
    ],
    "_nss_files_sethostent(int)": [],
    "_nss_files_gethostent_r(struct hostent *, char *, int, int *, int *)": [
        "/* Return next entry in host file.  */"
    ],
    "_nss_files_gethostbyname3_r(const char *, int, struct hostent *, char *, int, int *, int *, int32_t *, char **)": [
        "/* Open file.  */"
    ],
    "_nss_files_initgroups_dyn(const char *, gid_t, long *, long *, gid_t **, long, int *)": [
        "/* We have to iterate over the entire file.  */",
        "/* Reread current line, the parser has clobbered it.  */",
        "/* Matches user.  Insert this group.  */",
        "/* Need a bigger buffer.  */",
        "/* We reached the maximum.  */",
        "/* Free memory.  */"
    ],
    "_nss_netgroup_parseline(char **, struct __netgrent *, char *, int, int *)": [
        "/* Some sanity checks.  */",
        "/* First skip leading spaces.  */",
        "/* We have a list of other netgroups.  */",
        "/* It is another netgroup name.  */",
        "/* Match host name.  */",
        "/* Match user name.  */",
        "/* Match domain name.  */",
        "/* When we got here we have found an entry.  Before we can copy it\n     to the private buffer we have to make sure it is big enough.  */",
        "/* Replace ',' with '\\0'.  */",
        "/* Replace ',' with '\\0'.  */",
        "/* Replace ')' with '\\0'.  */",
        "/* Remember where we stopped reading.  */"
    ],
    "_nss_files_parse_netent(char *, void *, struct parser_data *, int, int *)": [],
    "_nss_files_setnetent(int)": [],
    "_nss_files_getnetent_r(struct netent *, char *, int, int *, int *)": [
        "/* Return next entry in host file.  */"
    ],
    "_nss_files_parse_protoent(char *, void *, struct parser_data *, int, int *)": [],
    "_nss_files_setprotoent(int)": [],
    "_nss_files_getprotoent_r(struct protoent *, char *, int, int *)": [
        "/* Return next entry in host file.  */"
    ],
    "_nss_files_setpwent(int)": [],
    "_nss_files_getpwent_r(struct passwd *, char *, int, int *)": [
        "/* Return next entry in host file.  */"
    ],
    "_nss_files_parse_rpcent(char *, void *, struct parser_data *, int, int *)": [],
    "_nss_files_setrpcent(int)": [],
    "_nss_files_getrpcent_r(struct rpcent *, char *, int, int *)": [
        "/* Return next entry in host file.  */"
    ],
    "_nss_files_parse_servent(char *, void *, struct parser_data *, int, int *)": [],
    "_nss_files_setservent(int)": [],
    "_nss_files_getservent_r(struct servent *, char *, int, int *)": [
        "/* Return next entry in host file.  */"
    ],
    "_nss_files_setsgent(int)": [],
    "_nss_files_getsgent_r(struct sgrp *, char *, int, int *)": [
        "/* Return next entry in host file.  */"
    ],
    "_nss_files_setspent(int)": [],
    "_nss_files_getspent_r(struct spwd *, char *, int, int *)": [
        "/* Return next entry in host file.  */"
    ],
    "_Fork()": [
        "/* Initialize the robust mutex list setting in the kernel which has\n\t been reset during the fork.  We do not check for errors because if\n\t it fails here, it must have failed at process startup as well and\n\t nobody could have used robust mutexes.\n\t Before we do that, we have to clear the list of robust mutexes\n\t because we do not inherit ownership of mutexes from the parent.\n\t We do not have to set self->robust_head.futex_offset since we do\n\t inherit the correct value from the parent.  We do not need to clear\n\t the pending operation because it must have been zero when fork was\n\t called.  */"
    ],
    "_exit(int)": [],
    "alarm(unsigned int)": [
        "/* Round to the nearest second, but never report zero seconds when\n     the alarm is still set.  */"
    ],
    "execl(const char *, const char *, ...)": [
        "/* Avoid dynamic memory allocation due two main issues:\n     1. The function should be async-signal-safe and a running on a signal\n        handler with a fail outcome might lead to malloc bad state.\n     2. It might be used in a vfork/clone(VFORK) scenario where using\n        malloc also might lead to internal bad state.  */"
    ],
    "execle(const char *, const char *, ...)": [
        "/* Avoid dynamic memory allocation due two main issues:\n     1. The function should be async-signal-safe and a running on a signal\n        handler with a fail outcome might lead to malloc bad state.\n     2. It might be used in a vfork/clone(VFORK) scenario where using\n        malloc also might lead to internal bad state.  */"
    ],
    "execlp(const char *, const char *, ...)": [
        "/* Although posix does not state execlp as an async-safe function\n     it can not use malloc to allocate the arguments since it might\n     be used in a vfork scenario and it may lead to malloc internal\n     bad state.  */"
    ],
    "execv(const char *, char *const *)": [],
    "execvp(const char *, char *const *)": [],
    "fexecve(int, char *const *, char *const *)": [
        "/* Avoid implicit array coercion in syscall macros.  */",
        "/* We use the /proc filesystem to get the information.  If it is not\n     mounted we fail.  We do not need the return value.  */",
        "/* We come here only if the 'execve' call fails.  Determine whether\n     /proc is mounted.  If not we return ENOSYS.  */"
    ],
    "fnmatch(const char *, const char *, int)": [
        "/* Convert the strings into wide characters.  Any conversion issue\n         fallback to the ascii version.  */"
    ],
    "__libc_fork()": [
        "/* Determine if we are running multiple threads.  We skip some fork\n     handlers in the single-thread case, to make fork safer to use in\n     signal handlers.  Although POSIX has dropped async-signal-safe\n     requirement for fork (Austin Group tracker issue #62) this is\n     best effort to make is async-signal-safe at least for single-thread\n     case.  */",
        "/* If we are not running multiple threads, we do not have to\n     preserve lock state.  If fork runs from a signal handler, only\n     async-signal-safe functions can be used in the child.  These data\n     structures are only used by unsafe functions, so their state does\n     not matter if fork was called from a signal handler.  */",
        "/* Acquire malloc locks.  This needs to come last because fork\n\t handlers may use malloc, and the libio list lock has an\n\t indirect malloc dependency as well (via the getdelim\n\t function).  */",
        "/* Reset the lock state in the multi-threaded case.  */",
        "/* Release malloc locks.  */",
        "/* Reset the file list.  These are recursive mutexes.  */",
        "/* Reset locks in the I/O code.  */",
        "/* Reset the lock the dynamic loader uses to protect its data.  */",
        "/* Reset the lock protecting dynamic TLS related data.  */",
        "/* Run the handlers registered for the child.  */",
        "/* If _Fork failed, preserve its errno value.  */",
        "/* Release acquired locks in the multi-threaded case.  */",
        "/* Release malloc locks, parent process variant.  */",
        "/* We execute this even if the 'fork' call failed.  */",
        "/* Run the handlers registered for the parent.  */"
    ],
    "gai_strerror(int)": [],
    "getopt(int, char *const *, const char *)": [],
    "getopt_long(int, char *const *, const char *, const struct option *, int *)": [],
    "getopt_long_only(int, char *const *, const char *, const struct option *, int *)": [],
    "__getpgid(pid_t)": [
        "/* Assume atomic word fetch and store, so don't lock _hurd_pid_lock.  */"
    ],
    "getpgrp()": [],
    "__getpid()": [
        "/* Assumes atomic word fetch and store, so doesn't lock _hurd_pid_lock.  */"
    ],
    "getsid(pid_t)": [],
    "glob(const char *, int, int (*)(const char *, int), glob_t *)": [
        "/* POSIX requires all slashes to be matched.  This means that with\n     a trailing slash we must match only directories.  */",
        "/* Have to do this so 'globfree' knows where to start freeing.  It\n       also makes all the code that uses gl_offs simpler. */",
        "/* Allocate working buffer large enough for our work.  Note that\n             we have at least an opening and closing brace.  */",
        "/* We know the prefix for all sub-patterns.  */",
        "/* Find the first sub-pattern and at the same time find the\n             rest after the closing brace.  */",
        "/* It is an invalid expression.  */",
        "/* Now find the end of the whole brace expression.  */",
        "/* It is an illegal expression.  */",
        "/* Please note that we now can be sure the brace expression\n             is well-formed.  */",
        "/* We have a brace expression.  BEGIN points to the opening {,\n             NEXT points past the terminator of the first element, and END\n             points past the final }.  We will accumulate result names from\n             recursive runs for each brace alternative in the buffer using\n             GLOB_APPEND.  */",
        "/* Construct the new glob expression.  */",
        "/* If we got an error, return it.  */",
        "/* We saw the last entry.  */",
        "/* We found some entries.  */",
        "/* Find the filename.  */",
        "/* The case of \"d:pattern\".  Since ':' is not allowed in\n     file names, we can safely assume that wherever it\n     happens in pattern, it signals the filename part.  This\n     is so we could some day support patterns like \"[a-z]:foo\".  */",
        "/* __MSDOS__ || WINDOWS32 */",
        "/* This can mean two things: a simple name or \"~name\".  The latter\n         case is nothing but a notation for a directory.  */",
        "/* Set FILENAME to NULL as a special flag.  This is ugly but\n             other solutions would require much more code.  We test for\n             this special case below.  */",
        "/* \"/pattern\" or \"\\\\/pattern\".  */",
        "/* For now, disallow wildcards in the drive spec, to\n             prevent infinite recursion in glob.  */",
        "/* If this is \"d:pattern\", we need to copy ':' to DIRNAME\n             as well.  If it's \"d:/pattern\", don't remove the slash\n             from \"d:/\", since \"d:\" and \"d:/\" are not the same.*/",
        "/* \"pattern/\".  Expand \"pattern\", appending slashes.  */",
        "/* \"pattern\\\\/\".  Remove the final backslash if it hasn't\n                 been quoted.  */",
        "/* Make sure globfree (&dirs); is a nop.  */",
        "/* Look up home directory.  */",
        "/* Windows NT defines HOMEDRIVE and HOMEPATH.  But give\n                 preference to HOME, because the user can change HOME.  */",
        "/* poor default */",
        "/* WINDOWS32 */",
        "/* No luck.  */",
        "/* Now construct the full directory.  */",
        "/* Recognize ~user as a shorthand for the specified user's home\n             directory.  */",
        "/* \"~fo\\\\o\\\\\" unescape to user_name \"foo\\\\\",\n                                 but \"~fo\\\\o\\\\/\" unescape to user_name\n                                 \"foo\".  */",
        "/* Look up specific user's home directory.  */",
        "/* If we found a home directory use this.  */",
        "/* dirname contains end_name; we can't free it now.  */",
        "/* We have to regard it as an error if we cannot find the\n                       home directory.  */",
        "/* WINDOWS32 */",
        "/* On native Windows, access to a user's home directory\n             (via GetUserProfileDirectory) or to a user's environment\n             variables (via ExpandEnvironmentStringsForUser) requires\n             the credentials of the user.  Therefore we cannot support\n             the ~user syntax on this platform.\n             Handling ~user specially (and treat it like plain ~) if\n             user is getenv (\"USERNAME\") would not be a good idea,\n             since it would make people think that ~user is supported\n             in general.  */",
        "/* WINDOWS32 */",
        "/* Now test whether we looked for \"~\" or \"~NAME\".  In this case we\n     can give the answer now.  */",
        "/* meta is 1 if correct glob pattern containing metacharacters.\n     If meta has bit (1 << 2) set, it means there was an unterminated\n     [ which we handle the same, using fnmatch.  Broken unterminated\n     pattern bracket expressions ought to be rare enough that it is\n     not worth special casing them, fnmatch will do the right thing.  */",
        "/* The directory name contains metacharacters, so we\n         have to glob for the directory, and then glob for\n         the pattern in each directory found.  */",
        "/* \"foo\\\\/bar\".  Remove the final backslash from dirname\n             if it has not been quoted.  */",
        "/* Use the alternative access functions also in the recursive\n             call.  */",
        "/* We have successfully globbed the preceding directory name.\n         For each name we found, call glob_in_dir on it and FILENAME,\n         appending the results to PGLOB.  */",
        "/* No matches in this directory.  Try the next.  */",
        "/* Stick the directory on the front of each name.  */",
        "/* We have ignored the GLOB_NOCHECK flag in the 'glob_in_dir' calls.\n         But if we have not found any matching entry and the GLOB_NOCHECK\n         flag was set we must return the input pattern itself.  */",
        "/* No matches.  */",
        "/* We need to unescape the dirname string.  It is certainly\n             allocated by alloca, as otherwise filename would be NULL\n             or dirname wouldn't contain backslashes.  */",
        "/* Make sure globfree (&dirs); is a nop.  */",
        "/* Stick the directory on the front of each name.  */",
        "/* Append slashes to directory names.  */",
        "/* Sort the vector.  */"
    ],
    "globfree(glob_t *)": [],
    "globfree64(int *)": [],
    "__nanosleep(const struct timespec *, struct timespec *)": [],
    "pause()": [],
    "posix_madvise(void *, int, int)": [
        "/* We have one problem: the kernel's MADV_DONTNEED does not\n     correspond to POSIX's POSIX_MADV_DONTNEED.  The former simply\n     discards changes made to the memory without writing it back to\n     disk, if this would be necessary.  The POSIX behavior does not\n     allow this.  There is no functionality mapping the POSIX behavior\n     so far so we ignore that advice for now.  */"
    ],
    "__libc_pread(int, void *, int, off_t)": [
        "/* Since we must not change the file pointer preserve the value so that\n     we can restore it later.  */",
        "/* Set to wanted position.  */",
        "/* Write out the data.  */",
        "/* Now we have to restore the position.  If this fails we have to\n     return this as an error.  But if the writing also failed we\n     return this error.  */"
    ],
    "__libc_pwrite(int, const void *, int, off_t)": [
        "/* Since we must not change the file pointer preserve the value so that\n     we can restore it later.  */",
        "/* Set to wanted position.  */",
        "/* Write out the data.  */",
        "/* Now we have to restore the position.  If this fails we have to\n     return this as an error.  But if the writing also failed we\n     return this error.  */"
    ],
    "re_compile_pattern(const char *, int, struct re_pattern_buffer *)": [
        "/* And GNU code determines whether or not to get register information\n     by passing null for the REGS argument to re_match, etc., not by\n     setting no_sub, unless RE_NO_SUB is set.  */",
        "/* Match anchors at newline.  */"
    ],
    "re_set_syntax(int)": [],
    "regcomp(int *restrict, const char *restrict, int)": [
        "/* Try to allocate space for the fastmap.  */",
        "/* If REG_NEWLINE is set, newlines are treated differently.  */",
        "/* REG_NEWLINE implies neither . nor [^...] match newline.  */",
        "/* It also changes the matching behavior.  */",
        "/* POSIX doesn't distinguish between an unmatched open-group and an\n     unmatched close-group: both are REG_EPAREN.  */",
        "/* We have already checked preg->fastmap != NULL.  */",
        "/* Compute the fastmap now, since regexec cannot modify the pattern\n       buffer.  This function never fails in this implementation.  */",
        "/* Some error occurred while compiling the expression.  */"
    ],
    "regcomp(regex_t *restrict, const char *restrict, int)": [
        "/* Try to allocate space for the fastmap.  */",
        "/* If REG_NEWLINE is set, newlines are treated differently.  */",
        "/* REG_NEWLINE implies neither . nor [^...] match newline.  */",
        "/* It also changes the matching behavior.  */",
        "/* POSIX doesn't distinguish between an unmatched open-group and an\n     unmatched close-group: both are REG_EPAREN.  */",
        "/* We have already checked preg->fastmap != NULL.  */",
        "/* Compute the fastmap now, since regexec cannot modify the pattern\n       buffer.  This function never fails in this implementation.  */",
        "/* Some error occurred while compiling the expression.  */"
    ],
    "regexec(const regex_t *restrict, const char *restrict, int, regmatch_t *, int)": [],
    "re_match(struct re_pattern_buffer *, const char *, Idx, Idx, struct re_registers *)": [],
    "re_search(struct re_pattern_buffer *, const char *, Idx, Idx, regoff_t, struct re_registers *)": [],
    "re_match_2(struct re_pattern_buffer *, const char *, Idx, const char *, Idx, Idx, struct re_registers *, Idx)": [],
    "re_search_2(struct re_pattern_buffer *, const char *, Idx, const char *, Idx, Idx, regoff_t, struct re_registers *, Idx)": [],
    "re_set_registers(struct re_pattern_buffer *, struct re_registers *, __re_size_t, regoff_t *, regoff_t *)": [],
    "regexec(const int *restrict, const char *restrict, int, int *, int)": [],
    "re_match(struct re_pattern_buffer *, const char *, int, int, struct re_registers *)": [],
    "re_search(struct re_pattern_buffer *, const char *, int, int, int, struct re_registers *)": [],
    "re_match_2(struct re_pattern_buffer *, const char *, int, const char *, int, int, struct re_registers *, int)": [],
    "re_search_2(struct re_pattern_buffer *, const char *, int, const char *, int, int, int, struct re_registers *, int)": [],
    "re_set_registers(struct re_pattern_buffer *, struct re_registers *, int, int *, int *)": [],
    "__register_atfork(void (*)(void), void (*)(void), void (*)(void), void *)": [
        "/* IDs assigned to handlers start at 1 and increment with handler\n         registration.  Un-registering a handlers discards the corresponding\n         ID.  It is not reused in future registrations.  */",
        "/* Release the lock.  */"
    ],
    "__sched_cpualloc(int)": [],
    "__sched_cpucount(int, const cpu_set_t *)": [],
    "__sched_cpufree(cpu_set_t *)": [],
    "sched_getaffinity(pid_t, int, cpu_set_t *)": [],
    "__sched_getparam(pid_t, struct sched_param *)": [],
    "__sched_getscheduler(pid_t)": [],
    "__sched_get_priority_max(int)": [],
    "__sched_get_priority_min(int)": [],
    "sched_setaffinity(pid_t, int, const cpu_set_t *)": [],
    "__sched_setscheduler(pid_t, int, const struct sched_param *)": [],
    "__sched_yield()": [],
    "setgroups(int, const gid_t *)": [],
    "__setpgid(int, int)": [],
    "setpgrp()": [],
    "__shm_get_name(struct shmdir_name *, const char *, int)": [
        "/* For SHM_ANON, we want shm_open () to pass O_TMPFILE to open (),\n         with SHMDIR itself as the path.  So, leave it at that.  */"
    ],
    "posix_spawn_file_actions_addchdir_np(posix_spawn_file_actions_t *, const char *)": [
        "/* Allocate more memory if needed.  */",
        "/* This can only mean we ran out of memory.  */",
        "/* Add the new value.  */",
        "/* Account for the new entry.  */"
    ],
    "posix_spawn_file_actions_addfchdir_np(posix_spawn_file_actions_t *, int)": [
        "/* Allocate more memory if needed.  */",
        "/* This can only mean we ran out of memory.  */",
        "/* Add the new value.  */",
        "/* Account for the new entry.  */"
    ],
    "posix_spawnattr_getsigdefault(const posix_spawnattr_t *, sigset_t *)": [
        "/* Copy the sigset_t data to the user buffer.  */"
    ],
    "posix_spawnattr_getflags(const posix_spawnattr_t *, short *)": [
        "/* Copy the flag word.  */"
    ],
    "posix_spawnattr_getpgroup(const posix_spawnattr_t *, pid_t *)": [
        "/* Copy the process group ID.  */"
    ],
    "posix_spawnattr_getschedparam(const posix_spawnattr_t *, struct sched_param *)": [
        "/* Copy the scheduling parameters.  */"
    ],
    "posix_spawnattr_getschedpolicy(const posix_spawnattr_t *, int *)": [
        "/* Copy the scheduling policy.  */"
    ],
    "posix_spawnattr_getsigmask(const posix_spawnattr_t *, sigset_t *)": [
        "/* Copy the sigset_t data to the user buffer.  */"
    ],
    "posix_spawnattr_setpgroup(posix_spawnattr_t *, pid_t)": [
        "/* Store the process group ID.  */"
    ],
    "posix_spawnattr_setschedparam(posix_spawnattr_t *, const struct sched_param *)": [
        "/* Store the scheduling parameters.  */"
    ],
    "posix_spawnattr_setschedpolicy(posix_spawnattr_t *, int)": [
        "/* Store the policy.  */"
    ],
    "__sysconf(int)": [],
    "__vfork()": [],
    "__wait(int *)": [],
    "__waitpid(pid_t, int *, int)": [],
    "wordfree(wordexp_t *)": [
        "/* wordexp can set pwordexp to NULL */"
    ],
    "herror(const char *)": [
        "/*noconst*/"
    ],
    "hstrerror(int)": [],
    "__inet_aton_exact(const char *, struct in_addr *)": [
        "/* Check that inet_aton_end parsed the entire string.  */"
    ],
    "inet_ntop(int, const void *, char *, socklen_t)": [
        "/* NOTREACHED */"
    ],
    "__inet_pton_length(int, const char *, int, void *)": [],
    "__libc_ns_makecanon(const char *, char *, int)": [
        "/* sizeof == 2.  */",
        "/* Ends in \".\".  */",
        "/* Ends in \"\\.\".  */",
        "/* But not \"\\\\.\".  */"
    ],
    "__libc_ns_samename(const char *, const char *)": [],
    "inet_nsap_addr(const char *, u_char *, int)": [],
    "inet_nsap_ntoa(int, const u_char *, char *)": [],
    "__res_iclose(res_state, int)": [],
    "__res_state()": [],
    "__res_context_hostalias(struct resolv_context *, const char *, char *, int)": [],
    "__res_context_mkquery(struct resolv_context *, int, const char *, int, int, const unsigned char *, unsigned char *, int)": [
        "/* Initialize header fields.  */",
        "/* We randomize the IDs every time.  The old code just incremented\n     by one after the initial randomization which still predictable if\n     the application does multiple requests.  */",
        "/* Perform opcode specific processing.  */",
        "/* Make an additional record for completion domain.  */"
    ],
    "__res_nopt(struct resolv_context *, int, unsigned char *, int, int)": [
        "/* Add the root label.  */",
        "/* Record type.  */",
        "/* Lowering the advertised buffer size based on the actual\n     answer buffer size is desirable because the server will\n     minimize the reply to fit into the UDP packet (and A\n     non-minimal response might not fit the buffer).\n\n     The RESOLV_EDNS_BUFFER_SIZE limit could still result in TCP\n     fallback and a non-minimal response which has to be\n     hard-truncated in the stub resolver, but this is price to\n     pay for avoiding fragmentation.  (This issue does not\n     affect the nss_dns functions because they use the stub\n     resolver in such a way that it allocates a properly sized\n     response buffer.)  */",
        "/* Extended RCODE.  */",
        "/* EDNS version.  */",
        "/* RDATA length (no options are preent).  */"
    ],
    "__libc_res_nameinquery(const char *, int, int, const unsigned char *, const unsigned char *)": [],
    "__libc_res_queriesmatch(const unsigned char *, const unsigned char *, const unsigned char *, const unsigned char *)": [
        "/* Only header section present in replies to dynamic update\n     packets.  */",
        "/* Note that we initially do not convert QDCOUNT to the host byte\n     order.  We can compare it with the second buffer's QDCOUNT\n     value without doing this.  */"
    ],
    "__res_context_query(struct resolv_context *, const char *, int, int, unsigned char *, int, unsigned char **, unsigned char **, int *, int *, int *)": [
        "/* It requires 2 times QUERYSIZE for type == T_QUERY_A_AND_AAAA.  */",
        "/* default */",
        "/* Use RESOLV_EDNS_BUFFER_SIZE because the receive\n\t\t       buffer can be reallocated.  */",
        "/* Use RESOLV_EDNS_BUFFER_SIZE because the receive\n\t\t     buffer can be reallocated.  */",
        "/* Use RESOLV_EDNS_BUFFER_SIZE if the receive buffer\n\t\t   can be reallocated.  */",
        "/* Retry just in case res_nmkquery failed because of too\n\t\t   short buffer.  Shouldn't happen.  */",
        "/* Suppress AAAA lookups if required.  __res_handle_no_aaaa\n\t   checks RES_NOAAAA first, so avoids parsing the\n\t   just-generated query packet in most cases.  nss_dns avoids\n\t   using T_QUERY_A_AND_AAAA in RES_NOAAAA mode, so there is no\n\t   need to handle it here.  */",
        "/* There must be no second query for AAAA queries.  The code\n\t     below is still needed to translate NODATA responses.  */",
        "/* __res_context_send might have reallocated the buffer.  */",
        "/* We simplify the following tests by assigning HP to HP2 or\n\t   vice versa.  It is easy to verify that this is the same as\n\t   ignoring all tests of HP or HP2.  */",
        "/* Make sure both hp and hp2 are defined */",
        "/* Servers must not reply to AAAA queries with\n\t\t\t   NOTIMP etc but some of them do.  */",
        "/* FALLTHROUGH */"
    ],
    "__res_context_search(struct resolv_context *, const char *, int, int, unsigned char *, int, unsigned char **, unsigned char **, int *, int *, int *)": [
        "/* True if we never query. */",
        "/* If there aren't any dots, it could be a user-level alias. */",
        "/*\n\t * If there are enough dots in the name, let's just give it a\n\t * try 'as is'. The threshold can be set with the \"ndots\" option.\n\t * Also, query 'as is', if there is a trailing dot in the name.\n\t */",
        "/* If the second response is valid then we use that.  */",
        "/*\n\t * We do at least one level of search if\n\t *\t- there is no dot and RES_DEFNAME is set, or\n\t *\t- there is at least one dot, there is no trailing dot,\n\t *\t  and RES_DNSRCH is set.\n\t */",
        "/* __res_context_querydoman concatenates name\n\t\t\t   with dname with a \".\" in between.  If we\n\t\t\t   pass it in dname the \".\" we got from the\n\t\t\t   configured default search path, we'll end\n\t\t\t   up with \"name..\", which won't resolve.\n\t\t\t   OTOH, passing it \"\" will result in \"name.\",\n\t\t\t   which has the intended effect for both\n\t\t\t   possible representations of the root\n\t\t\t   domain.  */",
        "/*\n\t\t\t * If no server present, give up.\n\t\t\t * If name isn't found in this domain,\n\t\t\t * keep trying higher domains in the search list\n\t\t\t * (if that's enabled).\n\t\t\t * On a NO_DATA error, keep trying, otherwise\n\t\t\t * a wildcard entry of another type could keep us\n\t\t\t * from finding this entry higher in the domain.\n\t\t\t * If we get some other error (negative answer or\n\t\t\t * server failure), then stop searching up,\n\t\t\t * but try the input name below in case it's\n\t\t\t * fully-qualified.\n\t\t\t */",
        "/* FALLTHROUGH */",
        "/* keep trying */",
        "/* try next search element, if any */",
        "/* FALLTHROUGH */",
        "/* anything else implies that we're done */",
        "/* if we got here for some reason other than DNSRCH,\n\t\t\t * we only wanted one iteration of the loop, so stop.\n\t\t\t */",
        "/*\n\t * If the query has not already been tried as is then try it\n\t * unless RES_NOTLDQUERY is set and there were no dots.\n\t */",
        "/* if we got here, we didn't satisfy the search.\n\t * if we did an initial full query, return that query's H_ERRNO\n\t * (note that we wouldn't be here if that query had succeeded).\n\t * else if we ever got a nodata, send that back as the reason.\n\t * else send back meaningless H_ERRNO, that being the one from\n\t * the last DNSRCH we did.\n\t */"
    ],
    "__res_randomid()": [],
    "__res_context_send(struct resolv_context *, const unsigned char *, int, const unsigned char *, int, unsigned char *, int, unsigned char **, unsigned char **, int *, int *, int *)": [
        "/* On some architectures send_vc is inlined and the compiler might emit\n\t   a warning indicating 'resplen' may be used uninitialized.  Note that\n\t   the warning belongs to resplen in send_vc which is used as return\n\t   value!  There the maybe-uninitialized warning is already ignored as\n\t   it is a false-positive - see comment in send_vc.\n\t   Here the variable n is set to the return value of send_vc.\n\t   See below.  */",
        "/*\n\t * If the ns_addr_list in the resolver context has changed, then\n\t * invalidate our cached copy and the associated timing data.\n\t */",
        "/*\n\t * Maybe initialize our private copy of the ns_addr_list.\n\t */",
        "/* Name server index offset.  Used to implement\n\t   RES_ROTATE.  */",
        "/*\n\t * Send request, RETRY times, or until successful.\n\t */",
        "/* The actual name server index.  This implements\n\t\t   RES_ROTATE.  */",
        "/* Use VC; at most one attempt per server. */",
        "/* See comment at the declaration of n.  */",
        "/* Use datagrams. */",
        "// XXX Check whether both requests failed or",
        "// XXX whether one has been answered successfully",
        "/* See comment at the declaration of n.  Note: resplen = n;  */",
        "/* Mask the AD bit in both responses unless it is\n\t\t   marked trusted.  */",
        "/*\n\t\t * If we have temporarily opened a virtual circuit,\n\t\t * or if we haven't been asked to keep a socket open,\n\t\t * close the socket.\n\t\t */",
        "/*foreach ns*/",
        "/*foreach retry*/",
        "/* no nameservers found */",
        "/* no answer obtained */"
    ],
    "__resolv_context_get()": [],
    "_nss_dns_getcanonname_r(const char *, char *, int, char **, int *, int *)": [
        "/* Just an alibi buffer, res_nquery will allocate a real buffer for\n     us.  */",
        "/* We need to decode the response.  Just one question record.\n\t     And if we got no answers we bail out, too.  */",
        "/* Number of answers.   */",
        "/* Beginning and end of the buffer with query, answer, and the\n\t     rest.  */",
        "/* Skip over the query.  This is the name, type, and class.  */",
        "/* Skip over the name and the two 16-bit values containing type\n\t     and class.  */",
        "/* Now the reply.  First again the name from the query,\n\t\t then type, class, TTL, and the length of the RDATA.\n\t\t We remember the name start.  */",
        "/* Check that there are enough bytes for the RR\n\t\t metadata.  */",
        "/* Check whether type and class match.  */",
        "/* We found the record.  */",
        "/* The buffer is too small.  */",
        "/* Success.  */",
        "/* Skip over TTL.  */",
        "/* Skip over RDATA length and RDATA itself.  */",
        "/* Not enough room for RDATA.  */",
        "/* Restore original buffer before retry.  */"
    ],
    "_nss_dns_gethostbyname3_r(const char *, int, struct hostent *, char *, int, int *, int *, int32_t *, char **)": [],
    "_nss_dns_gethostbyname2_r(const char *, int, struct hostent *, char *, int, int *, int *)": [],
    "_nss_dns_getnetbyname_r(const char *, struct netent *, char *, int, int *, int *)": [
        "/* Return entry for network with NAME.  */",
        "/* Nothing found.  */"
    ],
    "__getrlimit(enum __rlimit_resource, struct rlimit *)": [],
    "nice(int)": [
        "/* -1 is a valid priority, so we use errno to check for an error.  */"
    ],
    "setrlimit64(enum __rlimit_resource, const struct rlimit64 *)": [],
    "vlimit(enum __vlimit_resource, int)": [
        "/* The rlimit codes happen to each be one less\n\t than the corresponding vlimit codes.  */"
    ],
    "mq_close(mqd_t)": [],
    "mq_getattr(mqd_t, struct mq_attr *)": [],
    "mq_notify(mqd_t, const struct sigevent *)": [],
    "mq_receive(mqd_t, char *, int, unsigned int *)": [],
    "mq_send(mqd_t, const char *, int, unsigned int)": [],
    "mq_setattr(mqd_t, const struct mq_attr *restrict, struct mq_attr *restrict)": [],
    "mq_unlink(const char *)": [],
    "timer_create(clockid_t, struct sigevent *, timer_t *)": [
        "/* We don't allow timers for CPU clocks.  At least not in the\n\t moment.  */",
        "/* We have a global thread for delivering timed signals.\n\t If it is not running, try to start it up.  */",
        "/* Copy over thread attributes or set up default ones.  */",
        "/* Ensure thread attributes call for detached thread.  */",
        "/* Try to find existing thread having the right attributes.  */",
        "/* If no existing thread has these attributes, try to allocate one.  */",
        "/* Out of luck; no threads are available.  */",
        "/* If the thread is not running already, try to start it.  */"
    ],
    "timer_delete(timer_t)": [
        "/* Invalid timer ID or the timer is not in use.  */",
        "/* If thread is cancelled while waiting for handler to terminate,\n\t     the mutex is unlocked and timer_delete is aborted.  */",
        "/* If timer is currently being serviced, wait for it to finish.  */",
        "/* Remove timer from whatever queue it may be on and deallocate it.  */"
    ],
    "timer_getoverrun(timer_t)": [],
    "timer_gettime(timer_t, struct itimerspec *)": [],
    "timer_settime(timer_t, int, const struct itimerspec *, struct itimerspec *)": [
        "/* Will need to know current time since this is a relative timer;\n     might as well make the system call outside of the lock now! */",
        "/* One final check of timer validity; this one is possible only\n     until we have the mutex, because it accesses the inuse flag. */",
        "/* A value of { 0, 0 } causes the timer to be stopped. */",
        "/* The user specified the expiration time.  */",
        "/* Only need to wake up the thread if timer is inserted\n\t at the head of the queue. */"
    ],
    "_setjmp(struct __jmp_buf_tag *)": [],
    "setjmp(struct __jmp_buf_tag *)": [],
    "__libc_current_sigrtmin()": [],
    "killpg(__pid_t, int)": [],
    "__libc_sigaction(int, const struct sigaction *, struct sigaction *)": [
        "/* XXX The size argument hopefully will have to be changed to the\n     real size of the user-level sigset_t.  */"
    ],
    "raise(int)": [],
    "__sigaction(int, const struct sigaction *, struct sigaction *)": [],
    "sigaddset(sigset_t *, int)": [],
    "sigaltstack(const stack_t *, stack_t *)": [],
    "sigandset(sigset_t *, const sigset_t *, const sigset_t *)": [],
    "sigdelset(sigset_t *, int)": [],
    "sigemptyset(sigset_t *)": [],
    "sigfillset(sigset_t *)": [],
    "siggetmask()": [],
    "sighold(int)": [],
    "sigignore(int)": [],
    "siginterrupt(int, int)": [
        "/* Defined in signal.c.  */"
    ],
    "sigisemptyset(const sigset_t *)": [],
    "sigismember(const sigset_t *, int)": [],
    "signal(int, __sighandler_t)": [],
    "sigorset(sigset_t *, const sigset_t *, const sigset_t *)": [],
    "__sigpause(int, int)": [
        "/* The modern X/Open implementation is requested.  */",
        "/* Note the sigpause() is a cancellation point.  But since we call\n     sigsuspend() which itself is a cancellation point we do not have\n     to do anything here.  */"
    ],
    "sigpending(sigset_t *)": [],
    "sigrelse(int)": [],
    "sigset(int, __sighandler_t)": [
        "/* Add the signal to the current signal mask.  */",
        "/* If the signal was already blocked signal this to the caller.  */",
        "/* We need to determine whether a specific handler is installed.  */",
        "/* Remove the signal from the current signal mask.  */",
        "/* If the signal was already blocked return SIG_HOLD.  */"
    ],
    "sigstack(struct sigstack *, struct sigstack *)": [
        "/* We have to convert the information.  */",
        "/* For the size of the stack we have no value we can pass to the\n\t kernel.  This is why this function should not be used.  We simply\n\t assume that all the memory down to address zero (in case the stack\n\t grows down) is available.  */",
        "/* Call the kernel.  */",
        "/* Convert the result, if wanted and possible.  */"
    ],
    "__sigsuspend(const sigset_t *)": [],
    "__sigtimedwait(const sigset_t *, siginfo_t *, const struct timespec *)": [],
    "__sysv_signal(int, __sighandler_t)": [
        "/* Check signal extents to protect __sigismember.  */"
    ],
    "accept(int, struct sockaddr *restrict, socklen_t *)": [],
    "__connect(int, const struct sockaddr *, socklen_t)": [
        "/* For the local domain, we must look up the name as a file and talk\n\t to it with the ifsock protocol.  */",
        "/* The file did not grok the ifsock protocol.  */"
    ],
    "getpeername(int, struct sockaddr *restrict, socklen_t *)": [],
    "getsockopt(int, int, int, void *, socklen_t *)": [],
    "isfdtype(int, int)": [],
    "__recv(int, void *, int, int)": [
        "/* The file did not grok the socket protocol.  */"
    ],
    "recvmmsg(int, struct mmsghdr *, unsigned int, int, struct timespec *)": [],
    "__libc_sa_len(sa_family_t)": [],
    "__send(int, const void *, int, int)": [
        "/* The file did not grok the socket protocol.  */"
    ],
    "__sendmmsg(int, struct mmsghdr *, unsigned int, int)": [],
    "shutdown(int, int)": [],
    "sockatmark(int)": [],
    "__socket(int, int, int)": [],
    "socketpair(int, int, int, int *)": [],
    "ctermid(char *)": [
        "/*drop const*/"
    ],
    "cuserid(char *)": [],
    "getw(FILE *)": [
        "/* Is there a better way?  */"
    ],
    "__isoc23_fscanf(FILE *, const char *, ...)": [],
    "__isoc23_scanf(const char *, ...)": [],
    "__isoc23_sscanf(const char *, const char *, ...)": [],
    "__isoc23_vfscanf(FILE *, const char *, va_list)": [],
    "__isoc23_vscanf(const char *, va_list)": [],
    "__isoc23_vsscanf(const char *, const char *, int)": [],
    "__isoc99_fscanf(FILE *, const char *, ...)": [],
    "__isoc99_scanf(const char *, ...)": [],
    "__isoc99_sscanf(const char *, const char *, ...)": [],
    "__isoc99_vfscanf(FILE *, const char *, va_list)": [],
    "__isoc99_vscanf(const char *, va_list)": [],
    "__isoc99_vsscanf(const char *, const char *, int)": [],
    "perror(const char *)": [
        "/* The standard says that 'perror' must not change the orientation\n     of the stream.  What is supposed to happen when the stream isn't\n     oriented yet?  In this case we'll create a new stream which is\n     using the same underlying file descriptor.  */",
        "/* Use standard error as is.  */",
        "/* We don't have to do any special hacks regarding the file\n\t position.  Since the stderr stream wasn't used so far we just\n\t write to the descriptor.  */",
        "/* Close the stream.  */"
    ],
    "parse_printf_format(const char *, int, int *)": [
        "/* Number of arguments.  */",
        "/* Highest index used in a positional arg.  */",
        "/* Search for format specifications.  */",
        "/* Parse this spec.  */",
        "/* If the width is determined by an argument, it is an int.  */",
        "/* If the precision is determined by an argument, it is an int.  */",
        "/* No arguments.  */",
        "/* One argument; we already have the type.  */",
        "/* We have more than one argument for this format spec.  We must\n               call the arginfo function again to determine all the types.  */"
    ],
    "printf_size_info(const struct printf_info *, int, int *)": [
        "/* We need only one double or long double argument.  */"
    ],
    "psiginfo(const siginfo_t *, const char *)": [],
    "psignal(int, const char *)": [],
    "putw(int, FILE *)": [
        "/* Is there a better way?  */"
    ],
    "remove(const char *)": [
        "/* First try to unlink since this is more frequently the necessary action. */",
        "/* If it is indeed a directory...  */",
        "/* ...try to remove it.  */",
        "/* Cannot remove the object for whatever reason.  */"
    ],
    "rename(const char *, const char *)": [],
    "tempnam(const char *, const char *)": [],
    "tmpnam(char *)": [
        "/* By using two buffers we manage to be thread safe in the case\n     where S != NULL.  */",
        "/* In the following call we use the buffer pointed to by S if\n     non-NULL although we don't know the size.  But we limit the size\n     to L_tmpnam characters in any case.  */"
    ],
    "tmpnam_r(char *)": [],
    "a64l(const char *)": [],
    "abort()": [
        "/* First acquire the lock.  */",
        "/* Now it's for sure we are alone.  But recursive calls are possible.  */",
        "/* Unblock SIGABRT.  */",
        "/* Send signal which possibly calls a user handler.  */",
        "/* This stage is special: we must allow repeated calls of\n\t `abort' when a user defined handler for SIGABRT is installed.\n\t This is risky since the `raise' implementation might also\n\t fail but I don't see another possibility.  */",
        "/* There was a handler installed.  Now remove it.  */",
        "/* Try again.  */",
        "/* Now try to abort using the system specific command.  */",
        "/* If we can't signal ourselves and the abort instruction failed, exit.  */",
        "/* If even this fails try to use the provided instruction to crash\n     or otherwise make sure we never return.  */",
        "/* Try for ever and ever.  */"
    ],
    "abs(int)": [],
    "atof(const char *)": [],
    "atoi(const char *)": [],
    "atol(const char *)": [],
    "atoll(const char *)": [],
    "bsearch(const void *, const void *, int, int, __compar_fn_t)": [],
    "realpath(const char *, char *)": [],
    "canonicalize_file_name(const char *)": [],
    "__cxa_at_quick_exit(void (*)(void *), void *)": [],
    "__cxa_finalize(void *)": [
        "/* We don't want to run this cleanup more than once.  The Itanium\n\t       C++ ABI requires that multiple calls to __cxa_finalize not\n\t       result in calling termination functions more than once.  One\n\t       potential scenario where that could happen is with a concurrent\n\t       dlclose and exit, where the running dlclose must at some point\n\t       release the list lock, an exiting thread may acquire it, and\n\t       without setting flavor to ef_free, might re-run this destructor\n\t       which could result in undefined behaviour.  Therefore we must\n\t       set flavor to ef_free to avoid calling this destructor again.\n\t       Note that the concurrent exit must also take the dynamic loader\n\t       lock (for library finalizer processing) and therefore will\n\t       block while dlclose completes the processing of any in-progress\n\t       exit functions. Lastly, once we release the list lock for the\n\t       entry marked ef_free, we must not read from that entry again\n\t       since it may have been reused by the time we take the list lock\n\t       again.  Lastly the detection of new registered exit functions is\n\t       based on a monotonically incrementing counter, and there is an\n\t       ABA if between the unlock to run the exit function and the\n\t       re-lock after completion the user registers 2^64 exit functions,\n\t       the implementation will not detect this and continue without\n\t       executing any more functions.\n\n\t       One minor issue remains: A registered exit function that is in\n\t       progress by a call to dlclose() may not completely finish before\n\t       the next registered exit function is run. This may, according to\n\t       some readings of POSIX violate the requirement that functions\n\t       run in effective LIFO order.  This should probably be fixed in a\n\t       future implementation to ensure the functions do not run in\n\t       parallel.  */",
        "/* Unlock the list while we call a foreign function.  */",
        "/* It is possible that that last exit function registered\n\t       more exit functions.  Start the loop over.  */",
        "/* Also remove the quick_exit handlers, but do not call them.  */",
        "/* Remove the registered fork handlers.  We do not have to\n     unregister anything if the program is going to terminate anyway.  */"
    ],
    "__cxa_thread_atexit_impl(dtor_func, void *, void *)": [
        "/* Prepend.  */",
        "/* We have to acquire the big lock to prevent a racing dlclose from pulling\n     our DSO from underneath us while we're setting up our destructor.  */",
        "/* See if we already encountered the DSO.  */",
        "/* If the address is not recognized the call comes from the main\n\t program (we hope).  */",
        "/* This increment may only be concurrently observed either by the decrement\n     in __call_tls_dtors since the other l_tls_dtor_count access in\n     _dl_close_worker is protected by the dl_load_lock.  The execution in\n     __call_tls_dtors does not really depend on this value beyond the fact that\n     it should be atomic, so Relaxed MO should be sufficient.  */"
    ],
    "__call_tls_dtors()": [
        "/* Ensure that the MAP dereference happens before\n\t l_tls_dtor_count decrement.  That way, we protect this access from a\n\t potential DSO unload in _dl_close_worker, which happens when\n\t l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */"
    ],
    "div(int, int)": [],
    "drand48()": [],
    "drand48_r(struct drand48_data *, double *)": [],
    "erand48(unsigned short *)": [],
    "fmtmsg(long, const char *, int, const char *, const char *, const char *)": [
        "/* Make sure everything is initialized.  */",
        "/* Start the real work.  First check whether the input is ok.  */",
        "/* Must be two fields, separated by a colon.  */",
        "/* The first field must not contain more than 10 bytes.  */",
        "/* The second field must not have more than 14 bytes.  */",
        "/* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */",
        "/* Bingo.  */",
        "/* If we don't know anything about the severity level return an error.  */",
        "/* Now we can print.  */",
        "/* Oh, oh.  An error occurred during the output.  */"
    ],
    "getcontext(ucontext_t *)": [],
    "getentropy(void *, int)": [
        "/* The interface is documented to return EIO for buffer lengths\n     longer than 256 bytes.  */",
        "/* Try to fill the buffer completely.  Even with the 256 byte limit\n     above, we might still receive an EINTR error (when blocking\n     during boot).  */",
        "/* NB: No cancellation point.  */",
        "/* Try again if interrupted by a signal.  */",
        "/* No more bytes available.  This should not happen under\n             normal circumstances.  */",
        "/* Try again in case of a short read.  */"
    ],
    "getenv(const char *)": [],
    "getsubopt(char **, char *const *, char **)": [
        "/* Find end of next token.  */",
        "/* Find start of value.  */",
        "/* Try to match the characters between *OPTIONP and VSTART against\n     one of the TOKENS.  */",
        "/* We found the current option in TOKENS.  */",
        "/* The current suboption does not match any option.  */"
    ],
    "jrand48(unsigned short *)": [],
    "l64a(long)": [
        "/* The standard says that only 32 bits are used.  */",
        "/* The value for N == 0 is defined to be the empty string. */"
    ],
    "labs(long)": [],
    "lcong48(unsigned short *)": [],
    "ldiv(long, long)": [],
    "llabs(long long)": [],
    "lldiv(long long, long long)": [],
    "lrand48()": [],
    "lrand48_r(struct drand48_data *, long *)": [
        "/* Be generous for the arguments, detect some errors.  */"
    ],
    "makecontext(ucontext_t *, void (*)(void), int, ...)": [],
    "mblen(const char *, int)": [
        "/* If S is NULL the function has to return null or not null\n     depending on the encoding having a state depending encoding or\n     not.  */",
        "/* Get the conversion functions.  */",
        "/* Reset the state.  */",
        "/* According to the ISO C 89 standard this is the expected behaviour.  */",
        "/* The `mbrtowc' functions tell us more than we need.  Fold the -1\n\t and -2 result into -1.  */"
    ],
    "mbstowcs(int *, const char *, int)": [
        "/* Return how many we wrote (or maybe an error).  */"
    ],
    "mbtowc(int *, const char *, int)": [
        "/* If S is NULL the function has to return null or not null\n     depending on the encoding having a state depending encoding or\n     not.  */",
        "/* Get the conversion functions.  */",
        "/* This is an extension in the Unix standard which does not directly\n\t violate ISO C.  */",
        "/* The `mbrtowc' functions tell us more than we need.  Fold the -1\n\t and -2 result into -1.  */"
    ],
    "mrand48()": [],
    "mrand48_r(struct drand48_data *, long *)": [
        "/* Be generous for the arguments, detect some errors.  */"
    ],
    "nrand48(unsigned short *)": [],
    "putenv(char *)": [],
    "rand()": [],
    "rand_r(unsigned int *)": [],
    "rpmatch(const char *)": [
        "/* We cache the response patterns and compiled regexps here.  */"
    ],
    "__libc_secure_getenv(const char *)": [],
    "seed48(unsigned short *)": [],
    "setcontext(const ucontext_t *)": [],
    "setenv(const char *, const char *, int)": [],
    "clearenv()": [
        "/* We allocated this environment so we can free it.  */",
        "/* Clear the environment pointer removes the whole environment.  */"
    ],
    "srand48(long)": [],
    "stdc_bit_ceil_uc(unsigned char)": [],
    "stdc_bit_ceil_ui(unsigned int)": [],
    "stdc_bit_ceil_ul(unsigned long)": [],
    "stdc_bit_ceil_ull(unsigned long long)": [],
    "stdc_bit_ceil_us(unsigned short)": [],
    "stdc_bit_floor_uc(unsigned char)": [],
    "stdc_bit_floor_ui(unsigned int)": [],
    "stdc_bit_floor_ul(unsigned long)": [],
    "stdc_bit_floor_ull(unsigned long long)": [],
    "stdc_bit_floor_us(unsigned short)": [],
    "stdc_bit_width_uc(unsigned char)": [],
    "stdc_bit_width_ui(unsigned int)": [],
    "stdc_bit_width_ul(unsigned long)": [],
    "stdc_bit_width_ull(unsigned long long)": [],
    "stdc_bit_width_us(unsigned short)": [],
    "stdc_count_ones_uc(unsigned char)": [],
    "stdc_count_ones_ui(unsigned int)": [],
    "stdc_count_ones_ul(unsigned long)": [],
    "stdc_count_ones_ull(unsigned long long)": [],
    "stdc_count_ones_us(unsigned short)": [],
    "stdc_count_zeros_uc(unsigned char)": [],
    "stdc_count_zeros_ui(unsigned int)": [],
    "stdc_count_zeros_ul(unsigned long)": [],
    "stdc_count_zeros_ull(unsigned long long)": [],
    "stdc_count_zeros_us(unsigned short)": [],
    "stdc_first_leading_one_uc(unsigned char)": [],
    "stdc_first_leading_one_ui(unsigned int)": [],
    "stdc_first_leading_one_ul(unsigned long)": [],
    "stdc_first_leading_one_ull(unsigned long long)": [],
    "stdc_first_leading_one_us(unsigned short)": [],
    "stdc_first_leading_zero_uc(unsigned char)": [],
    "stdc_first_leading_zero_ui(unsigned int)": [],
    "stdc_first_leading_zero_ul(unsigned long)": [],
    "stdc_first_leading_zero_ull(unsigned long long)": [],
    "stdc_first_leading_zero_us(unsigned short)": [],
    "stdc_first_trailing_one_uc(unsigned char)": [],
    "stdc_first_trailing_one_ui(unsigned int)": [],
    "stdc_first_trailing_one_ul(unsigned long)": [],
    "stdc_first_trailing_one_ull(unsigned long long)": [],
    "stdc_first_trailing_one_us(unsigned short)": [],
    "stdc_first_trailing_zero_uc(unsigned char)": [],
    "stdc_first_trailing_zero_ui(unsigned int)": [],
    "stdc_first_trailing_zero_ul(unsigned long)": [],
    "stdc_first_trailing_zero_ull(unsigned long long)": [],
    "stdc_first_trailing_zero_us(unsigned short)": [],
    "stdc_has_single_bit_uc(unsigned char)": [],
    "stdc_has_single_bit_ui(unsigned int)": [],
    "stdc_has_single_bit_ul(unsigned long)": [],
    "stdc_has_single_bit_ull(unsigned long long)": [],
    "stdc_has_single_bit_us(unsigned short)": [],
    "stdc_leading_ones_uc(unsigned char)": [],
    "stdc_leading_ones_ui(unsigned int)": [],
    "stdc_leading_ones_ul(unsigned long)": [],
    "stdc_leading_ones_ull(unsigned long long)": [],
    "stdc_leading_ones_us(unsigned short)": [],
    "stdc_leading_zeros_uc(unsigned char)": [],
    "stdc_leading_zeros_ui(unsigned int)": [],
    "stdc_leading_zeros_ul(unsigned long)": [],
    "stdc_leading_zeros_ull(unsigned long long)": [],
    "stdc_leading_zeros_us(unsigned short)": [],
    "stdc_trailing_ones_uc(unsigned char)": [],
    "stdc_trailing_ones_ui(unsigned int)": [],
    "stdc_trailing_ones_ul(unsigned long)": [],
    "stdc_trailing_ones_ull(unsigned long long)": [],
    "stdc_trailing_ones_us(unsigned short)": [],
    "stdc_trailing_zeros_uc(unsigned char)": [],
    "stdc_trailing_zeros_ui(unsigned int)": [],
    "stdc_trailing_zeros_ul(unsigned long)": [],
    "stdc_trailing_zeros_ull(unsigned long long)": [],
    "stdc_trailing_zeros_us(unsigned short)": [],
    "strfromd(char *, int, const char *, double)": [
        "/* Single-precision values need to be stored in a double type, because\n     __printf_fp_l and __printf_fphex do not accept the float type.  */",
        "/* Variables to control the output format.  */",
        "/* printf_fp and printf_fphex treat this internally.  */",
        "/* Single-precision values need to be converted into double-precision,\n     because __printf_fp and __printf_fphex only accept double and long double\n     as the floating-point argument.  */",
        "/* Check if the first character in the format string is indeed the '%'\n     character.  Otherwise, abort.  */",
        "/* The optional precision specification always starts with a '.'.  If such\n     character is present, read the precision.  */",
        "/* Parse the precision.  */",
        "/* If only the period is specified, the precision is taken as zero, as\n\t described in ISO/IEC 9899:2011, section 7.21.6.1, 4th paragraph, 3rd\n\t item.  */",
        "/* Now there is only the conversion specifier to be read.  */",
        "/* Prepare the string buffer.  */",
        "/* Prepare the format specification for printf_fp.  */",
        "/* The functions strfromd and strfromf pass a floating-point number with\n     double precision to printf_fp, whereas strfroml passes a floating-point\n     number with long double precision.  The following line informs printf_fp\n     which type of floating-point number is being passed.  */",
        "/* Similarly, the function strfromf128 passes a floating-point number in\n     _Float128 format to printf_fp.  */",
        "/* Set info according to the format string.  */"
    ],
    "strfromf(char *, int, const char *, float)": [
        "/* Single-precision values need to be stored in a double type, because\n     __printf_fp_l and __printf_fphex do not accept the float type.  */",
        "/* Variables to control the output format.  */",
        "/* printf_fp and printf_fphex treat this internally.  */",
        "/* Single-precision values need to be converted into double-precision,\n     because __printf_fp and __printf_fphex only accept double and long double\n     as the floating-point argument.  */",
        "/* Check if the first character in the format string is indeed the '%'\n     character.  Otherwise, abort.  */",
        "/* The optional precision specification always starts with a '.'.  If such\n     character is present, read the precision.  */",
        "/* Parse the precision.  */",
        "/* If only the period is specified, the precision is taken as zero, as\n\t described in ISO/IEC 9899:2011, section 7.21.6.1, 4th paragraph, 3rd\n\t item.  */",
        "/* Now there is only the conversion specifier to be read.  */",
        "/* Prepare the string buffer.  */",
        "/* Prepare the format specification for printf_fp.  */",
        "/* The functions strfromd and strfromf pass a floating-point number with\n     double precision to printf_fp, whereas strfroml passes a floating-point\n     number with long double precision.  The following line informs printf_fp\n     which type of floating-point number is being passed.  */",
        "/* Similarly, the function strfromf128 passes a floating-point number in\n     _Float128 format to printf_fp.  */",
        "/* Set info according to the format string.  */"
    ],
    "strfroml(char *, int, const char *, long double)": [
        "/* Single-precision values need to be stored in a double type, because\n     __printf_fp_l and __printf_fphex do not accept the float type.  */",
        "/* Variables to control the output format.  */",
        "/* printf_fp and printf_fphex treat this internally.  */",
        "/* Single-precision values need to be converted into double-precision,\n     because __printf_fp and __printf_fphex only accept double and long double\n     as the floating-point argument.  */",
        "/* Check if the first character in the format string is indeed the '%'\n     character.  Otherwise, abort.  */",
        "/* The optional precision specification always starts with a '.'.  If such\n     character is present, read the precision.  */",
        "/* Parse the precision.  */",
        "/* If only the period is specified, the precision is taken as zero, as\n\t described in ISO/IEC 9899:2011, section 7.21.6.1, 4th paragraph, 3rd\n\t item.  */",
        "/* Now there is only the conversion specifier to be read.  */",
        "/* Prepare the string buffer.  */",
        "/* Prepare the format specification for printf_fp.  */",
        "/* The functions strfromd and strfromf pass a floating-point number with\n     double precision to printf_fp, whereas strfroml passes a floating-point\n     number with long double precision.  The following line informs printf_fp\n     which type of floating-point number is being passed.  */",
        "/* Similarly, the function strfromf128 passes a floating-point number in\n     _Float128 format to printf_fp.  */",
        "/* Set info according to the format string.  */"
    ],
    "__strtod_internal(const char *, char **, int)": [],
    "strtod(const char *, char **)": [],
    "__strtod_l(const char *, char **, locale_t)": [
        "/* End of configuration part.  */",
        "/* The gmp headers need some configuration frobs.  */",
        "/* Include gmp-mparam.h first, such that definitions of _SHORT_LIMB\n   and _LONG_LONG_LIMB in it can take effect into gmp.h.  */",
        "/* We use this code for the extended locale handling where the\n   function gets as an additional argument the locale which has to be\n   used.  To access the values we have to redefine the _NL_CURRENT and\n   _NL_CURRENT_WORD macros.  */",
        "/* Constants we need from float.h; select the set for the FLOAT precision.  */",
        "/* Extra macros required to get FLT expanded before the pasting.  */",
        "/* Function to construct a floating point number from an MP integer\n   containing the fraction bits, a base 2 exponent, and a sign flag.  */",
        "/* Definitions according to limb size used.  */",
        "/* Maximum size necessary for mpn integers to hold floating point\n   numbers.  The largest number we need to hold is 10^n where 2^-n is\n   1/4 ulp of the smallest representable value (that is, n = MANT_DIG\n   - MIN_EXP + 2).  Approximate using 10^3 < 2^10.  */",
        "/* Declare an mpn integer variable that big.  */",
        "/* Copy an mpn integer value.  */",
        "/* Set errno and return an overflowing value with sign specified by\n   NEGATIVE.  */",
        "/* Set errno and return an underflowing value with sign specified by\n   NEGATIVE.  */",
        "/* Return a floating point number of the needed type according to the given\n   multi-precision number after possible rounding.  */",
        "/* This is a special case to handle the very seldom case where\n\t   the mantissa will be empty after the shift.  */",
        "/* __mpn_rshift requires 0 < shift < BITS_PER_MP_LIMB.  */",
        "/* Whether the result counts as tiny depends on whether,\n\t\t after rounding to the normal precision, it still has\n\t\t a subnormal exponent.  */",
        "/* This is a hook for the m68k long double format, where the\n\t exponent bias is the same for normalized and denormalized\n\t numbers.  */",
        "/* The number was denormalized but now normalized.  */",
        "/* Read a multi-precision integer starting at STR with exactly DIGCNT digits\n   into N.  Return the size of the number limbs in NSIZE at the first\n   character od the string that is not part of the integer as the function\n   value.  If the EXPONENT is small enough to be taken as an additional\n   factor for the resulting number (see code) multiply by it.  */",
        "/* Number of digits for actual limb.  */",
        "/* There might be thousands separators or radix characters in\n\t the string.  But these all can be ignored because we know the\n\t format of the number is correct and we have an exact number\n\t of characters to read.  */",
        "/* Shift {PTR, SIZE} COUNT bits to the left, and fill the vacated bits\n   with the COUNT most significant bits of LIMB.\n\n   Implemented as a macro, so that __builtin_constant_p works even at -O0.\n\n   Tege doesn't like this macro so I have to write it here myself. :)\n   --drepper */",
        "/* We assume count > 0 && count < BITS_PER_MP_LIMB here.  */",
        "/* This file defines a function to check for correct grouping.  */",
        "/* Return a floating point number with the value of the given string NPTR.\n   Set *ENDPTR to the character after the last used one.  If the number is\n   smaller than the smallest representable number, set `errno' to ERANGE and\n   return 0.0.  If the number is too big to be represented, set `errno' to\n   ERANGE and return HUGE_VAL with the appropriate sign.  */",
        "/* The sign of the number.  */",
        "/* MP representation of the number.  */",
        "/* Exponent of the number.  */",
        "/* Numbers starting `0X' or `0x' have to be processed with base 16.  */",
        "/* When we have to compute fractional digits we form a fraction with a\n     second multi-precision number (and we sometimes need a second for\n     temporary results).  */",
        "/* Representation for the return value.  */",
        "/* Number of bits currently in result value.  */",
        "/* Running pointer after the last character processed in the string.  */",
        "/* Start of significant part of the number.  */",
        "/* Points at the character following the integer and fractional digits.  */",
        "/* Total number of digit and number of digits in integer part.  */",
        "/* Contains the last character read.  */",
        "/* We should get wint_t from <stddef.h>, but not all GCC versions define it\n   there.  So define it ourselves if it remains undefined.  */",
        "/* The radix character of the current locale.  */",
        "/* The thousands character of the current locale.  */",
        "/* The numeric grouping specification of the current locale,\n     in the format described in <locale.h>.  */",
        "/* Used in several places.  */",
        "/* Figure out the thousands separator character.  */",
        "/* Find the locale's decimal point character.  */",
        "/* Prepare number representation.  */",
        "/* Parse string to get maximal legal prefix.  We need the number of\n     characters of the integer part, the fractional part and the exponent.  */",
        "/* Ignore leading white space.  */",
        "/* Get sign of the result.  */",
        "/* Return 0.0 if no legal string is found.\n     No character is used even if a sign was found.  */",
        "/* We accept it.  This funny construct is here only to indent\n\t the code correctly.  */",
        "/* We accept it.  This funny construct is here only to indent\n\t the code correctly.  */",
        "/* Check for `INF' or `INFINITY'.  */",
        "/* Return +/- infinity.  */",
        "/* Return NaN.  */",
        "/* Match `(n-char-sequence-digit)'.  */",
        "/* Consume the closing parenthesis.  */",
        "/* Only match the NAN part.  */",
        "/* It is really a text we do not recognize.  */",
        "/* First look whether we are faced with a hexadecimal number.  */",
        "/* Okay, it is a hexa-decimal number.  Remember this and skip\n\t the characters.  BTW: hexadecimal numbers must not be\n\t grouped.  */",
        "/* Record the start of the digits, in case we will check their grouping.  */",
        "/* Ignore leading zeroes.  This helps us to avoid useless computations.  */",
        "/* We also have the multibyte thousands string.  */",
        "/* If no other digit but a '0' is found the result is 0.0.\n     Return current read pointer.  */",
        "/* '0x.' alone is not a valid hexadecimal number.\n\t       '.' alone is not valid either, but that has been checked\n\t       already earlier.  */",
        "/* If TP is at the start of the digits, there was no correctly\n\t grouped prefix of the string; so no number found.  */",
        "/* Remember first significant digit and read following characters until the\n     decimal point, exponent character or any non-FP number character.  */",
        "/* Not a digit or separator: end of the integer part.  */",
        "/* Check the grouping of the digits.  */",
        "/* Less than the entire string was correctly grouped.  */",
        "/* No valid group of numbers at all: no valid number.  */",
        "/* The number is validly grouped, but consists\n\t       only of zeroes.  The whole value is zero.  */",
        "/* Recompute DIG_NO so we won't read more digits than\n\t     are properly grouped.  */",
        "/* We have the number of digits in the integer part.  Whether these\n     are all or any is really a fractional digit will be decided\n     later.  */",
        "/* Read the fractional digits.  A special case are the 'american\n     style' numbers like `16.' i.e. with decimal point but without\n     trailing digits.  */",
        "/* Remember start of exponent (if any).  */",
        "/* Read exponent.  */",
        "/* Get the exponent limit. */",
        "/* The number is zero and this limit is\n\t\t\t arbitrary.  */",
        "/* The number is zero and this limit is\n\t\t\t arbitrary.  */",
        "/* The exponent is too large/small to represent a valid\n\t\t   number.  */",
        "/* We have to take care for special situation: a joker\n\t\t     might have written \"0.0e100000\" which is in fact\n\t\t     zero.  */",
        "/* Overflow or underflow.  */",
        "/* Accept all following digits as part of the exponent.  */",
        "/* NOTREACHED */",
        "/* We don't want to have to work with trailing zeroes after the radix.  */",
        "/* The whole string is parsed.  Store the address of the next character.  */",
        "/* Find the decimal point */",
        "/* If the BASE is 16 we can use a simpler algorithm.  */",
        "/* We cannot have a leading zero.  */",
        "/* We don't have to care for wrapping.  This is the normal\n\t     case so we add the first clause in the `if' expression as\n\t     an optimization.  It is a compile-time constant and so does\n\t     not cost anything.  */",
        "/* Adjust the exponent for the bits we are shifting in.  */",
        "/* We ran out of digits.  */",
        "/* Now we have the number of digits in total and the integer digits as well\n     as the exponent and its sign.  We can decide whether the read digits are\n     really integer digits or belong to the fractional part; i.e. we normalize\n     123e-2 to 1.23.  */",
        "/* 10^(MIN_10_EXP-1) is not normal.  Thus, 10^(MIN_10_EXP-1) /\n     2^MANT_DIG is below half the least subnormal, so anything with a\n     base-10 exponent less than the base-10 exponent (which is\n     MIN_10_EXP - 1 - ceil(MANT_DIG*log10(2))) of that value\n     underflows.  DIG is floor((MANT_DIG-1)log10(2)), so an exponent\n     below MIN_10_EXP - (DIG + 3) underflows.  But EXPONENT is\n     actually an exponent multiplied only by a fractional part, not an\n     integer part, so an exponent below MIN_10_EXP - (DIG + 2)\n     underflows.  */",
        "/* Read the integer part as a multi-precision number to NUM.  */",
        "/* We now multiply the gained number by the given power of ten.  */",
        "/* FIXME: not the whole multiplication has to be\n\t\t     done.  If we have the needed number of bits we\n\t\t     only need the information whether more non-zero\n\t\t     bits follow.  */",
        "/* Determine how many bits of the result we already have.  */",
        "/* Now we know the exponent of the number in base two.\n\t Check it against the maximum possible exponent.  */",
        "/* We have already the first BITS bits of the result.  Together with\n\t the information whether more non-zero bits follow this is enough\n\t to determine the result.  */",
        "/* Check whether any limb beside the ones in RETVAL are non-zero.  */",
        "/* NOTREACHED */",
        "/* FIXME: the following loop can be avoided if we assume a\n\t\t maximal MANT_DIG value.  */",
        "/* FIXME: the following loop can be avoided if we assume a\n\t\t maximal MANT_DIG value.  */",
        "/* FIXME: the following loop can be avoided if we assume a\n\t\t maximal MANT_DIG value.  */",
        "/* NOTREACHED */",
        "/* Store the bits we already have.  */",
        "/* We have to compute at least some of the fractional digits.  */",
        "/* We construct a fraction and the result of the division gives us\n       the needed digits.  The denominator is 1.0 multiplied by the\n       exponent of the lowest digit; i.e. 0.123 gives 123 / 1000 and\n       123e-6 gives 123 / 1000000.  */",
        "/* We need to compute MANT_DIG - BITS fractional bits that lie\n       within the mantissa of the result, the following bit for\n       rounding, and to know whether any subsequent bit is 0.\n       Computing a bit with value 2^-n means looking at n digits after\n       the decimal point.  */",
        "/* The bits required are those immediately after the point.  */",
        "/* The number is in the form .123eEXPONENT.  */",
        "/* The number is at least 10^(EXPONENT-1), and 10^3 <\n\t   2^10.  */",
        "/* The number is at least 2^-NEG_EXP_2.  We need up to\n\t   MANT_DIG bits following that bit.  */",
        "/* However, we never need bits beyond 1/4 ulp of the smallest\n\t   representable value.  (That 1/4 ulp bit is only needed to\n\t   determine tinyness on machines where tinyness is determined\n\t   after rounding.)  */",
        "/* At this point, NEED_FRAC_DIGITS is the total number of\n\t   digits needed after the point, but some of those may be\n\t   leading 0s.  */",
        "/* Any cases underflowing enough that none of the fractional\n\t   digits are needed should have been caught earlier (such\n\t   cases are on the order of 10^-n or smaller where 2^-n is\n\t   the least subnormal).  */",
        "/* Construct the denominator.  */",
        "/* Read the fractional digits from the string.  */",
        "/* We now have to shift both numbers so that the highest bit in the\n       denominator is set.  In the same process we copy the numerator to\n       a high place in the array so that the division constructs the wanted\n       digits.  This is done by a \"quasi fix point\" number representation.\n\n       num:   ddddddddddd . 0000000000000000000000\n\t      |--- m ---|\n       den:                            ddddddddddd      n >= m\n\t\t\t\t       |--- n ---|\n     */",
        "/* Don't call `mpn_shift' with a count of zero since the specification\n\t   does not allow this.  */",
        "/* Now we are ready for the division.  But it is not necessary to\n       do a full multi-precision division because we only need a small\n       number of bits for the result.  So we do not use __mpn_divmod\n       here but instead do the division here by hand and stop whenever\n       the needed number of bits is reached.  The code itself comes\n       from the GNU MP Library by Torbj\\\"orn Granlund.  */",
        "/* Note that we only clear the second element.  */",
        "/* The conditional is determined at compile time.  */",
        "/* The numerator of the number occupies fewer bits than\n\t\t     the denominator but the one limb is bigger than the\n\t\t     high limb of the numerator.  */",
        "/* QUOT should be either 111..111 or 111..110.  We need\n\t\t     special treatment of this rare case as normal division\n\t\t     would give overflow.  */",
        "/* Carry in the addition?  */",
        "/* The estimated QUOT was too large.  */",
        "/* If not carry, test QUOT again.  */",
        "/* The division does not work if the upper limb of the two-limb\n\t     numerator is greater than or equal to the denominator.  */",
        "/* We make a difference here because the compiler\n\t\t\t cannot optimize the `else' case that good and\n\t\t\t this reflects all currently used FLOAT types\n\t\t\t and GMP implementations.  */",
        "/* This might over-estimate QUOT, but it's probably not\n\t\t   worth the extra code here to find out.  */",
        "/* I.e. \"carry in previous addition?\" */",
        "/* Possible optimization: We already have (q * n0) and (1 * n1)\n\t\t after the calculation of QUOT.  Taking advantage of this, we\n\t\t could make this loop make two iterations less.  */",
        "/* NOTREACHED */",
        "/* External user entry point.  */"
    ],
    "__strtod_nan(const char *, char **, char)": [
        "/* This is a system-dependent way to specify the bitmask used for\n     the NaN.  We expect it to be a number which is put in the\n     mantissa of the number.  */"
    ],
    "__strtof_internal(const char *, char **, int)": [],
    "strtof(const char *, char **)": [],
    "__strtof_l(const char *, char **, locale_t)": [],
    "__strtof_nan(const char *, char **, char)": [
        "/* This is a system-dependent way to specify the bitmask used for\n     the NaN.  We expect it to be a number which is put in the\n     mantissa of the number.  */"
    ],
    "__strtol_internal(const char *, char **, int, int)": [],
    "__strtol_l(const char *, char **, int, locale_t)": [
        "/* We use this code for the extended locale handling where the\n   function gets as an additional argument the locale which has to be\n   used.  To access the values we have to redefine the _NL_CURRENT and\n   _NL_CURRENT_WORD macros.  */",
        "/* This file defines a function to check for correct grouping.  */",
        "/* Define tables of maximum values and remainders in order to detect\n   overflow.  Do this at compile-time in order to avoid the runtime\n   overhead of the division.  */",
        "/* Define some more readable aliases for these arrays which correspond\n   to how they'll be used in the function below.  */",
        "/* Convert NPTR to an `unsigned long int' or `long int' in base BASE.\n   If BASE is 0 the base is determined by the presence of a leading\n   zero, indicating octal or a leading \"0x\" or \"0X\", indicating hexadecimal.\n   If BASE is < 2 or > 36, it is reset to 10.\n   If BIN_CST is true, binary constants starting \"0b\" or \"0B\" are accepted\n   in base 0 and 2.\n   If ENDPTR is not NULL, a pointer to the character after the last\n   one converted is stored in *ENDPTR.  */",
        "/* The thousands character of the current locale.  */",
        "/* The numeric grouping specification of the current locale,\n     in the format described in <locale.h>.  */",
        "/* Figure out the thousands separator character.  */",
        "/* Skip white space.  */",
        "/* Check for a sign.  */",
        "/* Recognize number prefix and if BASE is zero, figure it out ourselves.  */",
        "/* Save the pointer so we can check later if anything happened.  */",
        "/* Find the end of the digit string and check its grouping.  */",
        "/* Avoid runtime division; lookup cutoff and limit.  */",
        "/* Note that we never can have an overflow.  */",
        "/* We have an overflow.  Now use the long representation.  */",
        "/* Check for overflow.  */",
        "/* Check if anything actually happened.  */",
        "/* Store in ENDPTR the address of one character\n     past the last character we converted.  */",
        "/* Check for a value that is within the range of\n     `unsigned LONG int', but outside the range of `LONG int'.  */",
        "/* Return the result of the appropriate sign.  */",
        "/* We must handle a special case here: the base is 0 or 16 and the\n     first two characters are '0' and 'x', but the rest are no\n     hexadecimal digits.  Likewise when the base is 0 or 2 and the\n     first two characters are '0' and 'b', but the rest are no binary\n     digits.  This is no error case.  We return 0 and ENDPTR points to\n     the 'x' or 'b'.  */",
        "/*  There was no number to convert.  */",
        "/* External user entry point.  */",
        "/* Prototype.  */"
    ],
    "__strtold_internal(const char *, char **, int)": [],
    "strtold(const char *, char **)": [],
    "__strtold_nan(const char *, char **, char)": [
        "/* This is a system-dependent way to specify the bitmask used for\n     the NaN.  We expect it to be a number which is put in the\n     mantissa of the number.  */"
    ],
    "__strtoll_internal(const char *, char **, int, int)": [],
    "__strtoll_l(const char *, char **, int, locale_t)": [
        "/* We use this code for the extended locale handling where the\n   function gets as an additional argument the locale which has to be\n   used.  To access the values we have to redefine the _NL_CURRENT and\n   _NL_CURRENT_WORD macros.  */",
        "/* This file defines a function to check for correct grouping.  */",
        "/* Define tables of maximum values and remainders in order to detect\n   overflow.  Do this at compile-time in order to avoid the runtime\n   overhead of the division.  */",
        "/* Define some more readable aliases for these arrays which correspond\n   to how they'll be used in the function below.  */",
        "/* Convert NPTR to an `unsigned long int' or `long int' in base BASE.\n   If BASE is 0 the base is determined by the presence of a leading\n   zero, indicating octal or a leading \"0x\" or \"0X\", indicating hexadecimal.\n   If BASE is < 2 or > 36, it is reset to 10.\n   If BIN_CST is true, binary constants starting \"0b\" or \"0B\" are accepted\n   in base 0 and 2.\n   If ENDPTR is not NULL, a pointer to the character after the last\n   one converted is stored in *ENDPTR.  */",
        "/* The thousands character of the current locale.  */",
        "/* The numeric grouping specification of the current locale,\n     in the format described in <locale.h>.  */",
        "/* Figure out the thousands separator character.  */",
        "/* Skip white space.  */",
        "/* Check for a sign.  */",
        "/* Recognize number prefix and if BASE is zero, figure it out ourselves.  */",
        "/* Save the pointer so we can check later if anything happened.  */",
        "/* Find the end of the digit string and check its grouping.  */",
        "/* Avoid runtime division; lookup cutoff and limit.  */",
        "/* Note that we never can have an overflow.  */",
        "/* We have an overflow.  Now use the long representation.  */",
        "/* Check for overflow.  */",
        "/* Check if anything actually happened.  */",
        "/* Store in ENDPTR the address of one character\n     past the last character we converted.  */",
        "/* Check for a value that is within the range of\n     `unsigned LONG int', but outside the range of `LONG int'.  */",
        "/* Return the result of the appropriate sign.  */",
        "/* We must handle a special case here: the base is 0 or 16 and the\n     first two characters are '0' and 'x', but the rest are no\n     hexadecimal digits.  Likewise when the base is 0 or 2 and the\n     first two characters are '0' and 'b', but the rest are no binary\n     digits.  This is no error case.  We return 0 and ENDPTR points to\n     the 'x' or 'b'.  */",
        "/*  There was no number to convert.  */",
        "/* External user entry point.  */",
        "/* Prototype.  */"
    ],
    "__strtoul_internal(const char *, char **, int, int)": [
        "/* If QUAD is defined, we are defining `strtoll' or `strtoull',\n   operating on `long long int's.  */"
    ],
    "__strtoul_l(const char *, char **, int, locale_t)": [
        "/* Determine the name.  */",
        "/* If QUAD is defined, we are defining `strtoll' or `strtoull',\n   operating on `long long int's.  */",
        "/* We use this code for the extended locale handling where the\n   function gets as an additional argument the locale which has to be\n   used.  To access the values we have to redefine the _NL_CURRENT and\n   _NL_CURRENT_WORD macros.  */",
        "/* This file defines a function to check for correct grouping.  */",
        "/* Define tables of maximum values and remainders in order to detect\n   overflow.  Do this at compile-time in order to avoid the runtime\n   overhead of the division.  */",
        "/* Define some more readable aliases for these arrays which correspond\n   to how they'll be used in the function below.  */",
        "/* Convert NPTR to an `unsigned long int' or `long int' in base BASE.\n   If BASE is 0 the base is determined by the presence of a leading\n   zero, indicating octal or a leading \"0x\" or \"0X\", indicating hexadecimal.\n   If BASE is < 2 or > 36, it is reset to 10.\n   If BIN_CST is true, binary constants starting \"0b\" or \"0B\" are accepted\n   in base 0 and 2.\n   If ENDPTR is not NULL, a pointer to the character after the last\n   one converted is stored in *ENDPTR.  */",
        "/* The thousands character of the current locale.  */",
        "/* The numeric grouping specification of the current locale,\n     in the format described in <locale.h>.  */",
        "/* Figure out the thousands separator character.  */",
        "/* Skip white space.  */",
        "/* Check for a sign.  */",
        "/* Recognize number prefix and if BASE is zero, figure it out ourselves.  */",
        "/* Save the pointer so we can check later if anything happened.  */",
        "/* Find the end of the digit string and check its grouping.  */",
        "/* Avoid runtime division; lookup cutoff and limit.  */",
        "/* Note that we never can have an overflow.  */",
        "/* We have an overflow.  Now use the long representation.  */",
        "/* Check for overflow.  */",
        "/* Check if anything actually happened.  */",
        "/* Store in ENDPTR the address of one character\n     past the last character we converted.  */",
        "/* Check for a value that is within the range of\n     `unsigned LONG int', but outside the range of `LONG int'.  */",
        "/* Return the result of the appropriate sign.  */",
        "/* We must handle a special case here: the base is 0 or 16 and the\n     first two characters are '0' and 'x', but the rest are no\n     hexadecimal digits.  Likewise when the base is 0 or 2 and the\n     first two characters are '0' and 'b', but the rest are no binary\n     digits.  This is no error case.  We return 0 and ENDPTR points to\n     the 'x' or 'b'.  */",
        "/*  There was no number to convert.  */",
        "/* External user entry point.  */",
        "/* Prototype.  */"
    ],
    "__strtoull_internal(const char *, char **, int, int)": [
        "/* If QUAD is defined, we are defining `strtoll' or `strtoull',\n   operating on `long long int's.  */"
    ],
    "__strtoull_l(const char *, char **, int, locale_t)": [
        "/* Determine the name.  */",
        "/* If QUAD is defined, we are defining `strtoll' or `strtoull',\n   operating on `long long int's.  */",
        "/* We use this code for the extended locale handling where the\n   function gets as an additional argument the locale which has to be\n   used.  To access the values we have to redefine the _NL_CURRENT and\n   _NL_CURRENT_WORD macros.  */",
        "/* This file defines a function to check for correct grouping.  */",
        "/* Define tables of maximum values and remainders in order to detect\n   overflow.  Do this at compile-time in order to avoid the runtime\n   overhead of the division.  */",
        "/* Define some more readable aliases for these arrays which correspond\n   to how they'll be used in the function below.  */",
        "/* Convert NPTR to an `unsigned long int' or `long int' in base BASE.\n   If BASE is 0 the base is determined by the presence of a leading\n   zero, indicating octal or a leading \"0x\" or \"0X\", indicating hexadecimal.\n   If BASE is < 2 or > 36, it is reset to 10.\n   If BIN_CST is true, binary constants starting \"0b\" or \"0B\" are accepted\n   in base 0 and 2.\n   If ENDPTR is not NULL, a pointer to the character after the last\n   one converted is stored in *ENDPTR.  */",
        "/* The thousands character of the current locale.  */",
        "/* The numeric grouping specification of the current locale,\n     in the format described in <locale.h>.  */",
        "/* Figure out the thousands separator character.  */",
        "/* Skip white space.  */",
        "/* Check for a sign.  */",
        "/* Recognize number prefix and if BASE is zero, figure it out ourselves.  */",
        "/* Save the pointer so we can check later if anything happened.  */",
        "/* Find the end of the digit string and check its grouping.  */",
        "/* Avoid runtime division; lookup cutoff and limit.  */",
        "/* Note that we never can have an overflow.  */",
        "/* We have an overflow.  Now use the long representation.  */",
        "/* Check for overflow.  */",
        "/* Check if anything actually happened.  */",
        "/* Store in ENDPTR the address of one character\n     past the last character we converted.  */",
        "/* Check for a value that is within the range of\n     `unsigned LONG int', but outside the range of `LONG int'.  */",
        "/* Return the result of the appropriate sign.  */",
        "/* We must handle a special case here: the base is 0 or 16 and the\n     first two characters are '0' and 'x', but the rest are no\n     hexadecimal digits.  Likewise when the base is 0 or 2 and the\n     first two characters are '0' and 'b', but the rest are no binary\n     digits.  This is no error case.  We return 0 and ENDPTR points to\n     the 'x' or 'b'.  */",
        "/*  There was no number to convert.  */",
        "/* External user entry point.  */",
        "/* Prototype.  */"
    ],
    "swapcontext(ucontext_t *, const ucontext_t *)": [],
    "__libc_system(const char *)": [
        "/* Check that we have a command processor available.  It might\n       not be available after a chroot(), for example.  */"
    ],
    "wcstombs(char *, const int *, int)": [
        "/* Return how many we wrote (or maybe an error).  */"
    ],
    "wctomb(char *, int)": [
        "/* If S is NULL the function has to return null or not null\n     depending on the encoding having a state depending encoding or\n     not.  */",
        "/* Get the conversion functions.  */",
        "/* This is an extension in the Unix standard which does not directly\n\t violate ISO C.  */"
    ],
    "__xpg_basename(char *)": [
        "/* We return a pointer to a static string containing \".\".  */",
        "/* There is no slash in the filename.  Return the whole string.  */",
        "/* We must remove trailing '/'.  */",
        "/* Now we can be in two situations:\n\t\t a) the string only contains '/' characters, so we return\n\t\t    '/'\n\t\t b) p points past the last component, but we have to remove\n\t\t    the trailing slash.  */",
        "/* The last slash we already found is the right position\n\t\t   to return.  */",
        "/* Go to the first character of the name.  */"
    ],
    "__strerror_r(int, char *, int)": [],
    "__argz_count(const char *, int)": [],
    "argz_delete(char **, int *, char *)": [
        "/* Get rid of the old value for NAME.  */"
    ],
    "__argz_next(const char *, int, const char *)": [],
    "__argz_stringify(char *, int, int)": [
        "/* includes final '\\0' we want to stop at */"
    ],
    "bcopy(const void *, void *, int)": [],
    "__bzero(void *, int)": [],
    "envz_entry(const char *, int, const char *)": [
        "/* Start of this entry. */",
        "/* See how far NAME and ENTRY match.  */",
        "/* Bingo! */",
        "/* No match, skip to the next entry.  */",
        "/* skip '\\0' */"
    ],
    "envz_remove(char **, int *, const char *)": [],
    "envz_merge(char **, int *, const char *, int, int)": [],
    "envz_strip(char **, int *)": [
        "/* Null entry. */"
    ],
    "explicit_bzero(void *, int)": [
        "/* Compiler barrier.  */"
    ],
    "__ffs(int)": [
        "/* Count low bits in X and store in %1.  */",
        "/* If number was zero, use -1 as result.  */"
    ],
    "ffsll(long long)": [
        "/* Count low bits in X and store in %1.  */",
        "/* If number was zero, use -1 as result.  */"
    ],
    "memcmp(const void *, const void *, int)": [
        "/* There are at least some bytes to compare.  No need to test\n\t for LEN == 0 in this alignment loop.  */",
        "/* SRCP2 is now aligned for memory operations on `op_t'.\n\t SRCP1 alignment determines if we can do a simple,\n\t aligned compare or need to shuffle bits.  */",
        "/* Number of bytes remaining in the interval [0..OPSIZ-1].  */",
        "/* There are just a few bytes to compare.  Use byte memory operations.  */"
    ],
    "memcpy(void *, const void *, int)": [
        "/* Copy from the beginning to the end.  */",
        "/* If there not too few bytes to copy, use word copy.  */",
        "/* Copy just a few bytes to make DSTP aligned.  */",
        "/* Copy whole pages from SRCP to DSTP by virtual address manipulation,\n\t as much as possible.  */",
        "/* Copy from SRCP to DSTP taking advantage of the known alignment of\n\t DSTP.  Number of bytes remaining is put in the third argument,\n\t i.e. in LEN.  This number may vary from machine to machine.  */",
        "/* Fall out and copy the tail.  */",
        "/* There are just a few bytes to copy.  Use byte memory operations.  */"
    ],
    "memfrob(void *, int)": [],
    "memmem(const void *, int, const void *, int)": [
        "/* Ensure haystack length is >= needle length.  */",
        "/* Use Two-Way algorithm for very long needles.  */",
        "/* Shift1 is the amount we can skip after matching the hash of the\n     needle end but not the full needle.  */",
        "/* Skip past character pairs not in the needle.  */",
        "/* If the match is not at the end of the needle, shift to the end\n\t and continue until we match the hash of the needle end.  */",
        "/* Hash of the last 2 characters matches.  If the needle is long,\n\t try to quickly filter out mismatches.  */",
        "/* Adjust filter offset when it doesn't find the mismatch.  */",
        "/* Skip based on matching the hash of the needle end.  */"
    ],
    "__mempcpy(void *, const void *, int)": [],
    "__rawmemchr(const void *, int)": [],
    "sigabbrev_np(int)": [],
    "__stpcpy(char *, const char *)": [
        "/* Copy just a few bytes to make DEST aligned.  */",
        "/* DEST is now aligned to op_t, SRC may or may not be.  */"
    ],
    "stpncpy(char *, const char *, int)": [],
    "strcasecmp(const char *, const char *)": [],
    "strcasecmp(const char *, const char *, locale_t)": [],
    "__strcasestr(const char *, const char *)": [
        "/* Length of NEEDLE.  */",
        "/* Known minimum length of HAYSTACK.  */",
        "/* Handle empty NEEDLE special case.  */",
        "/* Ensure HAYSTACK length is at least as long as NEEDLE length.\n     Since a match may occur early on in a huge HAYSTACK, use strnlen\n     and read ahead a few cachelines for improved performance.  */",
        "/* Perform the search.  Abstract memory is considered to be an array\n     of 'unsigned char' values, not an array of 'char' values.  See\n     ISO C 99 section 6.2.6.1.  */"
    ],
    "strcat(char *, const char *)": [],
    "strchr(const char *, int)": [],
    "strcmp(const char *, const char *)": [
        "/* Handle the unaligned bytes of p1 first.  */",
        "/* P1 is now aligned to op_t.  P2 may or may not be.  */"
    ],
    "strcoll(const char *, const char *)": [],
    "__strcoll_l(const char *, const char *, locale_t)": [
        "/* We don't assign the following values right away since it might be\n     unnecessary in case there are no rules.  */",
        "/* Catch empty strings.  */",
        "/* With GCC 7 when compiling with -Os the compiler warns that\n     seq1.back_us and seq2.back_us might be used uninitialized.\n     Sometimes this warning appears at locations in locale/weightwc.h\n     where the actual use is, but on architectures other than x86_64,\n     x86 and s390x, a warning appears at the definitions of seq1 and\n     seq2.  This uninitialized use is impossible for the same reason\n     as described in comments in locale/weightwc.h.  */",
        "/* We need the elements of the strings as unsigned values since they\n\t are used as indices.  */",
        "/* We assume that if a rule has defined `position' in one section\n\t this is true for all of them.  Please note that the localedef programs\n\t makes sure that `position' is not used at the first level.  */",
        "/* See whether any or both strings are empty.  */",
        "/* Both strings ended and are equal at this level.  Do a\n\t\t     byte-level comparison to ensure that we don't waste time\n\t\t     going through multiple passes for totally equal strings\n\t\t     before proceeding to subsequent passes.  */",
        "/* This means one string is shorter than the other.  Find out\n\t\t which one and return an appropriate value.  */"
    ],
    "strcpy(char *, const char *)": [],
    "strcspn(const char *, const char *)": [
        "/* Use multiple small memsets to enable inlining on most targets.  */"
    ],
    "strdup(const char *)": [],
    "strerror(int)": [],
    "strerrorname_np(int)": [],
    "strfry(char *)": [],
    "strncasecmp(const char *, const char *, int)": [],
    "strncasecmp(const char *, const char *, int, locale_t)": [],
    "strncat(char *, const char *, int)": [
        "/* Find the end of S1.  */"
    ],
    "strncmp(const char *, const char *, int)": [
        "/* Handle the unaligned bytes of p1 first.  */",
        "/* P1 is now aligned to op_t.  P2 may or may not be.  */"
    ],
    "strncpy(char *, const char *, int)": [],
    "strndup(const char *, int)": [],
    "strpbrk(const char *, const char *)": [],
    "strrchr(const char *, int)": [],
    "strsignal(int)": [],
    "strspn(const char *, const char *)": [
        "/* Load masks.  */",
        "/* Find where the NULL terminator is.  */",
        "/* A is aligned.  */",
        "/* Find where the NULL terminator is.  */",
        "/* There is no NULL terminator.  Don't use SSE4.2 if the length\n         of A > 16.  */",
        "/* Check partial string.  */",
        "/* No need to check CFlag since it is always 1.  */",
        "/* Find where the NULL terminator is.  */"
    ],
    "strstr(const char *, const char *)": [
        "/* Handle short needle special cases first.  */",
        "/* Ensure haystack length is at least as long as needle length.\n     Since a match may occur early on in a huge haystack, use strnlen\n     and read ahead a few cachelines for improved performance.  */",
        "/* Check whether we have a match.  This improves performance since we\n     avoid initialization overheads.  */",
        "/* Use Two-Way algorithm for very long needles.  */",
        "/* Initialize bad character shift hash table.  */",
        "/* Shift1 is the amount we can skip after matching the hash of the\n     needle end but not the full needle.  */",
        "/* Skip past character pairs not in the needle.  */",
        "/* If the match is not at the end of the needle, shift to the end\n\t and continue until we match the hash of the needle end.  */",
        "/* Hash of the last 2 characters matches.  If the needle is long,\n\t try to quickly filter out mismatches.  */",
        "/* Adjust filter offset when it doesn't find the mismatch.  */",
        "/* Skip based on matching the hash of the needle end.  */"
    ],
    "strtok(char *, const char *)": [],
    "strtok_r(char *, const char *, char **)": [
        "/* Scan leading delimiters.  */",
        "/* Find the end of the token.  */",
        "/* Terminate the token and make *SAVE_PTR point past it.  */"
    ],
    "__strverscmp(const char *, const char *)": [
        "/* Symbol(s)    0       [1-9]   others\n     Transition   (10) 0  (01) d  (00) x   */",
        "/* state    x    d    0  */",
        "/* S_N */",
        "/* S_I */",
        "/* S_F */",
        "/* S_Z */",
        "/* state   x/x  x/d  x/0  d/x  d/d  d/0  0/x  0/d  0/0  */",
        "/* S_N */",
        "/* S_I */",
        "/* S_F */",
        "/* S_Z */",
        "/* Hint: '0' is a digit too.  */"
    ],
    "strxfrm(char *, const char *, int)": [],
    "__strxfrm_l(char *, const char *, int, locale_t)": [
        "/* Handle byte comparison case.  */",
        "/* Handle an empty string, code hereafter relies on strlen (src) > 0.  */",
        "/* Get the locale data.  */",
        "/* We need the elements of the string as unsigned values since they\n     are used as indices.  */",
        "/* Allocate cache for small strings on the stack and fill it with weight and\n     rule indices.  If the cache size is not sufficient, continue with the\n     uncached xfrm version.  */",
        "/* This element is only read, the value never used but to determine\n     another value which then is ignored.  */",
        "/* Do the transformation.  */"
    ],
    "swab(const void *, void *, ssize_t)": [],
    "__xpg_strerror_r(int, char *, int)": [
        "/* Terminate the string in any case.  */"
    ],
    "authdes_create(const char *, u_int, struct sockaddr *, des_block *)": [
        "/* servername - network name of server */",
        "/* window     - time to live */",
        "/* syncaddr   - optional addr of host to sync with */",
        "/* ckey       - optional conversation key to use */"
    ],
    "authnone_create()": [],
    "authunix_create(char *, uid_t, gid_t, int, gid_t *)": [
        "/*\n   * Allocate and set up auth handle\n   */",
        "/*\n   * fill in param struct from the given params\n   */",
        "/*\n   * Serialize the parameters into origcred\n   */",
        "/*\n   * set auth handle to reflect new cred.\n   */"
    ],
    "xdr_authdes_cred(XDR *, struct authdes_cred *)": [
        "/*\n   * Unrolled xdr\n   */"
    ],
    "xdr_authunix_parms(XDR *, struct authunix_parms *)": [],
    "clnt_create(const char *, u_long, u_long, const char *)": [
        "/* This is not wanted.  This would disable the user from having\n\t a timeout in the clnt_call() call.  Only a call to cnlt_control()\n\t by the user should set the timeout value.  */",
        "/* Enlarge the buffer.  */",
        "/* This is not wanted.  This would disable the user from having\n\t a timeout in the clnt_call() call.  Only a call to cnlt_control()\n\t by the user should set the timeout value.  */",
        "/* This is not wanted.  This would disable the user from having\n\t a timeout in the clnt_call() call.  Only a call to cnlt_control()\n\t by the user should set the timeout value.  */"
    ],
    "clnt_sperror(int *, const char *)": [
        "/* unknown */"
    ],
    "clnt_sperrno(enum clnt_stat)": [],
    "clntraw_create(u_long, u_long)": [
        "/*\n   * pre-serialize the static part of the call msg and stash it away\n   */",
        "/*\n   * Set xdrmem for client/server shared buffer\n   */",
        "/*\n   * create client handle\n   */"
    ],
    "callrpc(const char *, u_long, u_long, u_long, int, const char *, int, char *)": [
        "/* reuse old client */",
        "/*\n   * if call failed, empty cache\n   */"
    ],
    "clnttcp_create(struct sockaddr_in *, u_long, u_long, int *, u_int, u_int)": [
        "/*\n   * If no port number given ask the pmap for one\n   */",
        "/*\n   * If no socket given, open one\n   */",
        "/*\n   * Set up private data struct\n   */",
        "/*\n   * Initialize call message\n   */",
        "/*\n   * pre-serialize the static part of the call msg and stash it away\n   */",
        "/*\n   * Create a client handle which uses xdrrec for serialization\n   * and authnone for authentication.\n   */",
        "/*\n   * Something goofed, free stuff and barf\n   */"
    ],
    "__libc_clntudp_bufcreate(struct sockaddr_in *, u_long, u_long, struct timeval, int *, u_int, u_int, int)": [
        "/* attempt to bind to prov port */"
    ],
    "clntunix_create(struct sockaddr_un *, u_long, u_long, int *, u_int, u_int)": [
        "/*\n   * If no socket given, open one\n   */",
        "/*\n   * Set up private data struct\n   */",
        "/*\n   * Initialize call message\n   */",
        "/*\n   * pre-serialize the static part of the call msg and stash it away\n   */",
        "/*\n   * Create a client handle which uses xdrrec for serialization\n   * and authnone for authentication.\n   */",
        "/*\n   * Something goofed, free stuff and barf\n   */"
    ],
    "cbc_crypt(char *, char *, unsigned int, unsigned int, char *)": [],
    "des_setparity(char *)": [],
    "get_myaddress(struct sockaddr_in *)": [
        "/* The function is horribly specified.  It does not return any error\n     if no interface is up.  Probably this won't happen (at least\n     loopback is there) but still...  */"
    ],
    "getrpcport(const char *, u_long, u_long, u_int)": [],
    "key_setsecret(char *)": [],
    "xdr_keystatus(int *, keystatus *)": [],
    "user2netname(char, const uid_t, const char *)": [
        "/* GCC with -Os or -O1 warns that sprint might overflow while handling\n     dfltdom, however the above test does check if an overflow would\n     happen.  */"
    ],
    "pmap_getmaps(struct sockaddr_in *)": [
        "/* Don't need a reserved port to get ports from the portmapper.  */",
        "/* We only need to close the socket here if we opened  it.  */"
    ],
    "__libc_rpc_getport(struct sockaddr_in *, u_long, u_long, u_int, time_t, time_t)": [
        "/* Don't need a reserved port to get ports from the portmapper.  */",
        "/* not needed or used */",
        "/* We only need to close the socket here if we opened  it.  */"
    ],
    "pmap_set(u_long, u_long, int, u_short)": [
        "/* (void)close(socket); CLNT_DESTROY closes it */"
    ],
    "xdr_pmap(XDR *, struct pmap *)": [],
    "xdr_pmaplist(XDR *, struct pmaplist **)": [
        "/*\n   * more_elements is pre-computed in case the direction is\n   * XDR_ENCODE or XDR_FREE.  more_elements is overwritten by\n   * xdr_bool when the direction is XDR_DECODE.\n   */",
        "/* we are done */",
        "/*\n       * the unfortunate side effect of non-recursion is that in\n       * the case of freeing we must remember the next object\n       * before we free the current object ...\n       */"
    ],
    "pmap_rmtcall(struct sockaddr_in *, u_long, u_long, u_long, int, caddr_t, int, caddr_t, struct timeval, u_long *)": [
        "/* (void)__close(socket); CLNT_DESTROY already closed it */"
    ],
    "clnt_broadcast(u_long, u_long, u_long, int, caddr_t, int, caddr_t, int)": [
        "/* program number */",
        "/* version number */",
        "/* procedure number */",
        "/* xdr routine for args */",
        "/* pointer to args */",
        "/* xdr routine for results */",
        "/* pointer to results */",
        "/* call with each result obtained */",
        "/* broadcast and response addresses */",
        "/*\n   * initialization: create a socket, a broadcast address, and\n   * preserialize the arguments into a send buffer.\n   */",
        "/* def SO_BROADCAST */",
        "/*      baddr.sin_addr.S_un.S_addr = htonl(INADDR_ANY); */",
        "/*\n   * Basic loop: broadcast a packet and wait a while for response(s).\n   * The response timeout grows larger per iteration.\n   */",
        "/* timed out */",
        "/* some kind of error */",
        "/* end of poll results switch */",
        "/*\n       * see if reply transaction id matches sent id.\n       * If so, decode the results.\n       */",
        "/* otherwise, we just ignore the errors ... */",
        "/* some kind of deserialization problem ... */",
        "/* otherwise, just random garbage */"
    ],
    "getpublickey(const char *, char *)": [],
    "xdr_callmsg(int *, struct rpc_msg *)": [
        "/* no real need....\n\t\t buf = (long *) ((char *) buf + RNDUP(oa->oa_length));\n\t       */",
        "/* no real need....\n\t\t     buf = (long *) ((char *) buf\n\t\t     + RNDUP(oa->oa_length));\n\t\t   */",
        "/* no real need...\n\t\t     buf = (long *) ((char *) buf\n\t\t     + RNDUP(oa->oa_length));\n\t\t   */"
    ],
    "_rpc_dtablesize()": [],
    "xdr_opaque_auth(int *, struct opaque_auth *)": [],
    "xdr_replymsg(int *, struct rpc_msg *)": [],
    "__rpc_thread_svc_fdset()": [],
    "rtime(struct sockaddr_in *, struct rpc_timeval *, struct rpc_timeval *)": [
        "/* RFC 868 says the time is transmitted as a 32-bit value.  */"
    ],
    "xprt_register(SVCXPRT *)": [
        "/* Don't add handle */",
        "/* Check if we have an empty slot */",
        "/* Out of memory */"
    ],
    "svc_register(SVCXPRT *, int, int, void (*)(struct svc_req *, SVCXPRT *), int)": [
        "/* he is registering another xptr */",
        "/* now register the information with the local binder service */"
    ],
    "_authenticate(struct svc_req *, struct rpc_msg *)": [],
    "svcraw_create()": [],
    "svc_exit()": [],
    "svctcp_create(int, u_int, u_int)": [],
    "svcudp_bufcreate(int, u_int, u_int)": [
        "/* Set the padding to all 1s. */",
        "/* Clear the padding. */"
    ],
    "svcudp_enablecache(int *, u_long)": [],
    "svcunix_create(int, u_int, u_int, char *)": [],
    "authdes_getucred(const struct authdes_cred *, uid_t *, gid_t *, short *, gid_t *)": [
        "/*\n       * not in cache: lookup\n       */",
        "/* mark as lookup up, but not found */",
        "/* We already have an allocated data structure.  But it is\n\t     too small.  */",
        "/* We should allocate room for at least NGROUPS groups.  */",
        "/* Make sure no too large values are reported.  */",
        "/*\n       * Already lookup up, but no match found\n       */",
        "/*\n   * cached credentials\n   */",
        "/* Another stupidity in the interface: *grouplen is of type short.\n     So we might have to cut the information passed up short.  */"
    ],
    "passwd2des(char *, char *)": [],
    "xencrypt(char *, char *)": [],
    "xdr_free(xdrproc_t, char *)": [],
    "xdr_array(XDR *, caddr_t *, u_int *, u_int, u_int, xdrproc_t)": [
        "/* array pointer */",
        "/* number of elements */",
        "/* max numberof elements */",
        "/* size in bytes of each element */",
        "/* xdr routine to handle each element */",
        "/* the actual element count */",
        "/* like strings, arrays are really counted arrays */",
        "/*\n   * XXX: Let the overflow possibly happen with XDR_FREE because mem_free()\n   * doesn't actually use its second argument anyway.\n   */",
        "/*\n   * if we are deserializing, we may need to allocate an array.\n   * We also save time by checking for a null array if we are freeing.\n   */",
        "/*\n   * now we xdr each element of array\n   */",
        "/*\n   * the array may need freeing\n   */"
    ],
    "xdr_float(XDR *, float *)": [],
    "xdr_int64_t(XDR *, int64_t *)": [
        "/* Avoid sign extension.  */"
    ],
    "xdrmem_create(int *, const caddr_t, u_int, enum xdr_op)": [
        "/* We have to add the const since the `struct xdr_ops' in `struct XDR'\n     is not `const'.  */"
    ],
    "xdrrec_create(int *, u_int, u_int, caddr_t, int (*)(char *, char *, int), int (*)(char *, char *, int))": [
        "/*\n       *  This is bad.  Should rework xdrrec_create to\n       *  return a handle, and in this case return NULL\n       */",
        "/*\n   * adjust sizes and allocate buffer quad byte aligned\n   */",
        "/*\n   * now the rest ...\n   */",
        "/* We have to add the cast since the `struct xdr_ops' in `struct XDR'\n     is not `const'.  */"
    ],
    "xdrrec_skiprecord(int *)": [],
    "xdr_reference(XDR *, caddr_t *, u_int, xdrproc_t)": [
        "/* the pointer to work on */",
        "/* size of the object pointed to */",
        "/* xdr routine to handle the object */"
    ],
    "xdr_sizeof(xdrproc_t, void *)": [
        "/* to stop ANSI-C compiler from complaining */",
        "/* the other harmless ones */"
    ],
    "xdrstdio_create(XDR *, FILE *, enum xdr_op)": [
        "/* We have to add the const since the `struct xdr_ops' in `struct XDR'\n     is not `const'.  */"
    ],
    "feclearexcept(int)": [
        "/* Mask out unsupported bits/exceptions.  */",
        "/* Bah, we have to clear selected exceptions.  Since there is no\n     `fldsw' instruction we have to do it the hard way.  */",
        "/* Clear the relevant bits.  */",
        "/* Put the new data in effect.  */",
        "/* And the same procedure for SSE.  */",
        "/* Clear the relevant bits.  */",
        "/* And put them into effect.  */",
        "/* Success.  */"
    ],
    "fegetexceptflag(fexcept_t *, int)": [
        "/* Get the current exceptions for the x87 FPU and SSE unit.  */",
        "/* Success.  */"
    ],
    "fesetexceptflag(const fexcept_t *, int)": [
        "/* The flags can be set in the 387 unit or in the SSE unit.\n     When we need to clear a flag, we need to do so in both units,\n     due to the way fetestexcept() is implemented.\n     When we need to set a flag, it is sufficient to do it in the SSE unit,\n     because that is guaranteed to not trap.  */",
        "/* Get the current x87 FPU environment.  We have to do this since we\n     cannot separately set the status word.  */",
        "/* Clear relevant flags.  */",
        "/* Store the new status word (along with the rest of the environment).  */",
        "/* And now similarly for SSE.  */",
        "/* Clear or set relevant flags.  */",
        "/* Put the new data in effect.  */",
        "/* Success.  */"
    ],
    "__isnan(double)": [],
    "__libc_unwind_link_get()": [
        "/* Return something that is not a null pointer, so that error checks\n     succeed.  */"
    ],
    "link()": [],
    "__signbit(double)": [],
    "pthread_attr_getguardsize(const pthread_attr_t *, int *)": [],
    "pthread_attr_setguardsize(pthread_attr_t *, int)": [],
    "pthread_barrier_destroy(pthread_barrier_t *)": [],
    "pthread_barrier_init(pthread_barrier_t *, const pthread_barrierattr_t *, unsigned int)": [
        "/* Use the default attributes.  */",
        "/* Non-default attributes.  */"
    ],
    "pthread_barrier_wait(pthread_barrier_t *)": [
        "/* Add ourselves to the list of waiters.  */"
    ],
    "pthread_barrierattr_destroy(pthread_barrierattr_t *)": [],
    "pthread_barrierattr_getpshared(const pthread_barrierattr_t *, int *)": [],
    "pthread_barrierattr_init(pthread_barrierattr_t *)": [],
    "pthread_barrierattr_setpshared(pthread_barrierattr_t *, int)": [],
    "pthread_condattr_getclock(const pthread_condattr_t *, clockid_t *)": [],
    "pthread_condattr_getpshared(const pthread_condattr_t *, int *)": [],
    "pthread_condattr_setclock(pthread_condattr_t *, clockid_t)": [
        "/* Only a few clocks are allowed.  CLOCK_REALTIME is always allowed.\n     CLOCK_MONOTONIC only if the kernel has the necessary support.  */",
        "/* Check whether the clock is available.  */",
        "/* Not available.  */"
    ],
    "pthread_condattr_setpshared(pthread_condattr_t *, int)": [],
    "pthread_getconcurrency()": [],
    "pthread_getcpuclockid(pthread_t, clockid_t *)": [],
    "__pthread_getspecific(pthread_key_t)": [],
    "__pthread_once(pthread_once_t *, void (*)(void))": [],
    "__pthread_rwlock_rdlock(struct __pthread_rwlock *)": [],
    "pthread_rwlock_tryrdlock(struct __pthread_rwlock *)": [
        "/* Successfully acquired the lock.  */",
        "/* Lock is held, but is held by a reader?  */",
        "/* The lock is busy.  */"
    ],
    "pthread_rwlock_trywrlock(struct __pthread_rwlock *)": [
        "/* Successfully acquired the lock.  */",
        "/* The lock is busy.  */"
    ],
    "__pthread_rwlock_unlock(pthread_rwlock_t *)": [
        "/* There are other readers.  */",
        "/* Last reader.  */",
        "/* Wake someone else up.  Try the writer queue first, then the\n     reader queue if that is empty.  */",
        "/* We do not unlock RWLOCK->held: we are transferring the ownership\n         to the thread that we are waking up.  */",
        "/* No one is waiting.  Just unlock it.  */"
    ],
    "__pthread_rwlock_wrlock(struct __pthread_rwlock *)": [],
    "pthread_rwlockattr_destroy(pthread_rwlockattr_t *)": [],
    "pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *, int *)": [],
    "pthread_rwlockattr_init(pthread_rwlockattr_t *)": [],
    "pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int)": [],
    "pthread_setconcurrency(int)": [],
    "pthread_setschedprio(pthread_t, int)": [],
    "__pthread_setspecific(pthread_key_t, const void *)": [
        "/* Amortize reallocation cost.  */"
    ],
    "init_module()": [],
    "strlen(const char *)": [
        "/* Search forward.  */",
        "/* Some old versions of gas need `repne' instead of `repnz'.  */",
        "/* Look for a zero byte.  */",
        "/* %0, %1, %3 */"
    ],
    "__isinfl(long double)": [],
    "__finite(double)": [],
    "__fpclassify(double)": [],
    "__isinf(double)": [],
    "__issignaling(double)": [],
    "__finitef128(int)": [],
    "__fpclassifyf128(int)": [],
    "__isinff128(int)": [],
    "__isnanf128(int)": [],
    "__issignalingf128(int)": [
        "/* We only have to care about the high-order bit of x's significand, because\n     having it set (sNaN) already makes the significand different from that\n     used to designate infinity.  */",
        "/* To keep the following comparison simple, toggle the quiet/signaling bit,\n     so that it is set for sNaNs.  This is inverse to IEEE 754-2008 (as well as\n     common practice for IEEE 754-1985).  */",
        "/* If lxi != 0, then set any suitable bit of the significand in hxi.  */",
        "/* We have to compare for greater (instead of greater or equal), because x's\n     significand being all-zero designates infinity not NaN.  */"
    ],
    "__signbitf128(int)": [],
    "__finitef(float)": [],
    "__fpclassifyf(float)": [],
    "__isinff(float)": [],
    "__isnanf(float)": [],
    "__issignalingf(float)": [],
    "__signbitf(float)": [],
    "__finitel(int)": [],
    "__fpclassifyl(int)": [],
    "__isinfl(int)": [],
    "__isnanl(int)": [],
    "__issignalingl(int)": [
        "/* We only have to care about the high-order bit of x's significand, because\n     having it set (sNaN) already makes the significand different from that\n     used to designate infinity.  */",
        "/* To keep the following comparison simple, toggle the quiet/signaling bit,\n     so that it is set for sNaNs.  This is inverse to IEEE 754-2008 (as well as\n     common practice for IEEE 754-1985).  */",
        "/* If lxi != 0, then set any suitable bit of the significand in hxi.  */",
        "/* We have to compare for greater (instead of greater or equal), because x's\n     significand being all-zero designates infinity not NaN.  */"
    ],
    "__signbitl(int)": [],
    "__iscanonicall(long double)": [
        "/* Intel variant: the high mantissa bit should have a value\n       determined by the exponent.  */",
        "/* M68K variant: both values of the high bit are valid for the\n       greatest and smallest exponents, while other exponents require\n       the high bit to be set.  */"
    ],
    "__issignalingl(long double)": [
        "/* By default we do not recognize a pseudo NaN as sNaN.  However on 80387 and\n     later all pseudo numbers including pseudo NaNs result in a signal and are\n     hence recognized as signaling.  */",
        "/* To keep the following comparison simple, toggle the quiet/signaling bit,\n     so that it is set for sNaNs.  This is inverse to IEEE 754-2008 (as well as\n     common practice for IEEE 754-1985).  */",
        "/* If lxi != 0, then set any suitable bit of the significand in hxi.  */",
        "/* We have to compare for greater (instead of greater or equal), because x's\n     significand being all-zero designates infinity not NaN.  */"
    ],
    "__signbitl(long double)": [],
    "__asprintf(char **, const char *, ...)": [],
    "__asprintf_chk(char **, int, const char *, ...)": [],
    "dprintf(int, const char *, ...)": [],
    "fprintf(FILE *, const char *, ...)": [],
    "qecvt(double, int, int *restrict, int *restrict)": [],
    "qfcvt(double, int, int *restrict, int *restrict)": [],
    "qgcvt(double, int, char *)": [],
    "vsyslog(int, const char *, va_list)": [],
    "__finitel(long double)": [],
    "__fpclassifyl(long double)": [
        "/* Pseudo-normals, i.e. pseudo-zero, pseudo-infinity and un-normals.  They\n     behave like NaNs, so categorize them as such.  */"
    ],
    "__isnanl(long double)": [
        "/* Detect pseudo-normal numbers, i.e. exponent is non-zero and the top\n\t   bit of the significand is not set.   */",
        "/* Clear the significand bit when computing mantissa.  */"
    ],
    "__clock_gettime(clockid_t, struct timespec *)": [],
    "clock()": [],
    "__close_nocancel(int)": [],
    "fstatvfs(int, struct statvfs *)": [
        "/* `struct statvfs' is in fact identical to `struct statfs' so we\n     can simply call fstatfs.  */"
    ],
    "fstatvfs64(int, struct statvfs64 *)": [
        "/* `struct statvfs64' is in fact identical to `struct statfs64' so\n     we can simply call fstatfs64.  */"
    ],
    "__open_nocancel(const char *, int, ...)": [],
    "__pread64_nocancel(int, void *, int, int)": [],
    "__read_nocancel(int, void *, int)": [],
    "setegid(gid_t)": [],
    "seteuid(uid_t)": [],
    "__setpgid(pid_t, pid_t)": [
        "/* Atomic fetch.  */",
        "/* Synchronize with the signal thread to make sure we have\n       received and processed proc_newids before returning to the user.  */"
    ],
    "sigpending(int *)": [],
    "__sigsuspend(const int *)": [
        "/* Crash before locking.  */",
        "/* Get a fresh port we will wait on.  */",
        "/* Change to the new blocked signal mask.  */",
        "/* Notice if any pending signals just became unblocked.  */",
        "/* Tell the signal thread to message us when a signal arrives.  */",
        "/* Tell the signal thread to check for pending signals.  */",
        "/* Wait for the signal thread's message.  */",
        "/* Restore the old mask and check for pending signals again.  */",
        "/* Tell the signal thread to check for pending signals.  */",
        "/* We've been interrupted!  And a good thing, too.\n     Otherwise we'd never return.\n     That's right; this function always returns an error.  */"
    ],
    "__sigtimedwait(const int *, int *, const struct timespec *)": [
        "/* We've already been run; don't interfere. */",
        "/* XXX */",
        "/* Make sure this is all kosher */",
        "/* Restore the blocking mask. */",
        "/* Crash before locking */",
        "/* See if one of these signals is currently pending.  */",
        "/* Huh?  Where'd it go? */",
        "/* Wait for one of them to show up.  */",
        "/* Make the preemptor */",
        "/* Install this preemptor */",
        "/* Unblock the expected signals */",
        "/* Wait.  */",
        "/* Timed out.  */",
        "/* Delete our preemptor. */"
    ],
    "statvfs(const char *, struct statvfs *)": [
        "/* `struct statvfs' is in fact identical to `struct statfs' so we\n     can simply call statfs.  */"
    ],
    "statvfs64(const char *, struct statvfs64 *)": [
        "/* `struct statvfs64' is in fact identical to `struct statfs64' so\n     we can simply call statfs64.  */"
    ],
    "__write_nocancel(int, const void *, int)": [],
    "pthread_mutex_consistent(pthread_mutex_t *)": [
        "/* The mutex is now ours, and it's consistent. */"
    ],
    "__pthread_mutex_destroy(pthread_mutex_t *)": [],
    "pthread_mutex_getprioceiling(const pthread_mutex_t *, int *)": [],
    "__pthread_mutex_init(pthread_mutex_t *, const pthread_mutexattr_t *)": [],
    "__pthread_mutex_lock(pthread_mutex_t *)": [],
    "pthread_mutex_setprioceiling(pthread_mutex_t *, int, int *)": [],
    "__pthread_mutex_trylock(pthread_mutex_t *)": [],
    "__pthread_mutex_unlock(pthread_mutex_t *)": [
        "/* Nothing to do. */",
        "/* Release the lock. If it's in an inconsistent\n\t   * state, mark it as irrecoverable. */"
    ],
    "__pthread_mutexattr_destroy(pthread_mutexattr_t *)": [],
    "pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *, int *)": [],
    "pthread_mutexattr_getprotocol(const pthread_mutexattr_t *, int *)": [],
    "pthread_mutexattr_getpshared(const pthread_mutexattr_t *, int *)": [],
    "pthread_mutexattr_getrobust(const pthread_mutexattr_t *, int *)": [],
    "pthread_mutexattr_gettype(const pthread_mutexattr_t *, int *)": [],
    "__pthread_mutexattr_init(pthread_mutexattr_t *)": [],
    "pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int)": [],
    "pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int)": [],
    "pthread_mutexattr_setpshared(pthread_mutexattr_t *, int)": [],
    "pthread_mutexattr_setrobust(pthread_mutexattr_t *, int)": [],
    "__pthread_mutexattr_settype(pthread_mutexattr_t *, int)": [],
    "ioperm(unsigned long, unsigned long, int)": [
        "/* With the device master port we get a capability that represents\n     this range of io ports.  */",
        "/* Now we add or remove that set from our task's bitmap.  */",
        "/* Old kernels don't have these RPCs.  */"
    ],
    "euidaccess(const char *, int)": [
        "/* If we are not set-uid or set-gid, access does the same.  */",
        "/* Clear any bogus bits. */",
        "/* The file exists. */",
        "/* Now we need the IDs.  */",
        "/* If we are not set-uid or set-gid, access does the same.  */",
        "/* The super-user can read and write any file, and execute any file\n     that anyone can execute. */",
        "/* XXX Add support for ACLs.  */"
    ],
    "cnd_timedwait(cnd_t *restrict, mtx_t *restrict, const struct timespec *restrict)": [],
    "mtx_timedlock(mtx_t *restrict, const struct timespec *restrict)": [],
    "thrd_equal(thrd_t, thrd_t)": [],
    "thrd_sleep(const struct timespec *, struct timespec *)": [
        "/* C11 states thrd_sleep function returns -1 if it has been interrupted\n     by a signal, or a negative value if it fails.  */"
    ],
    "tcflow(int, int)": [],
    "tcflush(int, int)": [],
    "tcgetpgrp(int)": [],
    "tcsendbreak(int, int)": [],
    "tcsetattr(int, int, const struct termios *)": [],
    "__cmsg_nxthdr(struct msghdr *, struct cmsghdr *)": [
        "/* We may safely assume that cmsg lies between mhdr->msg_control and\n     mhdr->msg_controllen because the user is required to obtain the first\n     cmsg via CMSG_FIRSTHDR, set its length, then obtain subsequent cmsgs\n     via CMSG_NXTHDR, setting lengths along the way.  However, we don't yet\n     trust the value of cmsg->cmsg_len and therefore do not use it in any\n     pointer arithmetic until we check its value.  */",
        "/* The current header is malformed, too small to be a full header.  */",
        "/* There isn't enough space between cmsg and the end of the buffer to\n  hold the current cmsg *and* the next one.  */",
        "/* Now, we trust cmsg_len and can use it to find the next header.  */"
    ],
    "openat64(int, const char *, int, ...)": [],
    "eventfd_read(int, eventfd_t *)": [],
    "eventfd_write(int, eventfd_t)": [],
    "execveat(int, const char *, char *const *, char *const *, int)": [
        "/* Avoid implicit array coercion in syscall macros.  */"
    ],
    "listen(int, int)": [],
    "mlock2(const void *, int, unsigned int)": [
        "/* Treat the missing system call as an invalid (non-zero) flag\n     argument.  */",
        "/* __ASSUME_MLOCK2 */"
    ],
    "msgget(key_t, int)": [],
    "__netlink_assert_response(int, ssize_t)": [
        "/* Check if the error is unexpected.  */",
        "/* If the address family does not match (or getsockname\n           failed), report the original error.  */",
        "/* These errors indicate that the descriptor is not a\n           connected socket.  */",
        "/* The kernel might return EAGAIN for other reasons than a\n             non-blocking socket.  But if the socket is not blocking,\n             it is not ours, so report the error.  */",
        "/* Restore original errno value.  */"
    ],
    "__open64_nocancel(const char *, int, ...)": [],
    "pidfd_getpid(int)": [
        "/* The fdinfo contains an invalid 'Pid:' value.  */",
        "/* The FD does not have a 'Pid:' entry associated.  */",
        "/* The pidfd cannot be resolved because it is in a separate pid\n     namespace.  */",
        "/* A negative value means the process is terminated.  */"
    ],
    "pidfd_spawn(int *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const *, char *const *)": [],
    "pidfd_spawnp(int *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const *, char *const *)": [],
    "pkey_get(int)": [],
    "pkey_mprotect(void *, int, int, int)": [
        "/* If the key is -1, the system call is precisely equivalent to\n       mprotect.  */"
    ],
    "pkey_set(int, unsigned int)": [],
    "process_vm_readv(pid_t, const struct iovec *, unsigned long, const struct iovec *, unsigned long, unsigned long)": [],
    "process_vm_writev(pid_t, const struct iovec *, unsigned long, const struct iovec *, unsigned long, unsigned long)": [],
    "sched_getcpu()": [],
    "semget(key_t, int, int)": [],
    "semop(int, struct sembuf *, int)": [],
    "shmat(int, const void *, int)": [],
    "shmdt(const void *)": [],
    "shmget(key_t, int, int)": [],
    "signalfd(int, const sigset_t *, int)": [],
    "__sigismember(const sigset_t *, int)": [],
    "__sigaddset(sigset_t *, int)": [],
    "__sigdelset(sigset_t *, int)": [],
    "posix_spawnattr_getcgroup_np(const posix_spawnattr_t *, int *)": [],
    "posix_spawnattr_setcgroup_np(posix_spawnattr_t *, int)": [],
    "cfgetospeed(const struct termios *)": [],
    "cfgetispeed(const struct termios *)": [],
    "cfsetospeed(struct termios *, speed_t)": [],
    "__fxstat64(int, int, struct stat64 *)": [],
    "__fxstatat64(int, int, const char *, struct stat64 *, int)": [],
    "__lxstat64(int, const char *, struct stat64 *)": [],
    "__xstat64(int, const char *, struct stat64 *)": [],
    "__fxstat(int, int, struct stat *)": [],
    "__lxstat(int, const char *, struct stat *)": [],
    "__xstat(int, const char *, struct stat *)": [],
    "__fxstatat(int, int, const char *, struct stat *, int)": [],
    "__lseek(int, off_t, int)": [],
    "__clone(int (*)(void *), void *, int, void *, ...)": [
        "/* pid_t *ptid, struct user_desc *tls, pid_t *ctid */",
        "/* Sanity check the arguments */"
    ],
    "syscall(long, long, long, long, long, long, long, long)": [],
    "__arch_prctl(int, uintptr_t *)": [
        "/* Check for a large value that overflows.  */"
    ],
    "__x86_get_cpuid_feature_leaf(unsigned int)": [],
    "ftok(const char *, int)": [],
    "msgctl(int, int, struct msqid_ds *)": [],
    "msgrcv(int, void *, int, long, int)": [],
    "msgsnd(int, const void *, int, int)": [],
    "semctl(int, int, int, ...)": [],
    "shmctl(int, int, struct shmid_ds *)": [],
    "cfmakeraw(struct termios *)": [
        "/* read returns when one char is available.  */"
    ],
    "cfsetspeed(struct termios *, speed_t)": [],
    "tcgetsid(int)": [],
    "dysize(int)": [],
    "ftime(struct timeb *)": [],
    "strftime(char *, int, const char *, const struct tm *)": [
        "/* Solaris 2.5 tzset sometimes modifies the storage returned by localtime.\n     Work around this bug by copying *tp before it might be munged.  */"
    ],
    "strptime(const char *, const char *, struct tm *)": [],
    "time(time_t *)": [],
    "timegm(struct tm *)": [],
    "timespec_get(struct timespec *, int)": [],
    "timespec_getres(struct timespec *, int)": [],
    "wcsftime(int *, int, const int *, const struct tm *)": [
        "/* Solaris 2.5 tzset sometimes modifies the storage returned by localtime.\n     Work around this bug by copying *tp before it might be munged.  */"
    ],
    "error(const char *const, ...)": [],
    "c16rtomb(char *, char16_t, mbstate_t *)": [
        "/* Reset any state relating to surrogate pairs.  */",
        "/* The previous call passed in the first surrogate of a\n\t surrogate pair.  */",
        "/* This is not a low surrogate; ensure an EILSEQ error by\n\t   trying to decode the high surrogate as a wide character on\n\t   its own.  */",
        "/* The high part of a surrogate pair.  */"
    ],
    "c32rtomb(char *, char32_t, mbstate_t *)": [],
    "c8rtomb(char *, int, mbstate_t *)": [
        "/* This implementation depends on the converter invoked by wcrtomb not\n     needing to retain state in either the top most bit of ps->__count or\n     in ps->__value between invocations.  This implementation uses the\n     top most bit of ps->__count to indicate that trailing code units are\n     expected and uses ps->__value to store previously seen code units.  */",
        "/* if 's' is a null pointer, behave as if u8'\\0' was passed as 'c8'.  If\n         this occurs for an incomplete code unit sequence, then an error will\n         be reported below.  */",
        "/* Initial state.  */",
        "/* An invalid lead code unit.  */",
        "/* A valid lead code unit.  */",
        "/* A single byte (ASCII) code unit.  */",
        "/* A single lead code unit was previously seen.  */",
        "/* An invalid second code unit.  */",
        "/* A three or four code unit sequence.  */",
        "/* A three or four byte code unit sequence.  */",
        "/* An invalid third or fourth code unit.  */",
        "/* A four code unit sequence.  */"
    ],
    "__isoc23_fwscanf(FILE *, const int *, ...)": [],
    "__isoc23_swscanf(const int *, const int *, ...)": [],
    "__isoc23_vfwscanf(FILE *, const int *, va_list)": [],
    "__isoc23_vswscanf(const int *, const int *, va_list)": [],
    "__isoc23_vwscanf(const int *, va_list)": [],
    "__isoc23_wscanf(const int *, ...)": [],
    "__isoc99_fwscanf(FILE *, const int *, ...)": [],
    "__isoc99_swscanf(const int *, const int *, ...)": [],
    "__isoc99_vfwscanf(FILE *, const int *, va_list)": [],
    "__isoc99_vswscanf(const int *, const int *, va_list)": [],
    "__isoc99_vwscanf(const int *, va_list)": [],
    "__isoc99_wscanf(const int *, ...)": [],
    "__mbrlen(const char *, int, mbstate_t *)": [],
    "mbrtoc16(char16_t *, const char *, int, mbstate_t *)": [
        "/* The standard text does not say that S being NULL means the state\n     is reset even if the second half of a surrogate still have to be\n     returned.  In fact, the error code description indicates\n     otherwise.  Therefore always first try to return a second\n     half.  */",
        "/* We have to return the second word for a surrogate.  */",
        "/* Set information for this step.  */",
        "/* A first special case is if S is NULL.  This means put PS in the\n     initial state.  */",
        "/* Tell where we want the result.  */",
        "/* Get the conversion functions.  */",
        "/* Do a normal conversion.  */",
        "/* There must not be any problems with the conversion but illegal input\n     characters.  The output buffer must be large enough, otherwise the\n     definition of MB_CUR_MAX is not correct.  All the other possible\n     errors also must not happen.  */",
        "/* The converted character is the NUL character.  */",
        "/* This is a surrogate.  */"
    ],
    "mbrtoc32(char32_t *, const char *, int, mbstate_t *)": [],
    "mbrtoc8(int *, const char *, int, mbstate_t *)": [
        "/* This implementation depends on the converter invoked by mbrtowc not\n     needing to retain state in either the top most bit of ps->__count or\n     in ps->__value between invocations.  This implementation uses the\n     top most bit of ps->__count to indicate that trailing code units are\n     yet to be written and uses ps->__value to store those code units.  */",
        "/* If state indicates that trailing code units are yet to be written, write\n     those first regardless of whether 's' is a null pointer.  */",
        "/* ps->__value.__wchb[3] stores the index of the next code unit to\n         write.  Code units are stored in reverse order.  */",
        "/* if 's' is a null pointer, behave as if a null pointer was passed for\n         'pc8', an empty string was passed for 's', and 1 passed for 'n'.  */",
        "/* mbrtowc() never returns -3.  When a MB sequence converts to multiple\n         WCs, no input is consumed when writing the subsequent WCs resulting\n         in a result of 0 even if a null character wasn't written.  */"
    ],
    "__mbrtowc(int *, const char *, int, mbstate_t *)": [
        "/* Set information for this step.  */",
        "/* A first special case is if S is NULL.  This means put PS in the\n     initial state.  */",
        "/* Tell where we want the result.  */",
        "/* Get the conversion functions.  */",
        "/* Do a normal conversion.  */",
        "/* There must not be any problems with the conversion but illegal input\n     characters.  The output buffer must be large enough, otherwise the\n     definition of MB_CUR_MAX is not correct.  All the other possible\n     errors also must not happen.  */",
        "/* The converted character is the NUL character.  */"
    ],
    "wcscasecmp(const int *, const int *)": [],
    "wcscasecmp(const int *, const int *, locale_t)": [],
    "__wcscoll_l(const int *, const int *, locale_t)": [
        "/* We don't assign the following values right away since it might be\n     unnecessary in case there are no rules.  */",
        "/* Catch empty strings.  */",
        "/* With GCC 7 when compiling with -Os the compiler warns that\n     seq1.back_us and seq2.back_us might be used uninitialized.\n     Sometimes this warning appears at locations in locale/weightwc.h\n     where the actual use is, but on architectures other than x86_64,\n     x86 and s390x, a warning appears at the definitions of seq1 and\n     seq2.  This uninitialized use is impossible for the same reason\n     as described in comments in locale/weightwc.h.  */",
        "/* We need the elements of the strings as unsigned values since they\n\t are used as indices.  */",
        "/* We assume that if a rule has defined `position' in one section\n\t this is true for all of them.  Please note that the localedef programs\n\t makes sure that `position' is not used at the first level.  */",
        "/* See whether any or both strings are empty.  */",
        "/* Both strings ended and are equal at this level.  Do a\n\t\t     byte-level comparison to ensure that we don't waste time\n\t\t     going through multiple passes for totally equal strings\n\t\t     before proceeding to subsequent passes.  */",
        "/* This means one string is shorter than the other.  Find out\n\t\t which one and return an appropriate value.  */"
    ],
    "wcscspn(const int *, const int *)": [],
    "wcsdup(const int *)": [],
    "wcsncasecmp(const int *, const int *, int)": [],
    "wcsncasecmp(const int *, const int *, int, locale_t)": [],
    "wcsncat(int *, const int *, int)": [
        "/* Find the end of dest.  */"
    ],
    "wcsncmp(const int *, const int *, int)": [],
    "wcspbrk(const int *, const int *)": [],
    "wcsrchr(const int *, const int)": [],
    "wcsspn(const int *, const int *)": [],
    "wcsstr(const int *, const int *)": [
        "/* possible ANSI violation */",
        "/* took the register-poor approach */"
    ],
    "wcstok(int *, const int *, int **)": [
        "/* Scan leading delimiters.  */",
        "/* Find the end of the token.\t */",
        "/* This token finishes the string.\t*/",
        "/* Terminate the token and make *SAVE_PTR point past it.  */"
    ],
    "wcswidth(const int *, int)": [],
    "wcsxfrm(int *, const int *, int)": [],
    "__wcsxfrm_l(int *, const int *, int, locale_t)": [
        "/* Handle byte comparison case.  */",
        "/* Handle an empty string, code hereafter relies on strlen (src) > 0.  */",
        "/* Get the locale data.  */",
        "/* We need the elements of the string as unsigned values since they\n     are used as indices.  */",
        "/* Allocate cache for small strings on the stack and fill it with weight and\n     rule indices.  If the cache size is not sufficient, continue with the\n     uncached xfrm version.  */",
        "/* This element is only read, the value never used but to determine\n     another value which then is ignored.  */",
        "/* Do the transformation.  */"
    ],
    "wctob(wint_t)": [
        "/* We know that only ASCII compatible encodings are used for the\n     locale and that the wide character encoding is ISO 10646.  */",
        "/* Tell where we want the result.  */",
        "/* Make sure we start in the initial state.  */",
        "/* Get the conversion functions.  */",
        "/* Create the input string.  */",
        "/* The conversion failed or the output is too long.  */"
    ],
    "wcwidth(int)": [],
    "__iswctype(wint_t, wctype_t)": [
        "/* If the user passes in an invalid DESC valid (the one returned from\n     `wctype' in case of an error) simply return 0.  */"
    ],
    "__iswctype_l(wint_t, wctype_t, locale_t)": [
        "/* If the user passes in an invalid DESC valid (the one returned from\n     `__wctype_l' in case of an error) simply return 0.  */"
    ],
    "__towctrans(wint_t, wctrans_t)": [
        "/* If the user passes in an invalid DESC valid (the one returned from\n     `wctrans' in case of an error) simply return the value.  */"
    ],
    "__towctrans_l(wint_t, wctrans_t, locale_t)": [
        "/* If the user passes in an invalid DESC valid (the one returned from\n     `__wctrans_l' in case of an error) simply return the value.  */"
    ],
    "__iswalnum_l(wint_t, locale_t)": [],
    "__wctrans_l(const char *, locale_t)": [],
    "__wctype_l(const char *, locale_t)": []
}
