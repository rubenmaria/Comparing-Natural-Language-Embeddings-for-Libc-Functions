{
    "argp_help(const struct argp *, FILE *, unsigned int, char *)": "void __argp_help (const struct argp *argp, FILE *stream,\n\t\t  unsigned flags, char *name)\n{\n  _help (argp, 0, stream, flags, name);\n}",
    "argp_state_help(const struct argp_state *, FILE *, unsigned int)": "void\n__argp_state_help (const struct argp_state *state, FILE *stream, unsigned flags)\n{\n  if ((!state || ! (state->flags & ARGP_NO_ERRS)) && stream)\n    {\n      if (state && (state->flags & ARGP_LONG_ONLY))\n\tflags |= ARGP_HELP_LONG_ONLY;\n\n      _help (state ? state->root_argp : 0, state, stream, flags,\n\t     state ? state->name : __argp_short_program_name ());\n\n      if (!state || ! (state->flags & ARGP_NO_EXIT))\n\t{\n\t  if (flags & ARGP_HELP_EXIT_ERR)\n\t    exit (argp_err_exit_status);\n\t  if (flags & ARGP_HELP_EXIT_OK)\n\t    exit (0);\n\t}\n  }\n}",
    "argp_error(const struct argp_state *, const char *, ...)": "void\n__argp_error (const struct argp_state *state, const char *fmt, ...)\n{\n  va_list ap;\n  va_start (ap, fmt);\n  __argp_error_internal (state, fmt, ap, 0);\n  va_end (ap);\n}",
    "argp_failure(const struct argp_state *, int, int, const char *, ...)": "void\n__argp_failure (const struct argp_state *state, int status, int errnum,\n\t\tconst char *fmt, ...)\n{\n  va_list ap;\n  va_start (ap, fmt);\n  __argp_failure_internal (state, status, errnum, fmt, ap, 0);\n  va_end (ap);\n}",
    "argp_parse(const struct argp *, int, char **, unsigned int, int *, void *)": "error_t\n__argp_parse (const struct argp *argp, int argc, char **argv, unsigned flags,\n\t      int *end_index, void *input)\n{\n  error_t err;\n  struct parser parser;\n\n  struct argp_child child[4];\n  struct argp top_argp;\n\n  /* If true, then err == EBADKEY is a result of a non-option argument failing\n     to be parsed (which in some cases isn't actually an error).  */\n  int arg_ebadkey = 0;\n\n  if (! (flags & ARGP_NO_HELP))\n    /* Add our own options.  */\n    {\n      int child_index = 0;\n\n      /* TOP_ARGP has no options, it just serves to group the user & default\n\t argps.  */\n      memset (&top_argp, 0, sizeof (struct argp));\n      top_argp.children = child;\n\n      memset (child, 0, 4 * sizeof (struct argp_child));\n\n      if (argp)\n\tchild[child_index++].argp = argp;\n      child[child_index++].argp = &argp_default_argp;\n      if (argp_program_version || argp_program_version_hook)\n\tchild[child_index++].argp = &argp_version_argp;\n      child[child_index].argp = 0;\n\n      argp = &top_argp;\n    }\n\n  /* Construct a parser for these arguments.  */\n  err = parser_init (&parser, argp, argc, argv, flags, input);\n\n  if (! err)\n    /* Parse! */\n    {\n      while (! err)\n\terr = parser_parse_next (&parser, &arg_ebadkey);\n      err = parser_finalize (&parser, err, arg_ebadkey, end_index);\n    }\n\n  return err;\n}",
    "vprintf(const char *restrict, int)": "__STDIO_INLINE int\nvprintf (const char *__restrict __fmt, __gnuc_va_list __arg)\n{\n  return vfprintf (stdout, __fmt, __arg);\n}",
    "getchar()": "int\ngetchar (void)\n{\n  int result;\n  if (!_IO_need_lock (stdin))\n    return _IO_getc_unlocked (stdin);\n  _IO_acquire_lock (stdin);\n  result = _IO_getc_unlocked (stdin);\n  _IO_release_lock (stdin);\n  return result;\n}",
    "fgetc_unlocked(FILE *)": "__STDIO_INLINE int\nfgetc_unlocked (FILE *__fp)\n{\n  return __getc_unlocked_body (__fp);\n}",
    "getc_unlocked(FILE *)": "__STDIO_INLINE int\ngetc_unlocked (FILE *__fp)\n{\n  return __getc_unlocked_body (__fp);\n}",
    "getchar_unlocked()": "int\ngetchar_unlocked (void)\n{\n  return _IO_getc_unlocked (stdin);\n}",
    "putchar(int)": "int\nputchar (int c)\n{\n  int result;\n  _IO_acquire_lock (stdout);\n  result = _IO_putc_unlocked (c, stdout);\n  _IO_release_lock (stdout);\n  return result;\n}",
    "fputc_unlocked(int, FILE *)": "int\nfputc_unlocked (int c, FILE *fp)\n{\n  CHECK_FILE (fp, EOF);\n  return _IO_putc_unlocked (c, fp);\n}",
    "putc_unlocked(int, FILE *)": "__STDIO_INLINE int\nputc_unlocked (int __c, FILE *__stream)\n{\n  return __putc_unlocked_body (__c, __stream);\n}",
    "putchar_unlocked(int)": "int\nputchar_unlocked (int c)\n{\n  CHECK_FILE (stdout, EOF);\n  return _IO_putc_unlocked (c, stdout);\n}",
    "feof_unlocked(FILE *)": "__STDIO_INLINE int\n__NTH (feof_unlocked (FILE *__stream))\n{\n  return __feof_unlocked_body (__stream);\n}",
    "ferror_unlocked(FILE *)": "__STDIO_INLINE int\n__NTH (ferror_unlocked (FILE *__stream))\n{\n  return __ferror_unlocked_body (__stream);\n}",
    "tolower(int)": "int\ntolower (int c)\n{\n  return c >= -128 && c < 256 ? __ctype_tolower[c] : c;\n}",
    "toupper(int)": "__extern_inline int\n__NTH (toupper (int __c))\n{\n  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;\n}",
    "argp_usage(const struct argp_state *)": "void\n__argp_usage (const struct argp_state *__state)\n{\n  __argp_state_help (__state, stderr, ARGP_HELP_STD_USAGE);\n}",
    "__assert(const char *, const char *, int)": "void\n__assert (const char *assertion, const char *file, int line)\n{\n  __assert_fail (assertion, file, line, (const char *) 0);\n}",
    "__assert_perror_fail(int, const char *, unsigned int, const char *)": "void\n__assert_perror_fail (int errnum,\n\t\t      const char *file, unsigned int line,\n\t\t      const char *function)\n{\n  char errbuf[1024];\n\n  char *e = __strerror_r (errnum, errbuf, sizeof errbuf);\n  __assert_fail_base (_(\"%s%s%s:%u: %s%sUnexpected error: %s.\\n%n\"),\n\t\t      e, file, line, function);\n}",
    "__assert_fail(const char *, const char *, unsigned int, const char *)": "void\n__assert_fail (const char *assertion, const char *file, unsigned int line,\n\t       const char *function)\n{\n  __assert_fail_base (_(\"%s%s%s:%u: %s%sAssertion `%s' failed.\\n%n\"),\n\t\t      assertion, file, line, function);\n}",
    "catgets(nl_catd, int, int, const char *)": "char *\ncatgets (nl_catd catalog_desc, int set, int message, const char *string)\n{\n  __nl_catd catalog;\n  size_t idx;\n  size_t cnt;\n\n  /* Be generous if catalog which failed to be open is used.  */\n  if (catalog_desc == (nl_catd) -1 || ++set <= 0 || message < 0)\n    return (char *) string;\n\n  catalog = (__nl_catd) catalog_desc;\n\n  idx = ((set * message) % catalog->plane_size) * 3;\n  cnt = 0;\n  do\n    {\n      if (catalog->name_ptr[idx + 0] == (uint32_t) set\n\t  && catalog->name_ptr[idx + 1] == (uint32_t) message)\n\treturn (char *) &catalog->strings[catalog->name_ptr[idx + 2]];\n\n      idx += catalog->plane_size * 3;\n    }\n  while (++cnt < catalog->plane_depth);\n\n  __set_errno (ENOMSG);\n  return (char *) string;\n}",
    "catclose(nl_catd)": "int\ncatclose (nl_catd catalog_desc)\n{\n  __nl_catd catalog;\n\n  /* Be generous if catalog which failed to be open is used.  */\n  if (catalog_desc == (nl_catd) -1)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  catalog = (__nl_catd) catalog_desc;\n\n#ifdef _POSIX_MAPPED_FILES\n  if (catalog->status == mmapped)\n    __munmap ((void *) catalog->file_ptr, catalog->file_size);\n  else\n#endif\t/* _POSIX_MAPPED_FILES */\n    if (catalog->status == malloced)\n      free ((void *) catalog->file_ptr);\n    else\n      {\n\t__set_errno (EBADF);\n\treturn -1;\n      }\n\n  free ((void *) catalog);\n\n  return 0;\n}",
    "__errno_location()": "int *\n__errno_location (void)\n{\n  return &errno;\n}",
    "__gmon_start__()": "static\n#else\n/* We cannot use the normal constructor mechanism to call\n   __gmon_start__ because gcrt1.o appears before crtbegin.o in the link.\n   Instead crti.o calls it specially.  */\nextern void __gmon_start__ (void);\n#endif\n\nvoid\n__gmon_start__ (void)\n{\n  /* Protect from being called more than once.  Since crti.o is linked\n     into every shared library, each of their init functions will call us.  */\n  static int called;\n\n  if (called)\n    return;\n\n  called = 1;\n\n  /* Start keeping profiling records.  */\n  __monstartup ((u_long) &__executable_start, (u_long) &etext);\n\n  /* Call _mcleanup before exiting; it will write out gmon.out from the\n     collected data.  */\n  atexit (&_mcleanup);\n}",
    "__libc_init_first(int, char **, char **)": "void\n__libc_init_first (int argc, char **argv, char **envp)\n{\n#ifdef SHARED\n  /* For DSOs we do not need __libc_init_first but an ELF constructor.  */\n}\n\nstatic void __attribute__ ((constructor))\n_init_first (int argc, char **argv, char **envp)\n{\n#endif\n\n  /* Make sure we don't initialize twice.  */\n#ifdef SHARED\n  if (__libc_initial)\n    {\n      /* Set the FPU control word to the proper default value if the\n\t kernel would use a different value.  */\n      if (__fpu_control != GLRO(dl_fpu_control))\n\t__setfpucw (__fpu_control);\n    }\n#endif\n\n  /* Save the command-line arguments.  */\n  __libc_argc = argc;\n  __libc_argv = argv;\n  __environ = envp;\n\n#ifndef SHARED\n  /* First the initialization which normally would be done by the\n     dynamic linker.  */\n  _dl_non_dynamic_init ();\n#endif\n\n  __init_misc (argc, argv, envp);\n}",
    "isblank(int)": "int\nisblank (int c)\n{\n  return __isctype (c, _ISblank);\n}",
    "__isblank_l(int, locale_t)": "int\n__isblank_l (int c, locale_t l)\n{\n  return __isctype_l (c, _ISblank, l);\n}",
    "_tolower(int)": "int\n_tolower (int c)\n{\n  return __ctype_tolower[c];\n}",
    "_toupper(int)": "int\n_toupper (int c)\n{\n  return __ctype_toupper[c];\n}",
    "toascii(int)": "int\ntoascii (int c)\n{\n  return __toascii (c);\n}",
    "isalnum(int)": "func (isalnum, _ISalnum)",
    "isalpha(int)": "func (isalpha, _ISalpha)",
    "iscntrl(int)": "func (iscntrl, _IScntrl)",
    "isdigit(int)": "func (isdigit, _ISdigit)",
    "islower(int)": "func (islower, _ISlower)",
    "isgraph(int)": "func (isgraph, _ISgraph)",
    "isprint(int)": "func (isprint, _ISprint)",
    "ispunct(int)": "func (ispunct, _ISpunct)",
    "isspace(int)": "func (isspace, _ISspace)",
    "isupper(int)": "func (isupper, _ISupper)",
    "isxdigit(int)": "func (isxdigit, _ISxdigit)",
    "__isalnum_l(int, locale_t)": "func (isalnum_l, _ISalnum)",
    "__isctype(int, int)": "int\n__isctype (int ch, int mask)\n{\n  return (((uint16_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_CLASS) + 128)\n\t  [(int) (ch)] & mask);\n}",
    "__backtrace(void **, int)": "int\n__backtrace (void **array, int size)\n{\n  int count;\n  struct trace_arg arg =\n    {\n     .array = array,\n     .unwind_link = __libc_unwind_link_get (),\n     .size = size,\n     .cnt = -1,\n    };\n\n  if (size <= 0)\n    return 0;\n\n  if (arg.unwind_link == NULL)\n    {\n      struct layout *current;\n      unsigned long fp, i7;\n\n      asm volatile (\"mov %%fp, %0\" : \"=r\"(fp));\n      asm volatile (\"mov %%i7, %0\" : \"=r\"(i7));\n      current = (struct layout *) (fp + BACKTRACE_STACK_BIAS);\n\n      array[0] = (void *) i7;\n\n      if (size == 1)\n\treturn 1;\n\n      backtrace_flush_register_windows();\n      for (count = 1; count < size; count++)\n\t{\n\t  array[count] = current->return_address;\n\t  if (!current->next)\n\t    break;\n\t  current = (struct layout *) (current->next + BACKTRACE_STACK_BIAS);\n\t}\n    }\n  else\n    {\n      UNWIND_LINK_PTR (arg.unwind_link, _Unwind_Backtrace)\n\t(backtrace_helper, &arg);\n\n      /* _Unwind_Backtrace seems to put NULL address above\n\t _start.  Fix it up here.  */\n      if (arg.cnt > 1 && arg.array[arg.cnt - 1] == NULL)\n\t--arg.cnt;\n      count = arg.cnt != -1 ? arg.cnt : 0;\n    }\n  return count;\n}",
    "__backtrace_symbols(void *const *, int)": "char **\n__backtrace_symbols (void *const *array, int size)\n{\n  Dl_info info[size];\n  int status[size];\n  int cnt;\n  size_t total = 0;\n  char **result;\n\n  /* Fill in the information we can get from `dladdr'.  */\n  for (cnt = 0; cnt < size; ++cnt)\n    {\n      struct link_map *map;\n      status[cnt] = _dl_addr (array[cnt], &info[cnt], &map, NULL);\n      if (status[cnt] && info[cnt].dli_fname && info[cnt].dli_fname[0] != '\\0')\n\t{\n\t  /* We have some info, compute the length of the string which will be\n\t     \"<file-name>(<sym-name>+offset) [address].  */\n\t  total += (strlen (info[cnt].dli_fname ?: \"\")\n\t\t    + strlen (info[cnt].dli_sname ?: \"\")\n\t\t    + 3 + WORD_WIDTH + 3 + WORD_WIDTH + 5);\n\n\t  /* The load bias is more useful to the user than the load\n\t     address.  The use of these addresses is to calculate an\n\t     address in the ELF file, so its prelinked bias is not\n\t     something we want to subtract out.  */\n\t  info[cnt].dli_fbase = (void *) map->l_addr;\n\t}\n      else\n\ttotal += 5 + WORD_WIDTH;\n    }\n\n  /* Allocate memory for the result.  */\n  result = (char **) malloc (size * sizeof (char *) + total);\n  if (result != NULL)\n    {\n      char *last = (char *) (result + size);\n\n      for (cnt = 0; cnt < size; ++cnt)\n\t{\n\t  result[cnt] = last;\n\n\t  if (status[cnt]\n\t      && info[cnt].dli_fname != NULL && info[cnt].dli_fname[0] != '\\0')\n\t    {\n\t      if (info[cnt].dli_sname == NULL)\n\t\t/* We found no symbol name to use, so describe it as\n\t\t   relative to the file.  */\n\t\tinfo[cnt].dli_saddr = info[cnt].dli_fbase;\n\n\t      if (info[cnt].dli_sname == NULL && info[cnt].dli_saddr == 0)\n\t\tlast += 1 + sprintf (last, \"%s(%s) [%p]\",\n\t\t\t\t     info[cnt].dli_fname ?: \"\",\n\t\t\t\t     info[cnt].dli_sname ?: \"\",\n\t\t\t\t     array[cnt]);\n\t      else\n\t\t{\n\t\t  char sign;\n\t\t  ptrdiff_t offset;\n\t\t  if (array[cnt] >= (void *) info[cnt].dli_saddr)\n\t\t    {\n\t\t      sign = '+';\n\t\t      offset = array[cnt] - info[cnt].dli_saddr;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      sign = '-';\n\t\t      offset = info[cnt].dli_saddr - array[cnt];\n\t\t    }\n\n\t\t  last += 1 + sprintf (last, \"%s(%s%c%#tx) [%p]\",\n\t\t\t\t       info[cnt].dli_fname ?: \"\",\n\t\t\t\t       info[cnt].dli_sname ?: \"\",\n\t\t\t\t       sign, offset, array[cnt]);\n\t\t}\n\t    }\n\t  else\n\t    last += 1 + sprintf (last, \"[%p]\", array[cnt]);\n\t}\n      assert (last <= (char *) result + size * sizeof (char *) + total);\n    }\n\n  return result;\n}",
    "__backtrace_symbols_fd(void *const *, int, int)": "void\n__backtrace_symbols_fd (void *const *array, int size, int fd)\n{\n  struct iovec iov[9];\n  int cnt;\n\n  for (cnt = 0; cnt < size; ++cnt)\n    {\n      char buf[WORD_WIDTH];\n      char buf2[WORD_WIDTH];\n      Dl_info info;\n      struct link_map *map;\n      size_t last = 0;\n\n      if (_dl_addr (array[cnt], &info, &map, NULL)\n\t  && info.dli_fname != NULL && info.dli_fname[0] != '\\0')\n\t{\n\t  /* Name of the file.  */\n\t  iov[0].iov_base = (void *) info.dli_fname;\n\t  iov[0].iov_len = strlen (info.dli_fname);\n\t  last = 1;\n\n\t  if (info.dli_sname != NULL || map->l_addr != 0)\n\t    {\n\t      size_t diff;\n\n\t      iov[last].iov_base = (void *) \"(\";\n\t      iov[last].iov_len = 1;\n\t      ++last;\n\n\t      if (info.dli_sname != NULL)\n\t\t{\n\t\t  /* We have a symbol name.  */\n\t\t  iov[last].iov_base = (void *) info.dli_sname;\n\t\t  iov[last].iov_len = strlen (info.dli_sname);\n\t\t  ++last;\n\t\t}\n\t      else\n\t\t/* We have no symbol, so describe it as relative to the file.\n\t\t   The load bias is more useful to the user than the load\n\t\t   address.  The use of these addresses is to calculate an\n\t\t   address in the ELF file, so its prelinked bias is not\n\t\t   something we want to subtract out.  */\n\t\tinfo.dli_saddr = (void *) map->l_addr;\n\n\t      if (array[cnt] >= (void *) info.dli_saddr)\n\t\t{\n\t\t  iov[last].iov_base = (void *) \"+0x\";\n\t\t  diff = array[cnt] - info.dli_saddr;\n\t\t}\n\t      else\n\t\t{\n\t\t  iov[last].iov_base = (void *) \"-0x\";\n\t\t  diff = info.dli_saddr - array[cnt];\n\t\t}\n\t      iov[last].iov_len = 3;\n\t      ++last;\n\n\t      iov[last].iov_base = _itoa_word ((unsigned long int) diff,\n\t\t\t\t\t       &buf2[WORD_WIDTH], 16, 0);\n\t      iov[last].iov_len = (&buf2[WORD_WIDTH]\n\t\t\t\t   - (char *) iov[last].iov_base);\n\t      ++last;\n\n\t      iov[last].iov_base = (void *) \")\";\n\t      iov[last].iov_len = 1;\n\t      ++last;\n\t    }\n\t}\n\n      iov[last].iov_base = (void *) \"[0x\";\n      iov[last].iov_len = 3;\n      ++last;\n\n      iov[last].iov_base = _itoa_word ((unsigned long int) array[cnt],\n\t\t\t\t       &buf[WORD_WIDTH], 16, 0);\n      iov[last].iov_len = &buf[WORD_WIDTH] - (char *) iov[last].iov_base;\n      ++last;\n\n      iov[last].iov_base = (void *) \"]\\n\";\n      iov[last].iov_len = 2;\n      ++last;\n\n      __writev (fd, iov, last);\n    }\n}",
    "__chk_fail()": "void\n__attribute__ ((noreturn))\n__chk_fail (void)\n{\n  __fortify_fail (\"buffer overflow detected\");\n}",
    "__confstr_chk(int, char *, int, int)": "size_t\n__confstr_chk (int name, char *buf, size_t len, size_t buflen)\n{\n  if (__glibc_unlikely (buflen < len))\n    __chk_fail ();\n\n  return confstr (name, buf, len);\n}",
    "__dprintf_chk(int, int, const char *, ...)": "attribute_hidden\nint\n__dprintf_chk (int d, int flag, const char *fmt, ...)\n{\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___vdprintf_chk (d, flag, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__explicit_bzero_chk(void *, int, int)": "void\n__explicit_bzero_chk (void *dst, size_t len, size_t dstlen)\n{\n  /* Inline __memset_chk to avoid a PLT reference to __memset_chk.  */\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n  memset (dst, '\\0', len);\n  /* Compiler barrier.  */\n  asm volatile (\"\" ::: \"memory\");\n}",
    "__fdelt_chk(long)": "long int\n__fdelt_chk (long int d)\n{\n  if (d < 0 || d >= FD_SETSIZE)\n    __fortify_fail (\"bit out of range 0 - FD_SETSIZE on fd_set\");\n\n  return d / __NFDBITS;\n}",
    "__fgets_chk(char *, int, int, FILE *)": "char *\n__fgets_chk (char *buf, size_t size, int n, FILE *fp)\n{\n  size_t count;\n  char *result;\n  CHECK_FILE (fp, NULL);\n  if (n <= 0)\n    return NULL;\n  _IO_acquire_lock (fp);\n  /* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */\n  int old_error = fp->_flags & _IO_ERR_SEEN;\n  fp->_flags &= ~_IO_ERR_SEEN;\n  count = _IO_getline (fp, buf, MIN ((size_t) n - 1, size), '\\n', 1);\n  /* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */\n  if (count == 0 || ((fp->_flags & _IO_ERR_SEEN) && errno != EAGAIN))\n    result = NULL;\n  else if (count >= size)\n    __chk_fail ();\n  else\n    {\n      buf[count] = '\\0';\n      result = buf;\n    }\n  fp->_flags |= old_error;\n  _IO_release_lock (fp);\n  return result;\n}",
    "__fgets_unlocked_chk(char *, int, int, FILE *)": "char *\n__fgets_unlocked_chk (char *buf, size_t size, int n, FILE *fp)\n{\n  size_t count;\n  char *result;\n  CHECK_FILE (fp, NULL);\n  if (n <= 0)\n    return NULL;\n  /* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */\n  int old_error = fp->_flags & _IO_ERR_SEEN;\n  fp->_flags &= ~_IO_ERR_SEEN;\n  count = _IO_getline (fp, buf, MIN ((size_t) n - 1, size), '\\n', 1);\n  /* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */\n  if (count == 0 || ((fp->_flags & _IO_ERR_SEEN) && errno != EAGAIN))\n    result = NULL;\n  else if (count >= size)\n    __chk_fail ();\n  else\n    {\n      buf[count] = '\\0';\n      result = buf;\n    }\n  fp->_flags |= old_error;\n  return result;\n}",
    "__fgetws_chk(int *, int, int, FILE *)": "wchar_t *\n__fgetws_chk (wchar_t *buf, size_t size, int n, FILE *fp)\n{\n  size_t count;\n  wchar_t *result;\n  int old_error;\n  CHECK_FILE (fp, NULL);\n  if (n <= 0)\n    return NULL;\n  _IO_acquire_lock (fp);\n  /* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */\n  old_error = fp->_flags & _IO_ERR_SEEN;\n  fp->_flags &= ~_IO_ERR_SEEN;\n  count = _IO_getwline (fp, buf, MIN ((size_t) n - 1, size), L'\\n', 1);\n  /* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */\n  if (count == 0 || (_IO_ferror_unlocked (fp) && errno != EAGAIN))\n    result = NULL;\n  else if (count >= size)\n    __chk_fail ();\n  else\n    {\n      buf[count] = '\\0';\n      result = buf;\n    }\n  fp->_flags |= old_error;\n  _IO_release_lock (fp);\n  return result;\n}",
    "__fgetws_unlocked_chk(int *, int, int, FILE *)": "wchar_t *\n__fgetws_unlocked_chk (wchar_t *buf, size_t size, int n, FILE *fp)\n{\n  size_t count;\n  wchar_t *result;\n  int old_error;\n  CHECK_FILE (fp, NULL);\n  if (n <= 0)\n    return NULL;\n  /* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */\n  old_error = fp->_flags & _IO_ERR_SEEN;\n  fp->_flags &= ~_IO_ERR_SEEN;\n  count = _IO_getwline (fp, buf, MIN ((size_t) n - 1, size), L'\\n', 1);\n  /* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */\n  if (count == 0 || ((fp->_flags & _IO_ERR_SEEN) && errno != EAGAIN))\n    result = NULL;\n  else if (count >= size)\n    __chk_fail ();\n  else\n    {\n      buf[count] = '\\0';\n      result = buf;\n    }\n  fp->_flags |= old_error;\n  return result;\n}",
    "__fortify_fail(const char *)": "void\n__attribute__ ((noreturn))\n__fortify_fail (const char *msg)\n{\n  __libc_message (\"*** %s ***: terminated\\n\", msg);\n}",
    "__fread_chk(void *restrict, int, int, int, FILE *restrict)": "size_t\n__fread_chk (void *__restrict ptr, size_t ptrlen,\n\t     size_t size, size_t n, FILE *__restrict stream)\n{\n  size_t bytes_requested = size * n;\n  if (__builtin_expect ((n | size)\n\t\t\t>= (((size_t) 1) << (8 * sizeof (size_t) / 2)), 0))\n    {\n      if (size != 0 && bytes_requested / size != n)\n\t__chk_fail ();\n    }\n\n  if (__glibc_unlikely (bytes_requested > ptrlen))\n    __chk_fail ();\n\n  CHECK_FILE (stream, 0);\n  if (bytes_requested == 0)\n    return 0;\n\n  size_t bytes_read;\n  _IO_acquire_lock (stream);\n  bytes_read = _IO_sgetn (stream, (char *) ptr, bytes_requested);\n  _IO_release_lock (stream);\n  return bytes_requested == bytes_read ? n : bytes_read / size;\n}",
    "__fread_unlocked_chk(void *restrict, int, int, int, FILE *restrict)": "size_t\n__fread_unlocked_chk (void *__restrict ptr, size_t ptrlen,\n\t\t      size_t size, size_t n, FILE *__restrict stream)\n{\n  size_t bytes_requested = size * n;\n  if (__builtin_expect ((n | size)\n\t\t\t>= (((size_t) 1) << (8 * sizeof (size_t) / 2)), 0))\n    {\n      if (size != 0 && bytes_requested / size != n)\n\t__chk_fail ();\n    }\n\n  if (__glibc_unlikely (bytes_requested > ptrlen))\n    __chk_fail ();\n\n  CHECK_FILE (stream, 0);\n  if (bytes_requested == 0)\n    return 0;\n\n  size_t bytes_read = _IO_sgetn (stream, (char *) ptr, bytes_requested);\n  return bytes_requested == bytes_read ? n : bytes_read / size;\n}",
    "__fwprintf_chk(int *, int, const int *, ...)": "int\n__fwprintf_chk (FILE *fp, int flag, const wchar_t *format, ...)\n{\n  /* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */\n  unsigned int mode = (flag > 0) ? PRINTF_FORTIFY : 0;\n  va_list ap;\n  int ret;\n\n  va_start (ap, format);\n  ret = __vfwprintf_internal (fp, format, ap, mode);\n  va_end (ap);\n\n  return ret;\n}",
    "__getcwd_chk(char *, int, int)": "char *\n__getcwd_chk (char *buf, size_t size, size_t buflen)\n{\n  if (size > buflen)\n    __chk_fail ();\n\n  return __getcwd (buf, size);\n}",
    "__getdomainname_chk(char *, int, int)": "int\n__getdomainname_chk (char *buf, size_t buflen, size_t nreal)\n{\n  if (buflen > nreal)\n    __chk_fail ();\n\n  return getdomainname (buf, buflen);\n}",
    "__getgroups_chk(int, __gid_t *, int)": "int\n__getgroups_chk (int size, __gid_t list[], size_t listlen)\n{\n  if (__glibc_unlikely (size < 0))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (__glibc_unlikely (size * sizeof (__gid_t) > listlen))\n    __chk_fail ();\n\n  return __getgroups (size, list);\n}",
    "__gethostname_chk(char *, int, int)": "int\n__gethostname_chk (char *buf, size_t buflen, size_t nreal)\n{\n  if (buflen > nreal)\n    __chk_fail ();\n\n  return __gethostname (buf, buflen);\n}",
    "__gets_chk(char *, int)": "char *\n__gets_chk (char *buf, size_t size)\n{\n  size_t count;\n  int ch;\n  char *retval;\n\n  if (size == 0)\n    __chk_fail ();\n\n  _IO_acquire_lock (stdin);\n  ch = _IO_getc_unlocked (stdin);\n  if (ch == EOF)\n    {\n      retval = NULL;\n      goto unlock_return;\n    }\n  if (ch == '\\n')\n    count = 0;\n  else\n    {\n      /* This is very tricky since a file descriptor may be in the\n\t non-blocking mode. The error flag doesn't mean much in this\n\t case. We return an error only when there is a new error. */\n      int old_error = stdin->_flags & _IO_ERR_SEEN;\n      stdin->_flags &= ~_IO_ERR_SEEN;\n      buf[0] = (char) ch;\n      count = _IO_getline (stdin, buf + 1, size - 1, '\\n', 0) + 1;\n      if (stdin->_flags & _IO_ERR_SEEN)\n\t{\n\t  retval = NULL;\n\t  goto unlock_return;\n\t}\n      else\n\tstdin->_flags |= old_error;\n    }\n  if (count >= size)\n    __chk_fail ();\n  buf[count] = 0;\n  retval = buf;\nunlock_return:\n  _IO_release_lock (stdin);\n  return retval;\n}",
    "__getwd_chk(char *, int)": "char *\n__getwd_chk (char *buf, size_t buflen)\n{\n  char *res = __getcwd (buf, buflen);\n  if (res == NULL && errno == ERANGE)\n    __chk_fail ();\n  return res;\n}",
    "__mbsnrtowcs_chk(int *, const char **, int, int, mbstate_t *, int)": "size_t\n__mbsnrtowcs_chk (wchar_t *dst, const char **src, size_t nmc, size_t len,\n\t\t  mbstate_t *ps, size_t dstlen)\n{\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  return __mbsnrtowcs (dst, src, nmc, len, ps);\n}",
    "__mbsrtowcs_chk(int *, const char **, int, mbstate_t *, int)": "size_t\n__mbsrtowcs_chk (wchar_t *dst, const char **src, size_t len,\n\t\t mbstate_t *ps, size_t dstlen)\n{\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  return __mbsrtowcs (dst, src, len, ps);\n}",
    "__mbstowcs_chk(int *, const char *, int, int)": "size_t\n__mbstowcs_chk (wchar_t *dst, const char *src, size_t len, size_t dstlen)\n{\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  mbstate_t state;\n\n  memset (&state, '\\0', sizeof state);\n  /* Return how many we wrote (or maybe an error).  */\n  return __mbsrtowcs (dst, &src, len, &state);\n}",
    "__memcpy_chk(void *, const void *, int, int)": "void *\n__memcpy_chk (void *dstpp, const void *srcpp, size_t len, size_t dstlen)\n{\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  return memcpy (dstpp, srcpp, len);\n}",
    "__memmove_chk(void *, const void *, int, int)": "void *\nMEMMOVE_CHK (void *dest, const void *src, size_t len, size_t destlen)\n{\n  if (__glibc_unlikely (destlen < len))\n    __chk_fail ();\n\n  return memmove (dest, src, len);\n}",
    "__mempcpy_chk(void *, const void *, int, int)": "void *\n__mempcpy_chk (void *dstpp, const void *srcpp, size_t len, size_t dstlen)\n{\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  return __mempcpy (dstpp, srcpp, len);\n}",
    "__memset_chk(void *, int, int, int)": "void *\n__memset_chk (void *dstpp, int c, size_t len, size_t dstlen)\n{\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  return memset (dstpp, c, len);\n}",
    "__cyg_profile_func_enter(void *, void *)": "void\n__cyg_profile_func_enter (void *this_fn, void *call_site)\n{\n  void *buf[2];\n\n  if (! active)\n    return;\n\n  /* Now write out the current position and that of the caller.  We do\n     this now, and don't cache the because we want real-time output.  */\n  buf[0] = this_fn;\n  buf[1] = call_site;\n\n  write (fd, buf, sizeof buf);\n}",
    "__obstack_printf_chk(struct obstack *, int, const char *, ...)": "int\n__obstack_printf_chk (struct obstack *obstack, int flag, const char *format,\n\t\t      ...)\n{\n  /* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */\n  unsigned int mode = (flag > 0) ? PRINTF_FORTIFY : 0;\n  va_list ap;\n  int ret;\n\n  va_start (ap, format);\n  ret = __obstack_vprintf_internal (obstack, format, ap, mode);\n  va_end (ap);\n\n  return ret;\n}",
    "__poll_chk(struct pollfd *, nfds_t, int, unsigned long)": "int\n__poll_chk (struct pollfd *fds, nfds_t nfds, int timeout, __SIZE_TYPE__ fdslen)\n{\n  if (fdslen / sizeof (*fds) < nfds)\n    __chk_fail ();\n\n  return __poll (fds, nfds, timeout);\n}",
    "__ppoll_chk(struct pollfd *, nfds_t, const struct timespec *, const int *, unsigned long)": "int\n__ppoll_chk (struct pollfd *fds, nfds_t nfds, const struct timespec *timeout,\n\t     const __sigset_t *ss, __SIZE_TYPE__ fdslen)\n{\n  if (fdslen / sizeof (*fds) < nfds)\n    __chk_fail ();\n\n  return ppoll (fds, nfds, timeout, ss);\n}",
    "__pread64_chk(int, void *, int, int, int)": "ssize_t\n__pread64_chk (int fd, void *buf, size_t nbytes, off64_t offset, size_t buflen)\n{\n  if (nbytes > buflen)\n    __chk_fail ();\n\n  return __libc_pread64 (fd, buf, nbytes, offset);\n}",
    "__pread_chk(int, void *, int, off_t, int)": "ssize_t\n__pread_chk (int fd, void *buf, size_t nbytes, off_t offset, size_t buflen)\n{\n  if (nbytes > buflen)\n    __chk_fail ();\n\n  return __pread (fd, buf, nbytes, offset);\n}",
    "__read_chk(int, void *, int, int)": "ssize_t\n__read_chk (int fd, void *buf, size_t nbytes, size_t buflen)\n{\n  if (nbytes > buflen)\n    __chk_fail ();\n\n  return __read (fd, buf, nbytes);\n}",
    "__readlink_chk(const char *restrict, char *restrict, int, int)": "ssize_t\n__readlink_chk (const char *__restrict path, char *__restrict buf, size_t len,\n\t\tsize_t buflen)\n{\n  if (len > buflen)\n    __chk_fail ();\n\n  return __readlink (path, buf, len);\n}",
    "__readlinkat_chk(int, const char *restrict, char *restrict, int, int)": "ssize_t\n__readlinkat_chk (int fd, const char *__restrict path,\n\t\t  char *__restrict buf, size_t len,\n\t\t  size_t buflen)\n{\n  if (len > buflen)\n    __chk_fail ();\n\n  return readlinkat (fd, path, buf, len);\n}",
    "__realpath_chk(const char *, char *, int)": "char *\n__realpath_chk (const char *buf, char *resolved, size_t resolvedlen)\n{\n#ifdef PATH_MAX\n  if (resolvedlen < PATH_MAX)\n    __chk_fail ();\n\n  return __realpath (buf, resolved);\n#else\n  long int pathmax;\n\n  if (buf == NULL)\n    {\n      __set_errno (EINVAL);\n      return NULL;\n    }\n\n  pathmax = __pathconf (buf, _PC_PATH_MAX);\n  if (pathmax != -1)\n    {\n      /* We do have a fixed limit.  */\n      if (resolvedlen < pathmax)\n\t__chk_fail ();\n\n      return __realpath (buf, resolved);\n    }\n\n  /* Since there is no fixed limit we check whether the size is large\n     enough.  */\n  char *res = __realpath (buf, NULL);\n  if (res != NULL)\n    {\n      size_t actlen = strlen (res) + 1;\n      if (actlen > resolvedlen)\n\t__chk_fail ();\n\n      memcpy (resolved, res, actlen);\n      free (res);\n      res = resolved;\n    }\n\n  return res;\n#endif\n}",
    "__recv_chk(int, void *, int, int, int)": "ssize_t\n__recv_chk (int fd, void *buf, size_t n, size_t buflen, int flags)\n{\n  if (n > buflen)\n    __chk_fail ();\n\n  return __recv (fd, buf, n, flags);\n}",
    "__recvfrom_chk(int, void *, int, int, int, struct sockaddr *restrict, socklen_t *)": "ssize_t\n__recvfrom_chk (int fd, void *buf, size_t n, size_t buflen, int flags,\n\t\t__SOCKADDR_ARG addr, socklen_t *addr_len)\n{\n  if (n > buflen)\n    __chk_fail ();\n\n  return __recvfrom (fd, buf, n, flags, addr, addr_len);\n}",
    "__stack_chk_fail()": "void\n__attribute__ ((noreturn))\n__stack_chk_fail (void)\n{\n  __fortify_fail (\"stack smashing detected\");\n}",
    "__stpcpy_chk(char *, const char *, int)": "char *\n__stpcpy_chk (char *dest, const char *src, size_t destlen)\n{\n  size_t len = strlen (src);\n  if (len >= destlen)\n    __chk_fail ();\n\n  return memcpy (dest, src, len + 1) + len;\n}",
    "__stpncpy_chk(char *, const char *, int, int)": "char *\n__stpncpy_chk (char *dest, const char *src, size_t n, size_t destlen)\n{\n  if (__builtin_expect (destlen < n, 0))\n    __chk_fail ();\n\n  return __stpncpy (dest, src, n);\n}",
    "__strcat_chk(char *, const char *, int)": "char *\n__strcat_chk (char *dest, const char *src, size_t destlen)\n{\n  char *s1 = dest;\n  const char *s2 = src;\n  char c;\n\n  /* Find the end of the string.  */\n  do\n    {\n      if (__glibc_unlikely (destlen-- == 0))\n\t__chk_fail ();\n      c = *s1++;\n    }\n  while (c != '\\0');\n\n  /* Make S1 point before the next character, so we can increment\n     it while memory is read (wins on pipelined cpus).  */\n  ++destlen;\n  s1 -= 2;\n\n  do\n    {\n      if (__glibc_unlikely (destlen-- == 0))\n\t__chk_fail ();\n      c = *s2++;\n      *++s1 = c;\n    }\n  while (c != '\\0');\n\n  return dest;\n}",
    "__strcpy_chk(char *, const char *, int)": "char *\n__strcpy_chk (char *dest, const char *src, size_t destlen)\n{\n  size_t len = strlen (src);\n  if (len >= destlen)\n    __chk_fail ();\n\n  return memcpy (dest, src, len + 1);\n}",
    "__strlcat_chk(char *restrict, const char *restrict, int, int)": "size_t\n__strlcat_chk (char *__restrict s1, const char *__restrict s2,\n\t       size_t n, size_t s1len)\n{\n  if (__glibc_unlikely (s1len < n))\n    __chk_fail ();\n\n  return __strlcat (s1, s2, n);\n}",
    "__strlcpy_chk(char *restrict, const char *restrict, int, int)": "size_t\n__strlcpy_chk (char *__restrict s1, const char *__restrict s2,\n\t       size_t n, size_t s1len)\n{\n  if (__glibc_unlikely (s1len < n))\n    __chk_fail ();\n\n  return __strlcpy (s1, s2, n);\n}",
    "__strncat_chk(char *, const char *, int, int)": "char *\n__strncat_chk (char *s1, const char *s2, size_t n, size_t s1len)\n{\n  char c;\n  char *s = s1;\n\n  /* Find the end of S1.  */\n  do\n    {\n      if (__glibc_unlikely (s1len-- == 0))\n\t__chk_fail ();\n      c = *s1++;\n    }\n  while (c != '\\0');\n\n  /* Make S1 point before next character, so we can increment\n     it while memory is read (wins on pipelined cpus).  */\n  ++s1len;\n  s1 -= 2;\n\n  if (n >= 4)\n    {\n      size_t n4 = n >> 2;\n      do\n\t{\n\t  if (__glibc_unlikely (s1len-- == 0))\n\t    __chk_fail ();\n\t  c = *s2++;\n\t  *++s1 = c;\n\t  if (c == '\\0')\n\t    return s;\n\t  if (__glibc_unlikely (s1len-- == 0))\n\t    __chk_fail ();\n\t  c = *s2++;\n\t  *++s1 = c;\n\t  if (c == '\\0')\n\t    return s;\n\t  if (__glibc_unlikely (s1len-- == 0))\n\t    __chk_fail ();\n\t  c = *s2++;\n\t  *++s1 = c;\n\t  if (c == '\\0')\n\t    return s;\n\t  if (__glibc_unlikely (s1len-- == 0))\n\t    __chk_fail ();\n\t  c = *s2++;\n\t  *++s1 = c;\n\t  if (c == '\\0')\n\t    return s;\n\t} while (--n4 > 0);\n      n &= 3;\n    }\n\n  while (n > 0)\n    {\n      if (__glibc_unlikely (s1len-- == 0))\n\t__chk_fail ();\n      c = *s2++;\n      *++s1 = c;\n      if (c == '\\0')\n\treturn s;\n      n--;\n    }\n\n  if (c != '\\0')\n    {\n      if (__glibc_unlikely (s1len-- == 0))\n\t__chk_fail ();\n      *++s1 = '\\0';\n    }\n\n  return s;\n}",
    "__strncpy_chk(char *, const char *, int, int)": "char *\n__strncpy_chk (char *s1, const char *s2, size_t n, size_t s1len)\n{\n  if (__builtin_expect (s1len < n, 0))\n    __chk_fail ();\n\n  return strncpy (s1, s2, n);\n}",
    "__swprintf_chk(int *, int, int, int, const int *, ...)": "int\n__swprintf_chk (wchar_t *s, size_t maxlen, int flag, size_t slen,\n\t\tconst wchar_t *format, ...)\n{\n  if (__glibc_unlikely (slen < maxlen))\n    __chk_fail ();\n\n  /* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */\n  unsigned int mode = (flag > 0) ? PRINTF_FORTIFY : 0;\n  va_list ap;\n  int ret;\n\n  va_start (ap, format);\n  ret = __vswprintf_internal (s, maxlen, format, ap, mode);\n  va_end (ap);\n\n  return ret;\n}",
    "__ttyname_r_chk(int, char *, int, int)": "int\n__ttyname_r_chk (int fd, char *buf, size_t buflen, size_t nreal)\n{\n  if (buflen > nreal)\n    __chk_fail ();\n\n  return __ttyname_r (fd, buf, buflen);\n}",
    "__vasprintf_chk(char **, int, const char *, int)": "int\n__vasprintf_chk (char **result_ptr, int flag, const char *format, va_list ap)\n{\n  /* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */\n  unsigned int mode = (flag > 0) ? PRINTF_FORTIFY : 0;\n\n  return __vasprintf_internal (result_ptr, format, ap, mode);\n}",
    "__vdprintf_chk(int, int, const char *, int)": "int\n__vdprintf_chk (int d, int flag, const char *format, va_list ap)\n{\n  /* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */\n  unsigned int mode = (flag > 0) ? PRINTF_FORTIFY : 0;\n\n  return __vdprintf_internal (d, format, ap, mode);\n}",
    "__vfwprintf_chk(int *, int, const int *, int)": "int\n__vfwprintf_chk (FILE *fp, int flag, const wchar_t *format, va_list ap)\n{\n  /* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */\n  unsigned int mode = (flag > 0) ? PRINTF_FORTIFY : 0;\n\n  return __vfwprintf_internal (fp, format, ap, mode);\n}",
    "__obstack_vprintf_chk(struct obstack *, int, const char *, int)": "int\n__obstack_vprintf_chk (struct obstack *obstack, int flag, const char *format,\n\t\t       va_list ap)\n{\n  /* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */\n  unsigned int mode = (flag > 0) ? PRINTF_FORTIFY : 0;\n\n  return __obstack_vprintf_internal (obstack, format, ap, mode);\n}",
    "__vswprintf_chk(int *, int, int, int, const int *, int)": "int\n__vswprintf_chk (wchar_t *s, size_t maxlen, int flag, size_t slen,\n\t\t const wchar_t *format, va_list ap)\n{\n  if (__glibc_unlikely (slen < maxlen))\n    __chk_fail ();\n\n  /* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */\n  unsigned int mode = (flag > 0) ? PRINTF_FORTIFY : 0;\n\n  return __vswprintf_internal (s, maxlen, format, ap, mode);\n}",
    "__vwprintf_chk(int, const int *, int)": "int\n__vwprintf_chk (int flag, const wchar_t *format, va_list ap)\n{\n  /* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */\n  unsigned int mode = (flag > 0) ? PRINTF_FORTIFY : 0;\n\n  return __vfwprintf_internal (stdout, format, ap, mode);\n}",
    "__wcpcpy_chk(int *, const int *, int)": "wchar_t *\n__wcpcpy_chk (wchar_t *dest, const wchar_t *src, size_t destlen)\n{\n  do\n    if (destlen-- == 0)\n      __chk_fail ();\n  while ((*dest++ = *src++));\n\n  return dest - 1;\n}",
    "__wcpncpy_chk(int *, const int *, int, int)": "wchar_t *\n__wcpncpy_chk (wchar_t *dest, const wchar_t *src, size_t n, size_t destlen)\n{\n  if (__glibc_unlikely (destlen < n))\n    __chk_fail ();\n\n  /* This function is not often enough used to justify not using a\n     tail call.  */\n  return __wcpncpy (dest, src, n);\n}",
    "__wcrtomb_chk(char *, int, mbstate_t *, int)": "size_t\n__wcrtomb_chk (char *s, wchar_t wchar, mbstate_t *ps, size_t buflen)\n{\n  return __wcrtomb_internal (s, wchar, ps, buflen);\n}",
    "__wcscat_chk(int *, const int *, int)": "wchar_t *\n__wcscat_chk (wchar_t *dest, const wchar_t *src, size_t destlen)\n{\n  wchar_t *s1 = dest;\n  const wchar_t *s2 = src;\n  wchar_t c;\n\n  /* Find the end of the string.  */\n  do\n    {\n      if (__glibc_unlikely (destlen-- == 0))\n\t__chk_fail ();\n      c = *s1++;\n    }\n  while (c != L'\\0');\n\n  /* Make S1 point before the next character, so we can increment\n     it while memory is read (wins on pipelined cpus).\t*/\n  s1 -= 2;\n  ++destlen;\n\n  do\n    {\n      if (__glibc_unlikely (destlen-- == 0))\n\t__chk_fail ();\n      c = *s2++;\n      *++s1 = c;\n    }\n  while (c != L'\\0');\n\n  return dest;\n}",
    "__wcscpy_chk(int *, const int *, int)": "wchar_t *\n__wcscpy_chk (wchar_t *dest, const wchar_t *src, size_t n)\n{\n  wint_t c;\n  wchar_t *wcp = dest;\n\n  do\n    {\n      if (__glibc_unlikely (n-- == 0))\n        __chk_fail ();\n      c = *src++;\n      *wcp++ = c;\n    }\n  while (c != L'\\0');\n\n  return dest;\n}",
    "__wcslcat_chk(int *restrict, const int *restrict, int, int)": "size_t\n__wcslcat_chk (wchar_t *__restrict s1, const wchar_t *__restrict s2,\n               size_t n, size_t s1len)\n{\n  if (__glibc_unlikely (s1len < n))\n    __chk_fail ();\n\n  return __wcslcat (s1, s2, n);\n}",
    "__wcslcpy_chk(int *restrict, const int *restrict, int, int)": "size_t\n__wcslcpy_chk (wchar_t *__restrict s1, const wchar_t *__restrict s2,\n\t       size_t n, size_t s1len)\n{\n  if (__glibc_unlikely (s1len < n))\n    __chk_fail ();\n\n  return __wcslcpy (s1, s2, n);\n}",
    "__wcsncat_chk(int *, const int *, int, int)": "wchar_t *\n__wcsncat_chk (wchar_t *dest, const wchar_t *src, size_t n, size_t destlen)\n{\n  wchar_t c;\n  wchar_t * const s = dest;\n\n  /* Find the end of DEST.  */\n  do\n    {\n      if (__glibc_unlikely (destlen-- == 0))\n\t__chk_fail ();\n      c = *dest++;\n    }\n  while (c != L'\\0');\n\n  /* Make DEST point before next character, so we can increment\n     it while memory is read (wins on pipelined cpus).\t*/\n  ++destlen;\n  dest -= 2;\n\n  if (n >= 4)\n    {\n      size_t n4 = n >> 2;\n      do\n\t{\n\t  if (__glibc_unlikely (destlen-- == 0))\n\t    __chk_fail ();\n\t  c = *src++;\n\t  *++dest = c;\n\t  if (c == L'\\0')\n\t    return s;\n\t  if (__glibc_unlikely (destlen-- == 0))\n\t    __chk_fail ();\n\t  c = *src++;\n\t  *++dest = c;\n\t  if (c == L'\\0')\n\t    return s;\n\t  if (__glibc_unlikely (destlen-- == 0))\n\t    __chk_fail ();\n\t  c = *src++;\n\t  *++dest = c;\n\t  if (c == L'\\0')\n\t    return s;\n\t  if (__glibc_unlikely (destlen-- == 0))\n\t    __chk_fail ();\n\t  c = *src++;\n\t  *++dest = c;\n\t  if (c == L'\\0')\n\t    return s;\n\t} while (--n4 > 0);\n      n &= 3;\n    }\n\n  while (n > 0)\n    {\n      if (__glibc_unlikely (destlen-- == 0))\n\t__chk_fail ();\n      c = *src++;\n      *++dest = c;\n      if (c == L'\\0')\n\treturn s;\n      n--;\n    }\n\n  if (c != L'\\0')\n    {\n      if (__glibc_unlikely (destlen-- == 0))\n\t__chk_fail ();\n      *++dest = L'\\0';\n    }\n\n  return s;\n}",
    "__wcsncpy_chk(int *, const int *, int, int)": "wchar_t *\n__wcsncpy_chk (wchar_t *dest, const wchar_t *src, size_t n, size_t destlen)\n{\n  if (__glibc_unlikely (destlen < n))\n    __chk_fail ();\n\n  /* This function is not often enough used to justify not using a\n     tail call.  */\n  return __wcsncpy (dest, src, n);\n}",
    "__wcsnrtombs_chk(char *, const int **, int, int, mbstate_t *, int)": "size_t\n__wcsnrtombs_chk (char *dst, const wchar_t **src, size_t nwc, size_t len,\n\t\t  mbstate_t *ps, size_t dstlen)\n{\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  return __wcsnrtombs (dst, src, nwc, len, ps);\n}",
    "__wcsrtombs_chk(char *, const int **, int, mbstate_t *, int)": "size_t\n__wcsrtombs_chk (char *dst, const wchar_t **src, size_t len,\n\t\t mbstate_t *ps, size_t dstlen)\n{\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  return __wcsrtombs (dst, src, len, ps);\n}",
    "__wcstombs_chk(char *, const int *, int, int)": "size_t\n__wcstombs_chk (char *dst, const wchar_t *src, size_t len, size_t dstlen)\n{\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  mbstate_t state;\n\n  memset (&state, '\\0', sizeof state);\n\n  /* Return how many we wrote (or maybe an error).  */\n  return __wcsrtombs (dst, &src, len, &state);\n}",
    "__wctomb_chk(char *, int, int)": "int\n__wctomb_chk (char *s, wchar_t wchar, size_t buflen)\n{\n  /* We do not have to implement the full wctomb semantics since we\n     know that S cannot be NULL when we come here.  */\n  if (buflen < MB_CUR_MAX)\n    __chk_fail ();\n\n  return __wcrtomb (s, wchar, &__wctomb_state);\n}",
    "__wmemcpy_chk(int *, const int *, int, int)": "wchar_t *\n__wmemcpy_chk (wchar_t *s1, const wchar_t *s2, size_t n, size_t ns1)\n{\n  if (__glibc_unlikely (ns1 < n))\n    __chk_fail ();\n  return (wchar_t *) memcpy ((char *) s1, (char *) s2, n * sizeof (wchar_t));\n}",
    "__wmemmove_chk(int *, const int *, int, int)": "wchar_t *\n__wmemmove_chk (wchar_t *s1, const wchar_t *s2, size_t n, size_t ns1)\n{\n  if (__glibc_unlikely (ns1 < n))\n    __chk_fail ();\n  return (wchar_t *) memmove ((char *) s1, (char *) s2, n * sizeof (wchar_t));\n}",
    "__wmempcpy_chk(int *, const int *, int, int)": "wchar_t *\n__wmempcpy_chk (wchar_t *s1, const wchar_t *s2, size_t n, size_t ns1)\n{\n  if (__glibc_unlikely (ns1 < n))\n    __chk_fail ();\n  return (wchar_t *) __mempcpy ((char *) s1, (char *) s2,\n\t\t\t\tn * sizeof (wchar_t));\n}",
    "__wmemset_chk(int *, int, int, int)": "wchar_t *\n__wmemset_chk (wchar_t *s, wchar_t c, size_t n, size_t dstlen)\n{\n  if (__glibc_unlikely (dstlen < n))\n    __chk_fail ();\n\n  return wmemset (s, c, n);\n}",
    "__wprintf_chk(int, const int *, ...)": "int\n__wprintf_chk (int flag, const wchar_t *format, ...)\n{\n  /* For flag > 0 (i.e. __USE_FORTIFY_LEVEL > 1) request that %n\n     can only come from read-only format strings.  */\n  unsigned int mode = (flag > 0) ? PRINTF_FORTIFY : 0;\n  va_list ap;\n  int ret;\n\n  va_start (ap, format);\n  ret = __vfwprintf_internal (stdout, format, ap, mode);\n  va_end (ap);\n\n  return ret;\n}",
    "alphasort64(const struct dirent64 **, const struct dirent64 **)": "int\nalphasort64 (const struct dirent64 **a, const struct dirent64 **b)\n{\n  return strcoll ((*a)->d_name, (*b)->d_name);\n}",
    "getdirentries64(int, char *, int, int *)": "ssize_t\ngetdirentries64 (int fd, char *buf, size_t nbytes, off64_t *basep)\n{\n  off64_t base = __lseek64 (fd, (off_t) 0, SEEK_CUR);\n\n  ssize_t result = __getdents64 (fd, buf, nbytes);\n\n  if (result != -1)\n    *basep = base;\n\n  return result;\n}",
    "readdir64_r(DIR *, struct dirent64 *, struct dirent64 **)": "int\nreaddir64_r (DIR *dirp, struct dirent64 *entry, struct dirent64 **result)\n{\n  __set_errno (ENOSYS);\n  *result = NULL;\n  return -1;\n}",
    "scandir64(const char *, struct dirent64 ***, int (*)(const struct dirent64 *), int (*)(const struct dirent64 **, const struct dirent64 **))": "int\nscandir64 (const char *dir, struct dirent64 ***namelist,\n\t   int (*select) (const struct dirent64 *),\n\t   int (*cmp) (const struct dirent64 **, const struct dirent64 **))\n{\n  return __scandir64_tail (__opendir (dir), namelist, select, cmp);\n}",
    "scandirat64(int, const char *, struct dirent64 ***, int (*)(const struct dirent64 *), int (*)(const struct dirent64 **, const struct dirent64 **))": "int\nscandirat64 (int dfd, const char *dir, struct dirent64 ***namelist,\n\t     int (*select) (const struct dirent64 *),\n\t     int (*cmp) (const struct dirent64 **, const struct dirent64 **))\n{\n  return __scandir64_tail (__opendirat (dfd, dir), namelist, select, cmp);\n}",
    "seekdir(DIR *, long)": "void\nseekdir (DIR *dirp, long int pos)\n{\n  __libc_lock_lock (dirp->lock);\n  (void) __lseek (dirp->fd, pos, SEEK_SET);\n  dirp->size = 0;\n  dirp->offset = 0;\n  dirp->filepos = pos;\n  __libc_lock_unlock (dirp->lock);\n}",
    "telldir(DIR *)": "long int\ntelldir (DIR *dirp)\n{\n  long int ret;\n\n  __libc_lock_lock (dirp->lock);\n  ret = dirp->filepos;\n  __libc_lock_unlock (dirp->lock);\n\n  return ret;\n}",
    "versionsort64(const struct dirent64 **, const struct dirent64 **)": "int\nversionsort64 (const struct dirent64 **a, const struct dirent64 **b)\n{\n  return __strverscmp ((*a)->d_name, (*b)->d_name);\n}",
    "malloc(int)": "void *\nmalloc (size_t size)\n{\n  if (fail_malloc)\n    return NULL;\n\n  static void *(*original_malloc) (size_t);\n  if (original_malloc == NULL)\n    original_malloc = xdlsym (RTLD_NEXT, \"malloc\");\n  return original_malloc (size);\n}",
    "unsetenv(const char *)": "int\nunsetenv (const char *name)\n{\n  size_t len;\n  char **ep;\n\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  len = strlen (name);\n\n  LOCK;\n\n  ep = __environ;\n  if (ep != NULL)\n    while (*ep != NULL)\n      {\n\tif (!strncmp (*ep, name, len) && (*ep)[len] == '=')\n\t  {\n\t    /* Found it.  Remove this pointer by moving later ones back.  */\n\t    char **dp = ep;\n\n\t    do\n\t\tdp[0] = dp[1];\n\t    while (*dp++);\n\t    /* Continue the loop in case NAME appears again.  */\n\t  }\n\telse\n\t  ++ep;\n      }\n\n  UNLOCK;\n\n  return 0;\n}",
    "_dl_find_object(void *, struct dl_find_object *)": "int\n_dl_find_object (void *address, struct dl_find_object *result)\n{\n  return GLRO (dl_find_object) (address, result);\n}",
    "_dl_mcount_wrapper(void *)": "void\n_dl_mcount_wrapper (void *selfpc)\n{\n  GLRO(dl_mcount) ((ElfW(Addr)) RETURN_ADDRESS (0), (ElfW(Addr)) selfpc);\n}",
    "_dl_mcount_wrapper_check(void *)": "void\n_dl_mcount_wrapper_check (void *selfpc)\n{\n  if (GL(dl_profile_map) != NULL)\n    GLRO(dl_mcount) ((ElfW(Addr)) RETURN_ADDRESS (0), (ElfW(Addr)) selfpc);\n}",
    "__libc_early_init(_Bool)": "void\n__libc_early_init (_Bool initial)\n{\n  /* Initialize ctype data.  */\n  __ctype_init ();\n\n  /* Only the outer namespace is marked as single-threaded.  */\n  __libc_single_threaded = initial;\n\n#ifdef SHARED\n  __libc_single_threaded_internal = __libc_initial = initial;\n#endif\n\n  __pthread_early_init ();\n\n#if ENABLE_ELISION_SUPPORT\n  __lll_elision_init ();\n#endif\n}",
    "getpid()": "pid_t getpid(void)\n{\n  pid_t (*f)(void);\n  f = (pid_t (*)(void)) dlsym (RTLD_NEXT, \"getpid\");\n  if (f == NULL)\n    error (EXIT_FAILURE, 0, \"dlsym (RTLD_NEXT, \\\"getpid\\\"): %s\", dlerror ());\n  return (pid2 = f()) + 26;\n}",
    "calloc(int, int)": "void *\ncalloc (size_t a, size_t b)\n{\n  if (b > 0 && a > SIZE_MAX / b)\n    {\n      errno = ENOMEM;\n      return NULL;\n    }\n  lock ();\n  /* malloc_internal uses mmap, so the memory is zeroed.  */\n  void *result = malloc_internal (a * b);\n  unlock ();\n  return result;\n}",
    "access(int)": "static void\naccess (int i)\n{\n  char *buf = xasprintf (\"tls_global_%02d\", i);\n  dlerror ();\n  int *p = dlsym (mod[i], buf);\n  if (test_verbose)\n    printf (\"mod[%d]: &tls = %p\\n\", i, p);\n  if (p == NULL)\n    FAIL_EXIT1 (\"dlsym failed: %s\\n\", dlerror ());\n  TEST_COMPARE (*p, 0);\n  ++*p;\n  free (buf);\n}",
    "__profile_frequency()": "int\n__profile_frequency (void)\n{\n  return GLRO(dl_clktck);\n}",
    "__libc_alloca_cutoff(int)": "int\n__libc_alloca_cutoff (size_t size)\n{\n  return size <= (MIN (__MAX_ALLOCA_CUTOFF,\n\t\t       THREAD_GETMEM (THREAD_SELF, stackblock_size) / 4\n\t\t       /* The main thread, before the thread library is\n\t\t\t  initialized, has zero in the stackblock_size\n\t\t\t  element.  Since it is the main thread we can\n\t\t\t  assume the maximum available stack space.  */\n\t\t       ?: __MAX_ALLOCA_CUTOFF * 4));\n}",
    "pthread_attr_init(pthread_attr_t *)": "FORWARD (pthread_attr_init, (pthread_attr_t *attr), (attr), 0)",
    "pthread_attr_setschedparam(pthread_attr_t *, const struct sched_param *)": "FORWARD (pthread_attr_setschedparam,\n\t (pthread_attr_t *attr, const struct sched_param *param),\n\t (attr, param), 0)",
    "pthread_attr_getscope(const pthread_attr_t *, int *)": "FORWARD (pthread_attr_getscope,\n\t (const pthread_attr_t *attr, int *scope), (attr, scope), 0)",
    "pthread_attr_setscope(pthread_attr_t *, int)": "FORWARD (pthread_attr_setscope, (pthread_attr_t *attr, int scope),\n\t (attr, scope), 0)",
    "pthread_condattr_destroy(pthread_condattr_t *)": "FORWARD (pthread_condattr_destroy, (pthread_condattr_t *attr), (attr), 0)",
    "pthread_condattr_init(pthread_condattr_t *)": "FORWARD (pthread_condattr_init, (pthread_condattr_t *attr), (attr), 0)",
    "pthread_cond_broadcast(pthread_cond_t *)": "FORWARD (pthread_cond_broadcast, (pthread_cond_t *cond), (cond), 0)",
    "pthread_cond_destroy(pthread_cond_t *)": "FORWARD (pthread_cond_destroy, (pthread_cond_t *cond), (cond), 0)",
    "pthread_cond_init(pthread_cond_t *, const pthread_condattr_t *)": "FORWARD (pthread_cond_init,\n\t (pthread_cond_t *cond, const pthread_condattr_t *cond_attr),\n\t (cond, cond_attr), 0)",
    "pthread_cond_signal(pthread_cond_t *)": "FORWARD (pthread_cond_signal, (pthread_cond_t *cond), (cond), 0)",
    "pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *)": "FORWARD (pthread_cond_wait, (pthread_cond_t *cond, pthread_mutex_t *mutex),\n\t (cond, mutex), 0)",
    "pthread_cond_timedwait(pthread_cond_t *, pthread_mutex_t *, const struct timespec *)": "FORWARD (pthread_cond_timedwait,\n\t (pthread_cond_t *cond, pthread_mutex_t *mutex,\n\t  const struct timespec *abstime), (cond, mutex, abstime), 0)",
    "pthread_mutex_destroy(pthread_mutex_t *)": "FORWARD (pthread_mutex_destroy, (pthread_mutex_t *mutex), (mutex), 0)",
    "pthread_mutex_init(pthread_mutex_t *, const pthread_mutexattr_t *)": "FORWARD (pthread_mutex_init,\n\t (pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr),\n\t (mutex, mutexattr), 0)",
    "pthread_mutex_lock(pthread_mutex_t *)": "FORWARD (pthread_mutex_lock, (pthread_mutex_t *mutex), (mutex), 0)",
    "pthread_mutex_unlock(pthread_mutex_t *)": "FORWARD (pthread_mutex_unlock, (pthread_mutex_t *mutex), (mutex), 0)",
    "pthread_setcanceltype(int, int *)": "FORWARD (pthread_setcanceltype, (int type, int *oldtype), (type, oldtype), 0)",
    "__h_errno_location()": "int *\n__h_errno_location (void)\n{\n  return &__h_errno;\n}",
    "pthread_yield()": "int\npthread_yield (void)\n{\n  return __sched_yield ();\n}",
    "__gconv_get_cache()": "void *\n__gconv_get_cache (void)\n{\n  return gconv_cache;\n}",
    "__gconv_create_spec(struct gconv_spec *, const char *, const char *)": "struct gconv_spec *\n__gconv_create_spec (struct gconv_spec *conv_spec, const char *fromcode,\n                   const char *tocode)\n{\n  struct gconv_parsed_code pfc, ptc;\n  struct gconv_spec *ret = NULL;\n\n  pfc.code = __strdup (fromcode);\n  ptc.code = __strdup (tocode);\n\n  if ((pfc.code == NULL)\n      || (ptc.code == NULL))\n    goto out;\n\n  gconv_parse_code (&pfc);\n  gconv_parse_code (&ptc);\n\n  /* We ignore suffixes in the fromcode because that is how the current\n     implementation has always handled them.  Only suffixes in the tocode are\n     processed and handled.  The reality is that invalid input in the input\n     character set should only be ignored if the fromcode specifies IGNORE.\n     The current implementation ignores invalid input in the input character\n     set if the tocode contains IGNORE.  We preserve this behavior for\n     backwards compatibility.  In the future we may split the handling of\n     IGNORE to allow a finer grained specification of ignoring invalid input\n     and/or ignoring invalid output.  */\n  conv_spec->translit = ptc.translit;\n  conv_spec->ignore = ptc.ignore;\n\n  /* 3 extra bytes because 1 extra for '\\0', and 2 extra so strip might\n     be able to add one or two trailing '/' characters if necessary.  */\n  conv_spec->fromcode = malloc (strlen (fromcode) + 3);\n  if (conv_spec->fromcode == NULL)\n    goto out;\n\n  conv_spec->tocode = malloc (strlen (tocode) + 3);\n  if (conv_spec->tocode == NULL)\n    {\n      free (conv_spec->fromcode);\n      conv_spec->fromcode = NULL;\n      goto out;\n    }\n\n  /* Strip unrecognized characters and ensure that the code has two '/'\n     characters as per conversion code triplet specification.  */\n  strip (conv_spec->fromcode, pfc.code);\n  strip (conv_spec->tocode, ptc.code);\n  ret = conv_spec;\n\nout:\n  free (pfc.code);\n  free (ptc.code);\n\n  return ret;\n}",
    "__gconv_get_modules_db()": "struct gconv_module *\n__gconv_get_modules_db (void)\n{\n  return __gconv_modules_db;\n}",
    "__gconv_get_alias_db()": "void *\n__gconv_get_alias_db (void)\n{\n  return __gconv_alias_db;\n}",
    "__gconv_open(struct gconv_spec *, __gconv_t *, int)": "int\n__gconv_open (struct gconv_spec *conv_spec, __gconv_t *handle,\n\t      int flags)\n{\n  struct __gconv_step *steps;\n  size_t nsteps;\n  __gconv_t result = NULL;\n  size_t cnt = 0;\n  int res;\n  int conv_flags = 0;\n  bool translit = false;\n  char *tocode, *fromcode;\n\n  /* Find out whether any error handling method is specified.  */\n  translit = conv_spec->translit;\n\n  if (conv_spec->ignore)\n    conv_flags |= __GCONV_IGNORE_ERRORS;\n\n  tocode = conv_spec->tocode;\n  fromcode = conv_spec->fromcode;\n\n  /* If the string is empty define this to mean the charset of the\n     currently selected locale.  */\n  if (strcmp (tocode, \"//\") == 0)\n    {\n      const char *codeset = _NL_CURRENT (LC_CTYPE, CODESET);\n      size_t len = strlen (codeset);\n      char *dest;\n      tocode = dest = (char *) alloca (len + 3);\n      memcpy (__mempcpy (dest, codeset, len), \"//\", 3);\n    }\n  if (strcmp (fromcode, \"//\") == 0)\n    {\n      const char *codeset = _NL_CURRENT (LC_CTYPE, CODESET);\n      size_t len = strlen (codeset);\n      char *dest;\n      fromcode = dest = (char *) alloca (len + 3);\n      memcpy (__mempcpy (dest, codeset, len), \"//\", 3);\n    }\n\n  res = __gconv_find_transform (tocode, fromcode, &steps, &nsteps, flags);\n  if (res == __GCONV_OK)\n    {\n      /* Allocate room for handle.  */\n      result = (__gconv_t) malloc (sizeof (struct __gconv_info)\n\t\t\t\t   + (nsteps\n\t\t\t\t      * sizeof (struct __gconv_step_data)));\n      if (result == NULL)\n\tres = __GCONV_NOMEM;\n      else\n\t{\n\t  /* Remember the list of steps.  */\n\t  result->__steps = steps;\n\t  result->__nsteps = nsteps;\n\n\t  /* Clear the array for the step data.  */\n\t  memset (result->__data, '\\0',\n\t\t  nsteps * sizeof (struct __gconv_step_data));\n\n\t  /* Call all initialization functions for the transformation\n\t     step implementations.  */\n\t  for (cnt = 0; cnt < nsteps; ++cnt)\n\t    {\n\t      size_t size;\n\n\t      /* Would have to be done if we would not clear the whole\n                 array above.  */\n#if 0\n\t      /* Reset the counter.  */\n\t      result->__data[cnt].__invocation_counter = 0;\n\n\t      /* It's a regular use.  */\n\t      result->__data[cnt].__internal_use = 0;\n#endif\n\n\t      /* We use the `mbstate_t' member in DATA.  */\n\t      result->__data[cnt].__statep = &result->__data[cnt].__state;\n\n\t      /* The builtin transliteration handling only\n\t\t supports the internal encoding.  */\n\t      if (translit\n\t\t  && __strcasecmp_l (steps[cnt].__from_name,\n\t\t\t\t     \"INTERNAL\", _nl_C_locobj_ptr) == 0)\n\t\tconv_flags |= __GCONV_TRANSLIT;\n\n\t      /* If this is the last step we must not allocate an\n\t\t output buffer.  */\n\t      if (cnt < nsteps - 1)\n\t\t{\n\t\t  result->__data[cnt].__flags = conv_flags;\n\n\t\t  /* Allocate the buffer.  */\n\t\t  size = (GCONV_NCHAR_GOAL * steps[cnt].__max_needed_to);\n\n\t\t  result->__data[cnt].__outbuf = malloc (size);\n\t\t  if (result->__data[cnt].__outbuf == NULL)\n\t\t    {\n\t\t      res = __GCONV_NOMEM;\n\t\t      goto bail;\n\t\t    }\n\n\t\t  result->__data[cnt].__outbufend =\n\t\t    result->__data[cnt].__outbuf + size;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Handle the last entry.  */\n\t\t  result->__data[cnt].__flags = conv_flags | __GCONV_IS_LAST;\n\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      if (res != __GCONV_OK)\n\t{\n\t  /* Something went wrong.  Free all the resources.  */\n\t  int serrno;\n\tbail:\n\t  serrno = errno;\n\n\t  if (result != NULL)\n\t    {\n\t      while (cnt-- > 0)\n\t\tfree (result->__data[cnt].__outbuf);\n\n\t      free (result);\n\t      result = NULL;\n\t    }\n\n\t  __gconv_close_transform (steps, nsteps);\n\n\t  __set_errno (serrno);\n\t}\n    }\n\n  *handle = result;\n  return res;\n}",
    "__gconv_transliterate(struct __gconv_step *, struct __gconv_step_data *, const unsigned char *, const unsigned char **, const unsigned char *, unsigned char **, int *)": "int\n__gconv_transliterate (struct __gconv_step *step,\n\t\t       struct __gconv_step_data *step_data,\n\t\t       const unsigned char *inbufstart,\n\t\t       const unsigned char **inbufp,\n\t\t       const unsigned char *inbufend,\n\t\t       unsigned char **outbufstart, size_t *irreversible)\n{\n  /* Find out about the locale's transliteration.  */\n  uint32_t size;\n  const uint32_t *from_idx;\n  const uint32_t *from_tbl;\n  const uint32_t *to_idx;\n  const uint32_t *to_tbl;\n  const uint32_t *winbuf;\n  const uint32_t *winbufend;\n  uint32_t low;\n  uint32_t high;\n\n  /* The input buffer.  There are actually 4-byte values.  */\n  winbuf = (const uint32_t *) *inbufp;\n  winbufend = (const uint32_t *) inbufend;\n\n  __gconv_fct fct = step->__fct;\n  if (step->__shlib_handle != NULL)\n    PTR_DEMANGLE (fct);\n\n  /* If there is no transliteration information in the locale don't do\n     anything and return the error.  */\n  size = _NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_TRANSLIT_TAB_SIZE);\n  if (size == 0)\n    goto no_rules;\n\n  /* Get the rest of the values.  */\n  from_idx =\n    (const uint32_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_TRANSLIT_FROM_IDX);\n  from_tbl =\n    (const uint32_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_TRANSLIT_FROM_TBL);\n  to_idx =\n    (const uint32_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_TRANSLIT_TO_IDX);\n  to_tbl =\n    (const uint32_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_TRANSLIT_TO_TBL);\n\n  /* Test whether there is enough input.  */\n  if (winbuf + 1 > winbufend)\n    return (winbuf == winbufend\n\t    ? __GCONV_EMPTY_INPUT : __GCONV_INCOMPLETE_INPUT);\n\n  /* The array starting at FROM_IDX contains indices to the string table\n     in FROM_TBL.  The indices are sorted wrt to the strings.  I.e., we\n     are doing binary search.  */\n  low = 0;\n  high = size;\n  while (low < high)\n    {\n      uint32_t med = (low + high) / 2;\n      uint32_t idx;\n      int cnt;\n\n      /* Compare the string at this index with the string at the current\n\t position in the input buffer.  */\n      idx = from_idx[med];\n      cnt = 0;\n      do\n\t{\n\t  if (from_tbl[idx + cnt] != winbuf[cnt])\n\t    /* Does not match.  */\n\t    break;\n\t  ++cnt;\n\t}\n      while (from_tbl[idx + cnt] != L'\\0' && winbuf + cnt < winbufend);\n\n      if (cnt > 0 && from_tbl[idx + cnt] == L'\\0')\n\t{\n\t  /* Found a matching input sequence.  Now try to convert the\n\t     possible replacements.  */\n\t  uint32_t idx2 = to_idx[med];\n\n\t  do\n\t    {\n\t      /* Determine length of replacement.  */\n\t      unsigned int len = 0;\n\t      int res;\n\t      const unsigned char *toinptr;\n\t      unsigned char *outptr;\n\n\t      while (to_tbl[idx2 + len] != L'\\0')\n\t\t++len;\n\n\t      /* Try this input text.  */\n\t      toinptr = (const unsigned char *) &to_tbl[idx2];\n\t      outptr = *outbufstart;\n\t      res = DL_CALL_FCT (fct,\n\t\t\t\t (step, step_data, &toinptr,\n\t\t\t\t  (const unsigned char *) &to_tbl[idx2 + len],\n\t\t\t\t  &outptr, NULL, 0, 0));\n\t      if (res != __GCONV_ILLEGAL_INPUT)\n\t\t{\n\t\t  /* If the conversion succeeds we have to increment the\n\t\t     input buffer.  */\n\t\t  if (res == __GCONV_EMPTY_INPUT)\n\t\t    {\n\t\t      *inbufp += cnt * sizeof (uint32_t);\n\t\t      ++*irreversible;\n\t\t      res = __GCONV_OK;\n\t\t    }\n\t\t  /* Do not increment the output pointer if we could not\n\t\t     store the entire output. */\n\t\t  if (res != __GCONV_FULL_OUTPUT)\n\t\t    *outbufstart = outptr;\n\n\t\t  return res;\n\t\t}\n\n\t      /* Next replacement.  */\n\t      idx2 += len + 1;\n\t    }\n\t  while (to_tbl[idx2] != L'\\0');\n\n\t  /* Nothing found, continue searching.  */\n\t}\n      else if (cnt > 0)\n\t/* This means that the input buffer contents matches a prefix of\n\t   an entry.  Since we cannot match it unless we get more input,\n\t   we will tell the caller about it.  */\n\treturn __GCONV_INCOMPLETE_INPUT;\n\n      if (winbuf + cnt >= winbufend || from_tbl[idx + cnt] < winbuf[cnt])\n\tlow = med + 1;\n      else\n\thigh = med;\n    }\n\n no_rules:\n  /* Maybe the character is supposed to be ignored.  */\n  if (_NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_TRANSLIT_IGNORE_LEN) != 0)\n    {\n      int n = _NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_TRANSLIT_IGNORE_LEN);\n      const uint32_t *ranges =\n\t(const uint32_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_TRANSLIT_IGNORE);\n      const uint32_t wc = *(const uint32_t *) (*inbufp);\n      int i;\n\n      /* Test whether there is enough input.  */\n      if (winbuf + 1 > winbufend)\n\treturn (winbuf == winbufend\n\t\t? __GCONV_EMPTY_INPUT : __GCONV_INCOMPLETE_INPUT);\n\n      for (i = 0; i < n; ranges += 3, ++i)\n\tif (ranges[0] <= wc && wc <= ranges[1]\n\t    && (wc - ranges[0]) % ranges[2] == 0)\n\t  {\n\t    /* Matches the range.  Ignore it.  */\n\t    *inbufp += 4;\n\t    ++*irreversible;\n\t    return __GCONV_OK;\n\t  }\n\telse if (wc < ranges[0])\n\t  /* There cannot be any other matching range since they are\n             sorted.  */\n\t  break;\n    }\n\n  /* One last chance: use the default replacement.  */\n  if (_NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN) != 0)\n    {\n      const uint32_t *default_missing = (const uint32_t *)\n\t_NL_CURRENT (LC_CTYPE, _NL_CTYPE_TRANSLIT_DEFAULT_MISSING);\n      const unsigned char *toinptr = (const unsigned char *) default_missing;\n      uint32_t len = _NL_CURRENT_WORD (LC_CTYPE,\n\t\t\t\t       _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN);\n      unsigned char *outptr;\n      int res;\n\n      /* Test whether there is enough input.  */\n      if (winbuf + 1 > winbufend)\n\treturn (winbuf == winbufend\n\t\t? __GCONV_EMPTY_INPUT : __GCONV_INCOMPLETE_INPUT);\n\n      outptr = *outbufstart;\n      res = DL_CALL_FCT (fct,\n\t\t\t (step, step_data, &toinptr,\n\t\t\t  (const unsigned char *) (default_missing + len),\n\t\t\t  &outptr, NULL, 0, 0));\n\n      if (res != __GCONV_ILLEGAL_INPUT)\n\t{\n\t  /* If the conversion succeeds we have to increment the\n\t     input buffer.  */\n\t  if (res == __GCONV_EMPTY_INPUT)\n\t    {\n\t      /* This worked but is not reversible.  */\n\t      ++*irreversible;\n\t      *inbufp += 4;\n\t      res = __GCONV_OK;\n\t    }\n\t  *outbufstart = outptr;\n\n\t  return res;\n\t}\n    }\n\n  /* Haven't found a match.  */\n  return __GCONV_ILLEGAL_INPUT;\n}",
    "iconv(iconv_t, char **, int *, char **, int *)": "size_t\niconv (iconv_t cd, char **inbuf, size_t *inbytesleft, char **outbuf,\n       size_t *outbytesleft)\n{\n  __gconv_t gcd = (__gconv_t) cd;\n  char *outstart = outbuf ? *outbuf : NULL;\n  size_t irreversible;\n  int result;\n\n  if (__glibc_unlikely (inbuf == NULL || *inbuf == NULL))\n    {\n      if (outbuf == NULL || *outbuf == NULL)\n\tresult = __gconv (gcd, NULL, NULL, NULL, NULL, &irreversible);\n      else\n\tresult = __gconv (gcd, NULL, NULL, (unsigned char **) outbuf,\n\t\t\t  (unsigned char *) (outstart + *outbytesleft),\n\t\t\t  &irreversible);\n    }\n  else\n    {\n      const char *instart = *inbuf;\n\n      result = __gconv (gcd, (const unsigned char **) inbuf,\n\t\t\t(const unsigned char *)  (*inbuf + *inbytesleft),\n\t\t\t(unsigned char **) outbuf,\n\t\t\t(unsigned char *) (*outbuf + *outbytesleft),\n\t\t\t&irreversible);\n\n      *inbytesleft -= *inbuf - instart;\n    }\n  if (outstart != NULL)\n    *outbytesleft -= *outbuf - outstart;\n\n  switch (__builtin_expect (result, __GCONV_OK))\n    {\n    case __GCONV_ILLEGAL_DESCRIPTOR:\n      __set_errno (EBADF);\n      irreversible = (size_t) -1L;\n      break;\n\n    case __GCONV_ILLEGAL_INPUT:\n      __set_errno (EILSEQ);\n      irreversible = (size_t) -1L;\n      break;\n\n    case __GCONV_FULL_OUTPUT:\n      __set_errno (E2BIG);\n      irreversible = (size_t) -1L;\n      break;\n\n    case __GCONV_INCOMPLETE_INPUT:\n      __set_errno (EINVAL);\n      irreversible = (size_t) -1L;\n      break;\n\n    case __GCONV_EMPTY_INPUT:\n    case __GCONV_OK:\n      /* Nothing.  */\n      break;\n\n    default:\n      assert (!\"Nothing like this should happen\");\n    }\n\n  return irreversible;\n}",
    "iconv_close(iconv_t)": "int\niconv_close (iconv_t cd)\n{\n  if (__glibc_unlikely (cd == (iconv_t *) -1L))\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  return __gconv_close ((__gconv_t) cd) ? -1 : 0;\n}",
    "iconv_open(const char *, const char *)": "iconv_t\niconv_open (const char *tocode, const char *fromcode)\n{\n  __gconv_t cd;\n  struct gconv_spec conv_spec;\n\n  if (__gconv_create_spec (&conv_spec, fromcode, tocode) == NULL)\n    return (iconv_t) -1;\n\n  int res = __gconv_open (&conv_spec, &cd, 0);\n\n  __gconv_destroy_spec (&conv_spec);\n\n  if (__builtin_expect (res, __GCONV_OK) != __GCONV_OK)\n    {\n      /* We must set the error number according to the specs.  */\n      if (res == __GCONV_NOCONV || res == __GCONV_NODB)\n\t__set_errno (EINVAL);\n\n      cd = (iconv_t) -1;\n    }\n\n  return (iconv_t) cd;\n}",
    "bindresvport(int, struct sockaddr_in *)": "int\nbindresvport (int sd, struct sockaddr_in *sin)\n{\n  static short port;\n  struct sockaddr_in myaddr;\n  int i;\n\n#define STARTPORT 600\n#define LOWPORT 512\n#define ENDPORT (IPPORT_RESERVED - 1)\n#define NPORTS\t(ENDPORT - STARTPORT + 1)\n  static short startport = STARTPORT;\n\n  if (sin == (struct sockaddr_in *) 0)\n    {\n      sin = &myaddr;\n      memset (sin, 0, sizeof (*sin));\n      sin->sin_family = AF_INET;\n    }\n  else if (sin->sin_family != AF_INET)\n    {\n      __set_errno (EAFNOSUPPORT);\n      return -1;\n    }\n\n  if (port == 0)\n    {\n      port = (__getpid () % NPORTS) + STARTPORT;\n    }\n\n  /* Initialize to make gcc happy.  */\n  int res = -1;\n\n  int nports = ENDPORT - startport + 1;\n  int endport = ENDPORT;\n\n  __libc_lock_lock (lock);\n\n again:\n  for (i = 0; i < nports; ++i)\n    {\n      sin->sin_port = htons (port++);\n      if (port > endport)\n\tport = startport;\n      res = __bind (sd, sin, sizeof (struct sockaddr_in));\n      if (res >= 0 || errno != EADDRINUSE)\n\tbreak;\n    }\n\n  if (i == nports && startport != LOWPORT)\n    {\n      startport = LOWPORT;\n      endport = STARTPORT - 1;\n      nports = STARTPORT - LOWPORT;\n      port = LOWPORT + port % (STARTPORT - LOWPORT);\n      goto again;\n    }\n\n  __libc_lock_unlock (lock);\n\n  return res;\n}",
    "ether_aton(const char *)": "struct ether_addr *\nether_aton (const char *asc)\n{\n  static struct ether_addr result;\n\n  return ether_aton_r (asc, &result);\n}",
    "ether_aton_r(const char *, struct ether_addr *)": "struct ether_addr *\nether_aton_r (const char *asc, struct ether_addr *addr)\n{\n  size_t cnt;\n\n  for (cnt = 0; cnt < 6; ++cnt)\n    {\n      unsigned int number;\n      char ch;\n\n      ch = _tolower (*asc++);\n      if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f'))\n\treturn NULL;\n      number = isdigit (ch) ? (ch - '0') : (ch - 'a' + 10);\n\n      ch = _tolower (*asc);\n      if ((cnt < 5 && ch != ':') || (cnt == 5 && ch != '\\0' && !isspace (ch)))\n\t{\n\t  ++asc;\n\t  if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f'))\n\t    return NULL;\n\t  number <<= 4;\n\t  number += isdigit (ch) ? (ch - '0') : (ch - 'a' + 10);\n\n\t  ch = *asc;\n\t  if (cnt < 5 && ch != ':')\n\t    return NULL;\n\t}\n\n      /* Store result.  */\n      addr->ether_addr_octet[cnt] = (unsigned char) number;\n\n      /* Skip ':'.  */\n      ++asc;\n    }\n\n  return addr;\n}",
    "ether_line(const char *, struct ether_addr *, char *)": "int\nether_line (const char *line, struct ether_addr *addr, char *hostname)\n{\n  for (size_t cnt = 0; cnt < 6; ++cnt)\n    {\n      unsigned int number;\n      char ch;\n\n      ch = _tolower (*line++);\n      if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f'))\n\treturn -1;\n      number = isdigit (ch) ? (ch - '0') : (ch - 'a' + 10);\n\n      ch = _tolower (*line);\n      if ((cnt < 5 && ch != ':') || (cnt == 5 && ch != '\\0' && !isspace (ch)))\n\t{\n\t  ++line;\n\t  if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f'))\n\t    return -1;\n\t  number <<= 4;\n\t  number += isdigit (ch) ? (ch - '0') : (ch - 'a' + 10);\n\n\t  ch = *line;\n\t  if (cnt < 5 && ch != ':')\n\t    return -1;\n\t}\n\n      /* Store result.  */\n      addr->ether_addr_octet[cnt] = (unsigned char) number;\n\n      /* Skip ':'.  */\n      if (ch != '\\0')\n\t++line;\n    }\n\n  /* Skip initial whitespace.  */\n  while (isspace (*line))\n    ++line;\n\n  if (*line == '#' || *line == '\\0')\n    /* No hostname.  */\n    return -1;\n\n  /* The hostname is up to the next non-space character.  */\n  /* XXX This can cause trouble because the hostname might be too long\n     but we have no possibility to check it here.  */\n  while (*line != '\\0' && *line != '#' && !isspace (*line))\n    *hostname++ = *line++;\n  *hostname = '\\0';\n\n  return 0;\n}",
    "ether_ntoa(const struct ether_addr *)": "char *\nether_ntoa (const struct ether_addr *addr)\n{\n  static char asc[18];\n\n  return ether_ntoa_r (addr, asc);\n}",
    "ether_ntoa_r(const struct ether_addr *, char *)": "char *\nether_ntoa_r (const struct ether_addr *addr, char *buf)\n{\n  sprintf (buf, \"%x:%x:%x:%x:%x:%x\",\n\t   addr->ether_addr_octet[0], addr->ether_addr_octet[1],\n\t   addr->ether_addr_octet[2], addr->ether_addr_octet[3],\n\t   addr->ether_addr_octet[4], addr->ether_addr_octet[5]);\n  return buf;\n}",
    "getipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t *, uint32_t *, struct in_addr *)": "int\ngetipv4sourcefilter (int s, struct in_addr interface, struct in_addr group,\n\t\t     uint32_t *fmode, uint32_t *numsrc, struct in_addr *slist)\n{\n  /* We have to create an struct ip_msfilter object which we can pass\n     to the kernel.  */\n  socklen_t needed = IP_MSFILTER_SIZE (*numsrc);\n\n  struct scratch_buffer buf;\n  scratch_buffer_init (&buf);\n  if (!scratch_buffer_set_array_size (&buf, 1, needed))\n    return -1;\n  struct ip_msfilter *imsf = buf.data;\n\n  imsf->imsf_multiaddr = group;\n  imsf->imsf_interface = interface;\n  imsf->imsf_numsrc = *numsrc;\n\n  int result = __getsockopt (s, SOL_IP, IP_MSFILTER, imsf, &needed);\n\n  /* If successful, copy the results to the places the caller wants\n     them in.  */\n  if (result == 0)\n    {\n      *fmode = imsf->imsf_fmode;\n      memcpy (slist, imsf->imsf_slist,\n\t      MIN (*numsrc, imsf->imsf_numsrc) * sizeof (struct in_addr));\n      *numsrc = imsf->imsf_numsrc;\n    }\n\n  scratch_buffer_free (&buf);\n\n  return result;\n}",
    "getsourcefilter(int, uint32_t, const struct sockaddr *, socklen_t, uint32_t *, uint32_t *, struct sockaddr_storage *)": "int\ngetsourcefilter (int s, uint32_t interface, const struct sockaddr *group,\n\t\t socklen_t grouplen, uint32_t *fmode, uint32_t *numsrc,\n\t\t struct sockaddr_storage *slist)\n{\n  /* We have to create an struct ip_msfilter object which we can pass\n     to the kernel.  */\n  socklen_t needed = GROUP_FILTER_SIZE (*numsrc);\n\n  struct scratch_buffer buf;\n  scratch_buffer_init (&buf);\n  if (!scratch_buffer_set_array_size (&buf, 1, needed))\n    return -1;\n  struct group_filter *gf = buf.data;\n\n  gf->gf_interface = interface;\n  memcpy (&gf->gf_group, group, grouplen);\n  gf->gf_numsrc = *numsrc;\n\n  /* We need to provide the appropriate socket level value.  */\n  int result;\n  int sol = __get_sol (group->sa_family, grouplen);\n  if (sol == -1)\n    {\n      __set_errno (EINVAL);\n      result = -1;\n    }\n  else\n    {\n      result = __getsockopt (s, sol, MCAST_MSFILTER, gf, &needed);\n\n      /* If successful, copy the results to the places the caller wants\n\t them in.  */\n      if (result == 0)\n\t{\n\t  *fmode = gf->gf_fmode;\n\t  memcpy (slist, gf->gf_slist,\n\t\t  MIN (*numsrc, gf->gf_numsrc)\n\t\t  * sizeof (struct sockaddr_storage));\n\t  *numsrc = gf->gf_numsrc;\n\t}\n    }\n\n  scratch_buffer_free (&buf);\n\n  return result;\n}",
    "htonl(uint32_t)": "uint32_t\nhtonl (uint32_t x)\n{\n#if BYTE_ORDER == BIG_ENDIAN\n  return x;\n#elif BYTE_ORDER == LITTLE_ENDIAN\n  return __bswap_32 (x);\n#else\n# error \"What kind of system is this?\"\n#endif\n}",
    "htons(uint16_t)": "uint16_t\nhtons (uint16_t x)\n{\n#if BYTE_ORDER == BIG_ENDIAN\n  return x;\n#elif BYTE_ORDER == LITTLE_ENDIAN\n  return __bswap_16 (x);\n#else\n# error \"What kind of system is this?\"\n#endif\n}",
    "__idna_to_dns_encoding(const char *, char **)": "int\n__idna_to_dns_encoding (const char *name, char **result)\n{\n  switch (__idna_name_classify (name))\n    {\n    case idna_name_ascii:\n      /* Nothing to convert.  */\n      return gai_strdup (name, result);\n    case idna_name_nonascii:\n      /* Encoding needed.  Handled below.  */\n      break;\n    case idna_name_nonascii_backslash:\n    case idna_name_encoding_error:\n      return EAI_IDN_ENCODE;\n    case idna_name_memory_error:\n      return EAI_MEMORY;\n    case idna_name_error:\n      return EAI_SYSTEM;\n    }\n\n  struct functions *functions = get_functions ();\n  if (functions == NULL)\n    /* We report this as an encoding error (assuming that libidn2 is\n       not installed), although the root cause may be a temporary\n       error condition due to resource shortage.  */\n    return EAI_IDN_ENCODE;\n  char *ptr = NULL;\n  __typeof__ (functions->lookup_ul) fptr = functions->lookup_ul;\n  PTR_DEMANGLE (fptr);\n  int ret = fptr (name, &ptr, 0);\n  if (ret == 0)\n    {\n      /* Assume that idn2_free is equivalent to free.  */\n      *result = ptr;\n      return 0;\n    }\n  else if (ret == IDN2_MALLOC)\n    return EAI_MEMORY;\n  else\n    return EAI_IDN_ENCODE;\n}",
    "inet6_opt_init(void *, socklen_t)": "int\ninet6_opt_init (void *extbuf, socklen_t extlen)\n{\n  if (extbuf != NULL)\n    {\n      if (extlen <= 0 || (extlen % 8) != 0 || extlen > 256 * 8)\n\treturn -1;\n\n      /* Fill in the length in units of 8 octets.  */\n      struct ip6_hbh *extp = (struct ip6_hbh *) extbuf;\n\n      /* RFC 2460 requires that the header extension length is the\n\t length of the option header in 8-byte units, not including\n\t the first 8 bytes.  Hence we have to subtract one.  */\n      extp->ip6h_len = extlen / 8 - 1;\n    }\n\n  return sizeof (struct ip6_hbh);\n}",
    "inet6_opt_append(void *, socklen_t, int, uint8_t, socklen_t, uint8_t, void **)": "int\ninet6_opt_append (void *extbuf, socklen_t extlen, int offset, uint8_t type,\n\t\t  socklen_t len, uint8_t align, void **databufp)\n{\n  /* Check minimum offset.  */\n  if (offset < sizeof (struct ip6_hbh))\n    return -1;\n\n  /* One cannot add padding options.  */\n  if (type == IP6OPT_PAD1 || type == IP6OPT_PADN)\n    return -1;\n\n  /* The option length must fit in one octet.  */\n  if (len > 255)\n    return -1;\n\n  /* The alignment can only by 1, 2, 4, or 8 and must not exceed the\n     option length.  */\n  if (align == 0 || align > 8 || (align & (align - 1)) != 0 || align > len)\n    return -1;\n\n  /* Determine the needed padding for alignment.  Following the\n     current content of the buffer we have the is the IPv6 option type\n     and length, followed immediately by the data.  The data has the\n     alignment constraints.  Therefore padding must be inserted in the\n     form of padding options before the new option. */\n  int data_offset = offset + sizeof (struct ip6_opt);\n  int npad = (align - data_offset % align) & (align - 1);\n\n  if (extbuf != NULL)\n    {\n      /* Now we can check whether the buffer is large enough.  */\n      if (data_offset + npad + len > extlen)\n\treturn -1;\n\n      add_padding (extbuf, offset, npad);\n\n      offset += npad;\n\n      /* Now prepare the option itself.  */\n      struct ip6_opt *opt = (struct ip6_opt *) ((uint8_t *) extbuf + offset);\n\n      opt->ip6o_type = type;\n      opt->ip6o_len = len;\n\n      *databufp = opt + 1;\n    }\n  else\n    offset += npad;\n\n  return offset + sizeof (struct ip6_opt) + len;\n}",
    "inet6_opt_finish(void *, socklen_t, int)": "int\ninet6_opt_finish (void *extbuf, socklen_t extlen, int offset)\n{\n  /* Check minimum offset.  */\n  if (offset < sizeof (struct ip6_hbh))\n    return -1;\n\n  /* Required padding at the end.  */\n  int npad = (8 - (offset & 7)) & 7;\n\n  if (extbuf != NULL)\n    {\n      /* Make sure the buffer is large enough.  */\n      if (offset + npad > extlen)\n\treturn -1;\n\n      add_padding (extbuf, offset, npad);\n    }\n\n  return offset + npad;\n}",
    "inet6_opt_set_val(void *, int, void *, socklen_t)": "int\ninet6_opt_set_val (void *databuf, int offset, void *val, socklen_t vallen)\n{\n  memcpy ((uint8_t *) databuf + offset, val, vallen);\n\n  return offset + vallen;\n}",
    "inet6_opt_next(void *, socklen_t, int, uint8_t *, socklen_t *, void **)": "int\ninet6_opt_next (void *extbuf, socklen_t extlen, int offset, uint8_t *typep,\n\t\tsocklen_t *lenp, void **databufp)\n{\n  if (offset == 0)\n    offset = sizeof (struct ip6_hbh);\n  else if (offset < sizeof (struct ip6_hbh))\n    return -1;\n\n  while (offset < extlen)\n    {\n      struct ip6_opt *opt = (struct ip6_opt *) ((uint8_t *) extbuf + offset);\n\n      if (opt->ip6o_type == IP6OPT_PAD1)\n\t/* Single byte padding.  */\n\t++offset;\n      else if (opt->ip6o_type == IP6OPT_PADN)\n\toffset += sizeof (struct ip6_opt) + opt->ip6o_len;\n      else\n\t{\n\t  /* Check whether the option is valid.  */\n\t  offset += sizeof (struct ip6_opt) + opt->ip6o_len;\n\t  if (offset > extlen)\n\t    return -1;\n\n\t  *typep = opt->ip6o_type;\n\t  *lenp = opt->ip6o_len;\n\t  *databufp = opt + 1;\n\t  return offset;\n\t}\n    }\n\n  return -1;\n}",
    "inet6_opt_find(void *, socklen_t, int, uint8_t, socklen_t *, void **)": "int\ninet6_opt_find (void *extbuf, socklen_t extlen, int offset, uint8_t type,\n\t\tsocklen_t *lenp, void **databufp)\n{\n  if (offset == 0)\n    offset = sizeof (struct ip6_hbh);\n  else if (offset < sizeof (struct ip6_hbh))\n    return -1;\n\n  while (offset < extlen)\n    {\n      struct ip6_opt *opt = (struct ip6_opt *) ((uint8_t *) extbuf + offset);\n\n      if (opt->ip6o_type == IP6OPT_PAD1)\n\t{\n\t  /* Single byte padding.  */\n\t  ++offset;\n\t  if (type == IP6OPT_PAD1)\n\t    {\n\t      *lenp = 0;\n\t      *databufp = (uint8_t *) extbuf + offset;\n\t      return offset;\n\t    }\n\t}\n      else if (opt->ip6o_type != type)\n\toffset += sizeof (struct ip6_opt) + opt->ip6o_len;\n      else\n\t{\n\t  /* Check whether the option is valid.  */\n\t  offset += sizeof (struct ip6_opt) + opt->ip6o_len;\n\t  if (offset > extlen)\n\t    return -1;\n\n\t  *lenp = opt->ip6o_len;\n\t  *databufp = opt + 1;\n\t  return offset;\n\t}\n    }\n\n  return -1;\n}",
    "inet6_opt_get_val(void *, int, void *, socklen_t)": "int\ninet6_opt_get_val (void *databuf, int offset, void *val, socklen_t vallen)\n{\n  memcpy (val, (uint8_t *) databuf + offset, vallen);\n\n  return offset + vallen;\n}",
    "inet6_option_space(int)": "int\ninet6_option_space (int nbytes)\n{\n  /* Add room for the extension header.  */\n  nbytes += sizeof (struct ip6_ext);\n\n  return CMSG_SPACE (roundup (nbytes, 8));\n}",
    "inet6_option_init(void *, struct cmsghdr **, int)": "int\ninet6_option_init (void *bp, struct cmsghdr **cmsgp, int type)\n{\n  /* Only Hop-by-Hop or Destination options allowed.  */\n  if (type != IPV6_HOPOPTS && type != IPV6_DSTOPTS)\n    return -1;\n\n  /* BP is a pointer to the previously allocated space.  */\n  struct cmsghdr *newp = (struct cmsghdr *) bp;\n\n  /* Initialize the message header.\n\n     Length: No data yet, only the cmsghdr struct.  */\n  newp->cmsg_len = CMSG_LEN (0);\n  /* Originating protocol: obviously IPv6.  */\n  newp->cmsg_level = IPPROTO_IPV6;\n  /* Message type.  */\n  newp->cmsg_type = type;\n\n  /* Pass up the result.  */\n  *cmsgp = newp;\n\n  return 0;\n}",
    "inet6_option_append(struct cmsghdr *, const uint8_t *, int, int)": "int\ninet6_option_append (struct cmsghdr *cmsg, const uint8_t *typep, int multx,\n\t\t     int plusy)\n{\n  /* typep is a pointer to the 8-bit option type.  It is assumed that this\n     field is immediately followed by the 8-bit option data length field,\n     which is then followed immediately by the option data.\n\n     The option types IP6OPT_PAD1 and IP6OPT_PADN also must be handled.  */\n  int len = typep[0] == IP6OPT_PAD1 ? 1 : typep[1] + 2;\n\n  /* Get the pointer to the space in the message.  */\n  uint8_t *ptr = option_alloc (cmsg, len, multx, plusy);\n  if (ptr == NULL)\n    /* Some problem with the parameters.  */\n    return -1;\n\n  /* Copy the content.  */\n  memcpy (ptr, typep, len);\n\n  return 0;\n}",
    "inet6_option_alloc(struct cmsghdr *, int, int, int)": "uint8_t *\ninet6_option_alloc (struct cmsghdr *cmsg, int datalen, int multx, int plusy)\n{\n  return option_alloc (cmsg, datalen, multx, plusy);\n}",
    "inet6_option_next(const struct cmsghdr *, uint8_t **)": "int\ninet6_option_next (const struct cmsghdr *cmsg, uint8_t **tptrp)\n{\n  /* Make sure it is an option of the right type.  */\n  if (cmsg->cmsg_level != IPPROTO_IPV6\n      || (cmsg->cmsg_type != IPV6_HOPOPTS && cmsg->cmsg_type != IPV6_DSTOPTS))\n    return -1;\n\n  /* Pointer to the extension header.  We only compute the address, we\n     don't access anything yet.  */\n  const struct ip6_ext *ip6e = (const struct ip6_ext *) CMSG_DATA (cmsg);\n\n  /* Make sure the message is long enough.  */\n  if (cmsg->cmsg_len < CMSG_LEN (sizeof (struct ip6_ext))\n      /* Now we can access the extension header.  */\n      || cmsg->cmsg_len < CMSG_LEN ((ip6e->ip6e_len + 1) * 8))\n    /* Too small.  */\n    return -1;\n\n  /* Determine the address of the byte past the message.  */\n  const uint8_t *endp = CMSG_DATA (cmsg) + (ip6e->ip6e_len + 1) * 8;\n\n  const uint8_t *result;\n  if (*tptrp == NULL)\n    /* This is the first call, return the first option if there is one.  */\n    result = (const uint8_t *) (ip6e + 1);\n  else\n    {\n      /* Make sure *TPTRP points to a beginning of a new option in\n\t the message.  The upper limit is checked in get_opt_end.  */\n      if (*tptrp < (const uint8_t *) (ip6e + 1))\n\treturn -1;\n\n      /* Get the beginning of the next option.  */\n      if (get_opt_end (&result, *tptrp, endp) != 0)\n\treturn -1;\n    }\n\n  /* We know where the next option starts.  */\n  *tptrp = (uint8_t *) result;\n\n  /* Check the option is fully represented in the message.  */\n  return get_opt_end (&result, result, endp);\n}",
    "inet6_option_find(const struct cmsghdr *, uint8_t **, int)": "int\ninet6_option_find (const struct cmsghdr *cmsg, uint8_t **tptrp, int type)\n{\n  /* Make sure it is an option of the right type.  */\n  if (cmsg->cmsg_level != IPPROTO_IPV6\n      || (cmsg->cmsg_type != IPV6_HOPOPTS && cmsg->cmsg_type != IPV6_DSTOPTS))\n    return -1;\n\n  /* Pointer to the extension header.  We only compute the address, we\n     don't access anything yet.  */\n  const struct ip6_ext *ip6e = (const struct ip6_ext *) CMSG_DATA (cmsg);\n\n  /* Make sure the message is long enough.  */\n  if (cmsg->cmsg_len < CMSG_LEN (sizeof (struct ip6_ext))\n      /* Now we can access the extension header.  */\n      || cmsg->cmsg_len < CMSG_LEN ((ip6e->ip6e_len + 1) * 8))\n    /* Too small.  */\n    return -1;\n\n  /* Determine the address of the byte past the message.  */\n  const uint8_t *endp = CMSG_DATA (cmsg) + (ip6e->ip6e_len + 1) * 8;\n\n  const uint8_t *next;\n  if (*tptrp == NULL)\n    /* This is the first call, return the first option if there is one.  */\n    next = (const uint8_t *) (ip6e + 1);\n  else\n    {\n      /* Make sure *TPTRP points to a beginning of a new option in\n\t the message.  The upper limit is checked in get_opt_end.  */\n      if (*tptrp < (const uint8_t *) (ip6e + 1))\n\treturn -1;\n\n      /* Get the beginning of the next option.  */\n      if (get_opt_end (&next, *tptrp, endp) != 0)\n\treturn -1;\n    }\n\n  /* Now search for the appropriate typed entry.  */\n  const uint8_t *result;\n  do\n    {\n      result = next;\n\n      /* Get the end of this entry.  */\n      if (get_opt_end (&next, result, endp) != 0)\n\treturn -1;\n    }\n  while (*result != type);\n\n  /* We know where the next option starts.  */\n  *tptrp = (uint8_t *) result;\n\n  /* Success.  */\n  return 0;\n}",
    "inet6_rth_space(int, int)": "socklen_t\ninet6_rth_space (int type, int segments)\n{\n  switch (type)\n    {\n    case IPV6_RTHDR_TYPE_0:\n      if (segments < 0 || segments > 127)\n\treturn 0;\n\n      return sizeof (struct ip6_rthdr0) + segments * sizeof (struct in6_addr);\n    }\n\n  return 0;\n}",
    "inet6_rth_init(void *, socklen_t, int, int)": "void *\ninet6_rth_init (void *bp, socklen_t bp_len, int type, int segments)\n{\n  struct ip6_rthdr *rthdr = (struct ip6_rthdr *) bp;\n\n  switch (type)\n    {\n    case IPV6_RTHDR_TYPE_0:\n      /* Make sure the parameters are valid and the buffer is large enough.  */\n      if (segments < 0 || segments > 127)\n\tbreak;\n\n      socklen_t len = (sizeof (struct ip6_rthdr0)\n\t\t       + segments * sizeof (struct in6_addr));\n      if (len > bp_len)\n\tbreak;\n\n      /* Some implementations seem to initialize the whole memory area.  */\n      memset (bp, '\\0', len);\n\n      /* Length in units of 8 octets.  */\n      rthdr->ip6r_len = segments * sizeof (struct in6_addr) / 8;\n      rthdr->ip6r_type = IPV6_RTHDR_TYPE_0;\n      return bp;\n    }\n\n  return NULL;\n}",
    "inet6_rth_add(void *, const struct in6_addr *)": "int\ninet6_rth_add (void *bp, const struct in6_addr *addr)\n{\n  struct ip6_rthdr *rthdr = (struct ip6_rthdr *) bp;\n\n  switch (rthdr->ip6r_type)\n    {\n      struct ip6_rthdr0 *rthdr0;\n    case IPV6_RTHDR_TYPE_0:\n      rthdr0 = (struct ip6_rthdr0 *) rthdr;\n      if (rthdr0->ip6r0_len * 8 / sizeof (struct in6_addr)\n\t  - rthdr0->ip6r0_segleft < 1)\n        return -1;\n\n      memcpy (&rthdr0->ip6r0_addr[rthdr0->ip6r0_segleft++],\n\t      addr, sizeof (struct in6_addr));\n\n      return 0;\n    }\n\n  return -1;\n}",
    "inet6_rth_reverse(const void *, void *)": "int\ninet6_rth_reverse (const void *in, void *out)\n{\n  struct ip6_rthdr *in_rthdr = (struct ip6_rthdr *) in;\n\n  switch (in_rthdr->ip6r_type)\n    {\n      struct ip6_rthdr0 *in_rthdr0;\n      struct ip6_rthdr0 *out_rthdr0;\n    case IPV6_RTHDR_TYPE_0:\n      in_rthdr0 = (struct ip6_rthdr0 *) in;\n      out_rthdr0 = (struct ip6_rthdr0 *) out;\n\n      /* Copy header, not the addresses.  The memory regions can overlap.  */\n      memmove (out_rthdr0, in_rthdr0, sizeof (struct ip6_rthdr0));\n\n      int total = in_rthdr0->ip6r0_len * 8 / sizeof (struct in6_addr);\n      for (int i = 0; i < total / 2; ++i)\n\t{\n\t  /* Remember, IN_RTHDR0 and OUT_RTHDR0 might overlap.  */\n\t  struct in6_addr temp = in_rthdr0->ip6r0_addr[i];\n\t  out_rthdr0->ip6r0_addr[i] = in_rthdr0->ip6r0_addr[total - 1 - i];\n\t  out_rthdr0->ip6r0_addr[total - 1 - i] = temp;\n\t}\n      if (total % 2 != 0 && in != out)\n\tout_rthdr0->ip6r0_addr[total / 2] = in_rthdr0->ip6r0_addr[total / 2];\n\n      out_rthdr0->ip6r0_segleft = total;\n\n      return 0;\n    }\n\n  return -1;\n}",
    "inet6_rth_segments(const void *)": "int\ninet6_rth_segments (const void *bp)\n{\n  struct ip6_rthdr *rthdr = (struct ip6_rthdr *) bp;\n\n  switch (rthdr->ip6r_type)\n    {\n    case IPV6_RTHDR_TYPE_0:\n\n      return rthdr->ip6r_len * 8 / sizeof (struct in6_addr);\n    }\n\n  return -1;\n}",
    "inet6_rth_getaddr(const void *, int)": "struct in6_addr *\ninet6_rth_getaddr (const void *bp, int index)\n{\n  struct ip6_rthdr *rthdr = (struct ip6_rthdr *) bp;\n\n  switch (rthdr->ip6r_type)\n    {\n       struct ip6_rthdr0 *rthdr0;\n    case IPV6_RTHDR_TYPE_0:\n      rthdr0 = (struct ip6_rthdr0 *) rthdr;\n\n      if (index >= rthdr0->ip6r0_len * 8 / sizeof (struct in6_addr))\n\tbreak;\n\n      return &rthdr0->ip6r0_addr[index];\n    }\n\n  return NULL;\n}",
    "__inet6_scopeid_pton(const struct in6_addr *, const char *, uint32_t *)": "int\n__inet6_scopeid_pton (const struct in6_addr *address, const char *scope,\n                      uint32_t *result)\n{\n  if (IN6_IS_ADDR_LINKLOCAL (address)\n      || IN6_IS_ADDR_MC_NODELOCAL (address)\n      || IN6_IS_ADDR_MC_LINKLOCAL (address))\n    {\n      uint32_t number = __if_nametoindex (scope);\n      if (number != 0)\n        {\n          *result = number;\n          return 0;\n        }\n    }\n\n  if (isdigit_l (scope[0], _nl_C_locobj_ptr))\n    {\n      char *end;\n      unsigned long long number\n        = ____strtoull_l_internal (scope, &end, /*base */ 10, /* group */ 0,\n                                   /* bin_cst */ false, _nl_C_locobj_ptr);\n      if (*end == '\\0' && number <= UINT32_MAX)\n        {\n          *result = number;\n          return 0;\n        }\n    }\n\n  __set_errno (EINVAL);\n  return -1;\n}",
    "inet_lnaof(struct in_addr)": "in_addr_t\ninet_lnaof (struct in_addr in)\n{\n\tuint32_t i = ntohl(in.s_addr);\n\n\tif (IN_CLASSA(i))\n\t\treturn ((i)&IN_CLASSA_HOST);\n\telse if (IN_CLASSB(i))\n\t\treturn ((i)&IN_CLASSB_HOST);\n\telse\n\t\treturn ((i)&IN_CLASSC_HOST);\n}",
    "inet_netof(struct in_addr)": "in_addr_t\ninet_netof (struct in_addr in)\n{\n\tuint32_t i = ntohl(in.s_addr);\n\n\tif (IN_CLASSA(i))\n\t\treturn (((i)&IN_CLASSA_NET) >> IN_CLASSA_NSHIFT);\n\telse if (IN_CLASSB(i))\n\t\treturn (((i)&IN_CLASSB_NET) >> IN_CLASSB_NSHIFT);\n\telse\n\t\treturn (((i)&IN_CLASSC_NET) >> IN_CLASSC_NSHIFT);\n}",
    "inet_ntoa(struct in_addr)": "char *\ninet_ntoa (struct in_addr in)\n{\n  unsigned char *bytes = (unsigned char *) &in;\n  __snprintf (buffer, sizeof (buffer), \"%d.%d.%d.%d\",\n\t      bytes[0], bytes[1], bytes[2], bytes[3]);\n\n  return buffer;\n}",
    "rresvport_af(int *, sa_family_t)": "int\nrresvport_af (int *alport, sa_family_t family)\n{\n\tunion {\n\t\tstruct sockaddr generic;\n\t\tstruct sockaddr_in in;\n\t\tstruct sockaddr_in6 in6;\n\t} ss;\n\tint s;\n\tsize_t len;\n\tuint16_t *sport;\n\n\tswitch(family){\n\tcase AF_INET:\n\t\tlen = sizeof(struct sockaddr_in);\n\t\tsport = &ss.in.sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tlen = sizeof(struct sockaddr_in6);\n\t\tsport = &ss.in6.sin6_port;\n\t\tbreak;\n\tdefault:\n\t\t__set_errno (EAFNOSUPPORT);\n\t\treturn -1;\n\t}\n\t/* NB: No SOCK_CLOEXEC for backwards compatibility.  */\n\ts = __socket(family, SOCK_STREAM, 0);\n\tif (s < 0)\n\t\treturn -1;\n\n\tmemset (&ss, '\\0', sizeof(ss));\n#ifdef SALEN\n\tss.generic.__ss_len = len;\n#endif\n\tss.generic.sa_family = family;\n\n\t/* Ignore invalid values.  */\n\tif (*alport < IPPORT_RESERVED / 2)\n\t\t*alport = IPPORT_RESERVED / 2;\n\telse if (*alport >= IPPORT_RESERVED)\n\t\t*alport = IPPORT_RESERVED - 1;\n\n\tint start = *alport;\n\tdo {\n\t\t*sport = htons((uint16_t) *alport);\n\t\tif (__bind(s, &ss.generic, len) >= 0)\n\t\t\treturn s;\n\t\tif (errno != EADDRINUSE) {\n\t\t\t(void)__close(s);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((*alport)-- == IPPORT_RESERVED/2)\n\t\t\t*alport = IPPORT_RESERVED - 1;\n\t} while (*alport != start);\n\t(void)__close(s);\n\t__set_errno (EAGAIN);\n\treturn -1;\n}",
    "ruserok_af(const char *, int, const char *, const char *, sa_family_t)": "int\nruserok_af (const char *rhost, int superuser, const char *ruser,\n\t    const char *luser, sa_family_t af)\n{\n\tstruct addrinfo hints, *res, *res0;\n\tint gai;\n\tint ret;\n\n\tmemset (&hints, '\\0', sizeof(hints));\n\thints.ai_family = af;\n\tgai = getaddrinfo(rhost, NULL, &hints, &res0);\n\tif (gai)\n\t\treturn -1;\n\tret = -1;\n\tfor (res=res0; res; res=res->ai_next)\n\t\tif (ruserok2_sa(res->ai_addr, res->ai_addrlen,\n\t\t\t\tsuperuser, ruser, luser, rhost) == 0){\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\tfreeaddrinfo(res0);\n\treturn (ret);\n}",
    "iruserok_af(const void *, int, const char *, const char *, sa_family_t)": "int\niruserok_af (const void *raddr, int superuser, const char *ruser,\n\t     const char *luser, sa_family_t af)\n{\n  union {\n    struct sockaddr generic;\n    struct sockaddr_in in;\n    struct sockaddr_in6 in6;\n  } ra;\n  size_t ralen;\n\n  memset (&ra, '\\0', sizeof(ra));\n  switch (af){\n  case AF_INET:\n    ra.in.sin_family = AF_INET;\n    memcpy (&ra.in.sin_addr, raddr, sizeof(struct in_addr));\n    ralen = sizeof(struct sockaddr_in);\n    break;\n  case AF_INET6:\n    ra.in6.sin6_family = AF_INET6;\n    memcpy (&ra.in6.sin6_addr, raddr, sizeof(struct in6_addr));\n    ralen = sizeof(struct sockaddr_in6);\n    break;\n  default:\n    return 0;\n  }\n  return ruserok_sa (&ra.generic, ralen, superuser, ruser, luser);\n}",
    "rexec_af(char **, int, const char *, const char *, const char *, int *, sa_family_t)": "int\nrexec_af (char **ahost, int rport, const char *name, const char *pass,\n\t  const char *cmd, int *fd2p, sa_family_t af)\n{\n\tstruct sockaddr_storage from;\n\tstruct addrinfo hints, *res0;\n\tconst char *orig_name = name;\n\tconst char *orig_pass = pass;\n\tu_short port = 0;\n\tint s, timo = 1, s3;\n\tchar c;\n\tint gai;\n\tchar servbuff[NI_MAXSERV];\n\n\t__snprintf(servbuff, sizeof(servbuff), \"%d\", ntohs(rport));\n\tservbuff[sizeof(servbuff) - 1] = '\\0';\n\n\tmemset(&hints, '\\0', sizeof(hints));\n\thints.ai_family = af;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_CANONNAME;\n\tgai = getaddrinfo(*ahost, servbuff, &hints, &res0);\n\tif (gai){\n\t\t/* XXX: set errno? */\n\t\treturn -1;\n\t}\n\n\tif (res0->ai_canonname){\n\t\tfree (ahostbuf);\n\t\tahostbuf = __strdup (res0->ai_canonname);\n\t\tif (ahostbuf == NULL) {\n\t\t\tperror (\"rexec: strdup\");\n\t\t\tgoto bad2;\n\t\t}\n\t\t*ahost = ahostbuf;\n\t} else {\n\t\t*ahost = NULL;\n\t\t__set_errno (ENOENT);\n\t\tgoto bad2;\n\t}\n\truserpass(res0->ai_canonname, &name, &pass);\nretry:\n\t/* NB: No SOCK_CLOEXEC for backwards compatibility.  */\n\ts = __socket(res0->ai_family, res0->ai_socktype, 0);\n\tif (s < 0) {\n\t\tperror(\"rexec: socket\");\n\t\tgoto bad2;\n\t}\n\tif (__connect(s, res0->ai_addr, res0->ai_addrlen) < 0) {\n\t\tif (errno == ECONNREFUSED && timo <= 16) {\n\t\t\t(void) __close(s);\n\t\t\t__sleep(timo);\n\t\t\ttimo *= 2;\n\t\t\tgoto retry;\n\t\t}\n\t\tperror(res0->ai_canonname);\n\t\tgoto bad;\n\t}\n\tif (fd2p == 0) {\n\t\t(void) __write(s, \"\", 1);\n\t\tport = 0;\n\t} else {\n\t\tchar num[32];\n\t\tint s2;\n\t\tunion\n\t\t{\n\t\t  struct sockaddr_storage ss;\n\t\t  struct sockaddr sa;\n\t\t} sa2;\n\t\tsocklen_t sa2len;\n\n\t\ts2 = __socket(res0->ai_family, res0->ai_socktype, 0);\n\t\tif (s2 < 0)\n\t\t\tgoto bad;\n\n\t\t__listen(s2, 1);\n\t\tsa2len = sizeof (sa2);\n\t\tif (__getsockname(s2, &sa2.sa, &sa2len) < 0) {\n\t\t\tperror(\"getsockname\");\n\t\t\t(void) __close(s2);\n\t\t\tgoto bad;\n\t\t} else if (sa2len != SA_LEN(&sa2.sa)) {\n\t\t\t__set_errno(EINVAL);\n\t\t\t(void) __close(s2);\n\t\t\tgoto bad;\n\t\t}\n\t\tport = 0;\n\t\tif (!getnameinfo(&sa2.sa, sa2len,\n\t\t\t\t NULL, 0, servbuff, sizeof(servbuff),\n\t\t\t\t NI_NUMERICSERV))\n\t\t\tport = strtol(servbuff, NULL, 10);\n\t\t(void) sprintf(num, \"%u\", port);\n\t\t(void) __write(s, num, strlen(num)+1);\n\t\t{ socklen_t len = sizeof (from);\n\t\t  s3 = TEMP_FAILURE_RETRY (accept(s2, (struct sockaddr *)&from,\n\t\t\t\t\t\t  &len));\n\t\t  __close(s2);\n\t\t  if (s3 < 0) {\n\t\t\tperror(\"accept\");\n\t\t\tport = 0;\n\t\t\tgoto bad;\n\t\t  }\n\t\t}\n\t\t*fd2p = s3;\n\t}\n\n\tstruct iovec iov[3] =\n\t  {\n\t    [0] = { .iov_base = (void *) name, .iov_len = strlen (name) + 1 },\n\t    /* should public key encrypt the password here */\n\t    [1] = { .iov_base = (void *) pass, .iov_len = strlen (pass) + 1 },\n\t    [2] = { .iov_base = (void *) cmd, .iov_len = strlen (cmd) + 1 }\n\t  };\n\t(void) TEMP_FAILURE_RETRY (__writev (s, iov, 3));\n\n\t/* We don't need the memory allocated for the name and the password\n\t   in ruserpass anymore.  */\n\tif (name != orig_name)\n\t  free ((char *) name);\n\tif (pass != orig_pass)\n\t  free ((char *) pass);\n\n\tif (__read(s, &c, 1) != 1) {\n\t\tperror(*ahost);\n\t\tgoto bad;\n\t}\n\tif (c != 0) {\n\t\twhile (__read(s, &c, 1) == 1) {\n\t\t\t(void) __write(2, &c, 1);\n\t\t\tif (c == '\\n')\n\t\t\t\tbreak;\n\t\t}\n\t\tgoto bad;\n\t}\n\tfreeaddrinfo(res0);\n\treturn (s);\nbad:\n\tif (port)\n\t\t(void) __close(*fd2p);\n\t(void) __close(s);\nbad2:\n\tfreeaddrinfo(res0);\n\treturn (-1);\n}",
    "ruserpass(const char *, const char **, const char **)": "int\nruserpass (const char *host, const char **aname, const char **apass)\n{\n\tchar *hdir, *buf, *tmp;\n\tchar myname[1024], *mydomain;\n\tint t, usedefault = 0;\n\tstruct __stat64_t64 stb;\n\n\thdir = __libc_secure_getenv(\"HOME\");\n\tif (hdir == NULL) {\n\t\t/* If we can't get HOME, fail instead of trying \".\",\n\t\t   which is no improvement. This really should call\n\t\t   getpwuid(getuid()).  */\n\t\t/*hdir = \".\";*/\n\t\treturn -1;\n\t}\n\n\tbuf = alloca (strlen (hdir) + 8);\n\n\t__stpcpy (__stpcpy (buf, hdir), \"/.netrc\");\n\tcfile = fopen(buf, \"rce\");\n\tif (cfile == NULL) {\n\t\tif (errno != ENOENT)\n\t\t\twarn(\"%s\", buf);\n\t\treturn (0);\n\t}\n\t/* No threads use this stream.  */\n\t__fsetlocking (cfile, FSETLOCKING_BYCALLER);\n\tif (__gethostname(myname, sizeof(myname)) < 0)\n\t\tmyname[0] = '\\0';\n\tmydomain = __strchrnul(myname, '.');\nnext:\n\twhile ((t = token())) switch(t) {\n\n\tcase DEFAULT:\n\t\tusedefault = 1;\n\t\t/* FALL THROUGH */\n\n\tcase MACHINE:\n\t\tif (!usedefault) {\n\t\t\tif (token() != ID)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Allow match either for user's input host name\n\t\t\t * or official hostname.  Also allow match of\n\t\t\t * incompletely-specified host in local domain.\n\t\t\t */\n\t\t\tif (__strcasecmp(host, tokval) == 0)\n\t\t\t\tgoto match;\n/*\t\t\tif (__strcasecmp(hostname, tokval) == 0)\n\t\t\t\tgoto match;\n\t\t\tif ((tmp = strchr(hostname, '.')) != NULL &&\n\t\t\t    __strcasecmp(tmp, mydomain) == 0 &&\n\t\t\t    __strncasecmp(hostname, tokval, tmp-hostname) == 0 &&\n\t\t\t    tokval[tmp - hostname] == '\\0')\n\t\t\t\tgoto match; */\n\t\t\tif ((tmp = strchr(host, '.')) != NULL &&\n\t\t\t    __strcasecmp(tmp, mydomain) == 0 &&\n\t\t\t    __strncasecmp(host, tokval, tmp - host) == 0 &&\n\t\t\t    tokval[tmp - host] == '\\0')\n\t\t\t\tgoto match;\n\t\t\tcontinue;\n\t\t}\n\tmatch:\n\t\twhile ((t = token()) && t != MACHINE && t != DEFAULT) switch(t) {\n\n\t\tcase LOGIN:\n\t\t\tif (token()) {\n\t\t\t\tif (*aname == 0) {\n\t\t\t\t  char *newp;\n\t\t\t\t  newp = malloc((unsigned) strlen(tokval) + 1);\n\t\t\t\t  if (newp == NULL)\n\t\t\t\t    {\n\t\t\t\t      warnx(_(\"out of memory\"));\n\t\t\t\t      goto bad;\n\t\t\t\t    }\n\t\t\t\t  *aname = strcpy(newp, tokval);\n\t\t\t\t} else {\n\t\t\t\t\tif (strcmp(*aname, tokval))\n\t\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PASSWD:\n\t\t\tif (strcmp(*aname, \"anonymous\") &&\n\t\t\t    __fstat64_time64(fileno(cfile), &stb) >= 0 &&\n\t\t\t    (stb.st_mode & 077) != 0) {\n\twarnx(_(\"Error: .netrc file is readable by others.\"));\n\twarnx(_(\"Remove 'password' line or make file unreadable by others.\"));\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (token() && *apass == 0) {\n\t\t\t\tchar *newp;\n\t\t\t\tnewp = malloc((unsigned) strlen(tokval) + 1);\n\t\t\t\tif (newp == NULL)\n\t\t\t\t  {\n\t\t\t\t    warnx(_(\"out of memory\"));\n\t\t\t\t    goto bad;\n\t\t\t\t  }\n\t\t\t\t*apass = strcpy(newp, tokval);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACCOUNT:\n\t\t\tbreak;\n\t\tcase MACDEF:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twarnx(_(\"Unknown .netrc keyword %s\"), tokval);\n\t\t\tbreak;\n\t\t}\n\t\tgoto done;\n\t}\ndone:\n\t(void) fclose(cfile);\n\treturn (0);\nbad:\n\t(void) fclose(cfile);\n\treturn (-1);\n}",
    "setipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t, uint32_t, const struct in_addr *)": "int\nsetipv4sourcefilter (int s, struct in_addr interface, struct in_addr group,\n\t\t     uint32_t fmode, uint32_t numsrc,\n\t\t     const struct in_addr *slist)\n{\n  /* We have to create an struct ip_msfilter object which we can pass\n     to the kernel.  */\n  size_t needed = IP_MSFILTER_SIZE (numsrc);\n\n  struct scratch_buffer buf;\n  scratch_buffer_init (&buf);\n  if (!scratch_buffer_set_array_size (&buf, 1, needed))\n    return -1;\n  struct ip_msfilter *imsf = buf.data;\n\n  imsf->imsf_multiaddr = group;\n  imsf->imsf_interface = interface;\n  imsf->imsf_fmode = fmode;\n  imsf->imsf_numsrc = numsrc;\n  memcpy (imsf->imsf_slist, slist, numsrc * sizeof (struct in_addr));\n\n  int result = __setsockopt (s, SOL_IP, IP_MSFILTER, imsf, needed);\n\n  scratch_buffer_free (&buf);\n\n  return result;\n}",
    "setsourcefilter(int, uint32_t, const struct sockaddr *, socklen_t, uint32_t, uint32_t, const struct sockaddr_storage *)": "int\nsetsourcefilter (int s, uint32_t interface, const struct sockaddr *group,\n\t\t socklen_t grouplen, uint32_t fmode, uint32_t numsrc,\n\t\t const struct sockaddr_storage *slist)\n{\n  /* We have to create an struct ip_msfilter object which we can pass\n     to the kernel.  */\n  size_t needed = GROUP_FILTER_SIZE (numsrc);\n\n  struct scratch_buffer buf;\n  scratch_buffer_init (&buf);\n  if (!scratch_buffer_set_array_size (&buf, 1, needed))\n    return -1;\n  struct group_filter *gf = buf.data;\n\n  gf->gf_interface = interface;\n  memcpy (&gf->gf_group, group, grouplen);\n  gf->gf_fmode = fmode;\n  gf->gf_numsrc = numsrc;\n  memcpy (gf->gf_slist, slist, numsrc * sizeof (struct sockaddr_storage));\n\n  /* We need to provide the appropriate socket level value.  */\n  int result;\n  int sol = __get_sol (group->sa_family, grouplen);\n  if (sol == -1)\n    {\n      __set_errno (EINVAL);\n      result = -1;\n    }\n  else\n    result = __setsockopt (s, sol, MCAST_MSFILTER, gf, needed);\n\n  scratch_buffer_free (&buf);\n\n  return result;\n}",
    "stpcpy(char *, const char *)": "static char *\nstpcpy (char *dest, const char *src)\n{\n  while ((*dest++ = *src++) != '\\0')\n    /* Do nothing. */ ;\n  return dest - 1;\n}",
    "mempcpy(void *, const void *, int)": "static void *\nmempcpy (void *dest, const void *src, size_t n)\n{\n  return (void *) ((char *) memcpy (dest, src, n) + n);\n}",
    "__close(int)": "int\n__close (int fd)\n{\n  return SYSCALL_CANCEL (close, fd);\n}",
    "copy_file_range(int, __off64_t *, int, __off64_t *, int, unsigned int)": "ssize_t\ncopy_file_range (int infd, __off64_t *pinoff,\n                 int outfd, __off64_t *poutoff,\n                 size_t length, unsigned int flags)\n{\n  return SYSCALL_CANCEL (copy_file_range, infd, pinoff, outfd, poutoff,\n                         length, flags);\n}",
    "creat(const char *, mode_t)": "int\ncreat (const char *file, mode_t mode)\n{\n  return __open (file, O_WRONLY|O_CREAT|O_TRUNC, mode);\n}",
    "creat64(const char *, mode_t)": "int\ncreat64 (const char *file, mode_t mode)\n{\n  return __open64 (file, O_WRONLY|O_CREAT|O_TRUNC, mode);\n}",
    "__dup2(int, int)": "int\n__dup2 (int fd, int fd2)\n{\n#ifdef __NR_dup2\n  return INLINE_SYSCALL_CALL (dup2, fd, fd2);\n#else\n  /* For the degenerate case, check if the fd is valid (by trying to\n     get the file status flags) and return it, or else return EBADF.  */\n  if (fd == fd2)\n    return __libc_fcntl (fd, F_GETFL, 0) < 0 ? -1 : fd;\n\n  return INLINE_SYSCALL_CALL (dup3, fd, fd2, 0);\n#endif\n}",
    "faccessat(int, const char *, int, int)": "int\nfaccessat (int fd, const char *file, int type, int flag)\n{\n  if (file == NULL || (flag & ~(AT_SYMLINK_NOFOLLOW | AT_EACCESS)) != 0\n      || (type & ~(R_OK|W_OK|X_OK|F_OK)) != 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (fd < 0 && fd != AT_FDCWD)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "fchmodat(int, const char *, mode_t, int)": "int\nfchmodat (int fd, const char *file, mode_t mode, int flag)\n{\n#if __ASSUME_FCHMODAT2\n  return INLINE_SYSCALL_CALL (fchmodat2, fd, file, mode, flag);\n#else\n  if (flag == 0)\n    return INLINE_SYSCALL_CALL (fchmodat, fd, file, mode);\n\n  int r = INLINE_SYSCALL_CALL (fchmodat2, fd, file, mode, flag);\n  if (r != 0 && errno == ENOSYS)\n    return fchmodat_fallback (fd, file, mode, flag);\n  return r;\n#endif\n}",
    "fchownat(int, const char *, uid_t, gid_t, int)": "int\nfchownat (int fd, const char *file, uid_t owner, gid_t group, int flag)\n{\n  if (file == NULL || (flag & ~AT_SYMLINK_NOFOLLOW) != 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (fd < 0 && fd != AT_FDCWD)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__fcntl(int, int, ...)": "int\n__fcntl (int fd, int cmd, ...)\n{\n  if (fd < 0)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__file_is_unchanged(const struct file_change_detection *, const struct file_change_detection *)": "bool\n__file_is_unchanged (const struct file_change_detection *left,\n                     const struct file_change_detection *right)\n{\n  if (left->size < 0 || right->size < 0)\n    /* Negative sizes are used as markers and never match.  */\n    return false;\n  else if (left->size == 0 && right->size == 0)\n    /* Both files are empty or do not exist, so they have the same\n       content, no matter what the other fields indicate.  */\n    return true;\n  else\n    return left->size == right->size\n      && left->ino == right->ino\n      && left->mtime.tv_sec == right->mtime.tv_sec\n      && left->mtime.tv_nsec == right->mtime.tv_nsec\n      && left->ctime.tv_sec == right->ctime.tv_sec\n      && left->ctime.tv_nsec == right->ctime.tv_nsec;\n}",
    "__fstat64(int, struct stat64 *)": "int\n__fstat64 (int fd, struct stat64 *buf)\n{\n  error_t err;\n\n  if (err = HURD_DPORT_USE (fd, __io_stat (port, buf)))\n    return __hurd_dfail (fd, err);\n\n  return 0;\n}",
    "fts_open(char *const *, int, int (*)(const FTSENT **, const FTSENT **))": "FTSOBJ *\nFTS_OPEN (char * const *argv, int options,\n\t  int (*compar) (const FTSENTRY **, const FTSENTRY **))\n{\n\tFTSOBJ *sp;\n\tFTSENTRY *p, *root;\n\tint nitems;\n\tFTSENTRY *parent = NULL;\n\tFTSENTRY *tmp;\n\n\t/* Options check. */\n\tif (options & ~FTS_OPTIONMASK) {\n\t\t__set_errno (EINVAL);\n\t\treturn (NULL);\n\t}\n\n\t/* Allocate/initialize the stream */\n\tif ((sp = malloc((u_int)sizeof(FTSOBJ))) == NULL)\n\t\treturn (NULL);\n\tmemset(sp, 0, sizeof(FTSOBJ));\n\tsp->fts_compar = (int (*) (const void *, const void *)) compar;\n\tsp->fts_options = options;\n\n\t/* Logical walks turn on NOCHDIR; symbolic links are too hard. */\n\tif (ISSET(FTS_LOGICAL))\n\t\tSET(FTS_NOCHDIR);\n\n\t/*\n\t * Start out with 1K of path space, and enough, in any case,\n\t * to hold the user's paths.\n\t */\n#ifndef MAXPATHLEN\n#define MAXPATHLEN 1024\n#endif\n\tsize_t maxarglen = fts_maxarglen(argv);\n\tif (fts_palloc(sp, MAX(maxarglen, MAXPATHLEN)))\n\t\tgoto mem1;\n\n\t/* Allocate/initialize root's parent. */\n\tif (*argv != NULL) {\n\t\tif ((parent = fts_alloc(sp, \"\", 0)) == NULL)\n\t\t\tgoto mem2;\n\t\tparent->fts_level = FTS_ROOTPARENTLEVEL;\n\t  }\n\n\t/* Allocate/initialize root(s). */\n\tfor (root = NULL, nitems = 0; *argv != NULL; ++argv, ++nitems) {\n\t\t/* Don't allow zero-length paths. */\n\t\tsize_t len = strlen(*argv);\n\t\tif (len == 0) {\n\t\t\t__set_errno (ENOENT);\n\t\t\tgoto mem3;\n\t\t}\n\n\t\tp = fts_alloc(sp, *argv, len);\n\t\tp->fts_level = FTS_ROOTLEVEL;\n\t\tp->fts_parent = parent;\n\t\tp->fts_accpath = p->fts_name;\n\t\tp->fts_info = fts_stat(sp, p, ISSET(FTS_COMFOLLOW));\n\n\t\t/* Command-line \".\" and \"..\" are real directories. */\n\t\tif (p->fts_info == FTS_DOT)\n\t\t\tp->fts_info = FTS_D;\n\n\t\t/*\n\t\t * If comparison routine supplied, traverse in sorted\n\t\t * order; otherwise traverse in the order specified.\n\t\t */\n\t\tif (compar) {\n\t\t\tp->fts_link = root;\n\t\t\troot = p;\n\t\t} else {\n\t\t\tp->fts_link = NULL;\n\t\t\tif (root == NULL)\n\t\t\t\ttmp = root = p;\n\t\t\telse {\n\t\t\t\ttmp->fts_link = p;\n\t\t\t\ttmp = p;\n\t\t\t}\n\t\t}\n\t}\n\tif (compar && nitems > 1)\n\t\troot = fts_sort(sp, root, nitems);\n\n\t/*\n\t * Allocate a dummy pointer and make fts_read think that we've just\n\t * finished the node before the root(s); set p->fts_info to FTS_INIT\n\t * so that everything about the \"current\" node is ignored.\n\t */\n\tif ((sp->fts_cur = fts_alloc(sp, \"\", 0)) == NULL)\n\t\tgoto mem3;\n\tsp->fts_cur->fts_link = root;\n\tsp->fts_cur->fts_info = FTS_INIT;\n\n\t/*\n\t * If using chdir(2), grab a file descriptor pointing to dot to ensure\n\t * that we can get back here; this could be avoided for some paths,\n\t * but almost certainly not worth the effort.  Slashes, symbolic links,\n\t * and \"..\" are all fairly nasty problems.  Note, if we can't get the\n\t * descriptor we run anyway, just more slowly.\n\t */\n\tif (!ISSET(FTS_NOCHDIR)\n\t    && (sp->fts_rfd = __open(\".\", O_RDONLY, 0)) < 0)\n\t\tSET(FTS_NOCHDIR);\n\n\treturn (sp);\n\nmem3:\tfts_lfree(root);\n\tfree(parent);\nmem2:\tfree(sp->fts_path);\nmem1:\tfree(sp);\n\treturn (NULL);\n}",
    "fts_close(FTS *)": "int\nFTS_CLOSE (FTSOBJ *sp)\n{\n\tFTSENTRY *freep, *p;\n\tint saved_errno;\n\n\t/*\n\t * This still works if we haven't read anything -- the dummy structure\n\t * points to the root list, so we step through to the end of the root\n\t * list which has a valid parent pointer.\n\t */\n\tif (sp->fts_cur) {\n\t\tfor (p = sp->fts_cur; p->fts_level >= FTS_ROOTLEVEL;) {\n\t\t\tfreep = p;\n\t\t\tp = p->fts_link != NULL ? p->fts_link : p->fts_parent;\n\t\t\tfree(freep);\n\t\t}\n\t\tfree(p);\n\t}\n\n\t/* Free up child linked list, sort array, path buffer. */\n\tif (sp->fts_child)\n\t\tfts_lfree(sp->fts_child);\n\tfree(sp->fts_array);\n\tfree(sp->fts_path);\n\n\t/* Return to original directory, save errno if necessary. */\n\tif (!ISSET(FTS_NOCHDIR)) {\n\t\tsaved_errno = __fchdir(sp->fts_rfd) ? errno : 0;\n\t\t(void)__close(sp->fts_rfd);\n\n\t\t/* Set errno and return. */\n\t\tif (saved_errno != 0) {\n\t\t\t/* Free up the stream pointer. */\n\t\t\tfree(sp);\n\t\t\t__set_errno (saved_errno);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t/* Free up the stream pointer. */\n\tfree(sp);\n\treturn (0);\n}",
    "fts_read(FTS *)": "FTSENTRY *\nFTS_READ (FTSOBJ *sp)\n{\n\tFTSENTRY *p, *tmp;\n\tint instr;\n\tchar *t;\n\tint saved_errno;\n\n\t/* If finished or unrecoverable error, return NULL. */\n\tif (sp->fts_cur == NULL || ISSET(FTS_STOP))\n\t\treturn (NULL);\n\n\t/* Set current node pointer. */\n\tp = sp->fts_cur;\n\n\t/* Save and zero out user instructions. */\n\tinstr = p->fts_instr;\n\tp->fts_instr = FTS_NOINSTR;\n\n\t/* Any type of file may be re-visited; re-stat and re-turn. */\n\tif (instr == FTS_AGAIN) {\n\t\tp->fts_info = fts_stat(sp, p, 0);\n\t\treturn (p);\n\t}\n\n\t/*\n\t * Following a symlink -- SLNONE test allows application to see\n\t * SLNONE and recover.  If indirecting through a symlink, have\n\t * keep a pointer to current location.  If unable to get that\n\t * pointer, follow fails.\n\t */\n\tif (instr == FTS_FOLLOW &&\n\t    (p->fts_info == FTS_SL || p->fts_info == FTS_SLNONE)) {\n\t\tp->fts_info = fts_stat(sp, p, 1);\n\t\tif (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n\t\t\tif ((p->fts_symfd = __open(\".\", O_RDONLY, 0)) < 0) {\n\t\t\t\tp->fts_errno = errno;\n\t\t\t\tp->fts_info = FTS_ERR;\n\t\t\t} else\n\t\t\t\tp->fts_flags |= FTS_SYMFOLLOW;\n\t\t}\n\t\treturn (p);\n\t}\n\n\t/* Directory in pre-order. */\n\tif (p->fts_info == FTS_D) {\n\t\t/* If skipped or crossed mount point, do post-order visit. */\n\t\tif (instr == FTS_SKIP ||\n\t\t    (ISSET(FTS_XDEV) && p->fts_dev != sp->fts_dev)) {\n\t\t\tif (p->fts_flags & FTS_SYMFOLLOW)\n\t\t\t\t(void)__close(p->fts_symfd);\n\t\t\tif (sp->fts_child) {\n\t\t\t\tfts_lfree(sp->fts_child);\n\t\t\t\tsp->fts_child = NULL;\n\t\t\t}\n\t\t\tp->fts_info = FTS_DP;\n\t\t\treturn (p);\n\t\t}\n\n\t\t/* Rebuild if only read the names and now traversing. */\n\t\tif (sp->fts_child != NULL && ISSET(FTS_NAMEONLY)) {\n\t\t\tCLR(FTS_NAMEONLY);\n\t\t\tfts_lfree(sp->fts_child);\n\t\t\tsp->fts_child = NULL;\n\t\t}\n\n\t\t/*\n\t\t * Cd to the subdirectory.\n\t\t *\n\t\t * If have already read and now fail to chdir, whack the list\n\t\t * to make the names come out right, and set the parent errno\n\t\t * so the application will eventually get an error condition.\n\t\t * Set the FTS_DONTCHDIR flag so that when we logically change\n\t\t * directories back to the parent we don't do a chdir.\n\t\t *\n\t\t * If haven't read do so.  If the read fails, fts_build sets\n\t\t * FTS_STOP or the fts_info field of the node.\n\t\t */\n\t\tif (sp->fts_child != NULL) {\n\t\t\tif (fts_safe_changedir(sp, p, -1, p->fts_accpath)) {\n\t\t\t\tp->fts_errno = errno;\n\t\t\t\tp->fts_flags |= FTS_DONTCHDIR;\n\t\t\t\tfor (p = sp->fts_child; p != NULL;\n\t\t\t\t     p = p->fts_link)\n\t\t\t\t\tp->fts_accpath =\n\t\t\t\t\t    p->fts_parent->fts_accpath;\n\t\t\t}\n\t\t} else if ((sp->fts_child = fts_build(sp, BREAD)) == NULL) {\n\t\t\tif (ISSET(FTS_STOP))\n\t\t\t\treturn (NULL);\n\t\t\treturn (p);\n\t\t}\n\t\tp = sp->fts_child;\n\t\tsp->fts_child = NULL;\n\t\tsp->fts_cur = p;\n\t\tgoto name;\n\t}\n\n\t/* Move to the next node on this level. */\nnext:\ttmp = p;\n\tif ((p = p->fts_link) != NULL) {\n\t\tsp->fts_cur = p;\n\t\tfree(tmp);\n\n\t\t/*\n\t\t * If reached the top, return to the original directory (or\n\t\t * the root of the tree), and load the paths for the next root.\n\t\t */\n\t\tif (p->fts_level == FTS_ROOTLEVEL) {\n\t\t\tif (FCHDIR(sp, sp->fts_rfd)) {\n\t\t\t\tSET(FTS_STOP);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tfts_load(sp, p);\n\t\t\treturn p;\n\t\t}\n\n\t\t/*\n\t\t * User may have called fts_set on the node.  If skipped,\n\t\t * ignore.  If followed, get a file descriptor so we can\n\t\t * get back if necessary.\n\t\t */\n\t\tif (p->fts_instr == FTS_SKIP)\n\t\t\tgoto next;\n\t\tif (p->fts_instr == FTS_FOLLOW) {\n\t\t\tp->fts_info = fts_stat(sp, p, 1);\n\t\t\tif (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n\t\t\t\tif ((p->fts_symfd =\n\t\t\t\t    __open(\".\", O_RDONLY, 0)) < 0) {\n\t\t\t\t\tp->fts_errno = errno;\n\t\t\t\t\tp->fts_info = FTS_ERR;\n\t\t\t\t} else\n\t\t\t\t\tp->fts_flags |= FTS_SYMFOLLOW;\n\t\t\t}\n\t\t\tp->fts_instr = FTS_NOINSTR;\n\t\t}\n\nname:\t\tt = sp->fts_path + NAPPEND(p->fts_parent);\n\t\t*t++ = '/';\n\t\tmemmove(t, p->fts_name, p->fts_namelen + 1);\n\t\treturn p;\n\t}\n\n\t/* Move up to the parent node. */\n\tp = tmp->fts_parent;\n\tsp->fts_cur = p;\n\tfree(tmp);\n\n\tif (p->fts_level == FTS_ROOTPARENTLEVEL) {\n\t\t/*\n\t\t * Done; free everything up and set errno to 0 so the user\n\t\t * can distinguish between error and EOF.\n\t\t */\n\t\tfree(p);\n\t\t__set_errno (0);\n\t\treturn (sp->fts_cur = NULL);\n\t}\n\n\t/* NUL terminate the pathname. */\n\tsp->fts_path[p->fts_pathlen] = '\\0';\n\n\t/*\n\t * Return to the parent directory.  If at a root node or came through\n\t * a symlink, go back through the file descriptor.  Otherwise, cd up\n\t * one directory.\n\t */\n\tif (p->fts_level == FTS_ROOTLEVEL) {\n\t\tif (FCHDIR(sp, sp->fts_rfd)) {\n\t\t\tSET(FTS_STOP);\n\t\t\treturn (NULL);\n\t\t}\n\t} else if (p->fts_flags & FTS_SYMFOLLOW) {\n\t\tif (FCHDIR(sp, p->fts_symfd)) {\n\t\t\tsaved_errno = errno;\n\t\t\t(void)__close(p->fts_symfd);\n\t\t\t__set_errno (saved_errno);\n\t\t\tSET(FTS_STOP);\n\t\t\treturn (NULL);\n\t\t}\n\t\t(void)__close(p->fts_symfd);\n\t} else if (!(p->fts_flags & FTS_DONTCHDIR) &&\n\t\t   fts_safe_changedir(sp, p->fts_parent, -1, \"..\")) {\n\t\tSET(FTS_STOP);\n\t\treturn (NULL);\n\t}\n\tp->fts_info = p->fts_errno ? FTS_ERR : FTS_DP;\n\treturn p;\n}",
    "fts_set(FTS *, FTSENT *, int)": "int\nFTS_SET (FTSOBJ *sp, FTSENTRY *p, int instr)\n{\n\tif (instr != 0 && instr != FTS_AGAIN && instr != FTS_FOLLOW &&\n\t    instr != FTS_NOINSTR && instr != FTS_SKIP) {\n\t\t__set_errno (EINVAL);\n\t\treturn (1);\n\t}\n\tp->fts_instr = instr;\n\treturn (0);\n}",
    "fts_children(FTS *, int)": "FTSENTRY *\nFTS_CHILDREN(FTSOBJ *sp, int instr)\n{\n\tFTSENTRY *p;\n\tint fd;\n\n\tif (instr != 0 && instr != FTS_NAMEONLY) {\n\t\t__set_errno (EINVAL);\n\t\treturn (NULL);\n\t}\n\n\t/* Set current node pointer. */\n\tp = sp->fts_cur;\n\n\t/*\n\t * Errno set to 0 so user can distinguish empty directory from\n\t * an error.\n\t */\n\t__set_errno (0);\n\n\t/* Fatal errors stop here. */\n\tif (ISSET(FTS_STOP))\n\t\treturn (NULL);\n\n\t/* Return logical hierarchy of user's arguments. */\n\tif (p->fts_info == FTS_INIT)\n\t\treturn (p->fts_link);\n\n\t/*\n\t * If not a directory being visited in pre-order, stop here.  Could\n\t * allow FTS_DNR, assuming the user has fixed the problem, but the\n\t * same effect is available with FTS_AGAIN.\n\t */\n\tif (p->fts_info != FTS_D /* && p->fts_info != FTS_DNR */)\n\t\treturn (NULL);\n\n\t/* Free up any previous child list. */\n\tif (sp->fts_child != NULL)\n\t\tfts_lfree(sp->fts_child);\n\n\tif (instr == FTS_NAMEONLY) {\n\t\tSET(FTS_NAMEONLY);\n\t\tinstr = BNAMES;\n\t} else\n\t\tinstr = BCHILD;\n\n\t/*\n\t * If using chdir on a relative path and called BEFORE fts_read does\n\t * its chdir to the root of a traversal, we can lose -- we need to\n\t * chdir into the subdirectory, and we don't know where the current\n\t * directory is, so we can't get back so that the upcoming chdir by\n\t * fts_read will work.\n\t */\n\tif (p->fts_level != FTS_ROOTLEVEL || p->fts_accpath[0] == '/' ||\n\t    ISSET(FTS_NOCHDIR))\n\t\treturn (sp->fts_child = fts_build(sp, instr));\n\n\tif ((fd = __open(\".\", O_RDONLY, 0)) < 0)\n\t\treturn (NULL);\n\tsp->fts_child = fts_build(sp, instr);\n\tif (__fchdir(fd))\n\t\treturn (NULL);\n\t(void)__close(fd);\n\treturn (sp->fts_child);\n}",
    "fts64_open(char *const *, int, int (*)(const int **, const int **))": "FTSOBJ *\nFTS_OPEN (char * const *argv, int options,\n\t  int (*compar) (const FTSENTRY **, const FTSENTRY **))\n{\n\tFTSOBJ *sp;\n\tFTSENTRY *p, *root;\n\tint nitems;\n\tFTSENTRY *parent = NULL;\n\tFTSENTRY *tmp;\n\n\t/* Options check. */\n\tif (options & ~FTS_OPTIONMASK) {\n\t\t__set_errno (EINVAL);\n\t\treturn (NULL);\n\t}\n\n\t/* Allocate/initialize the stream */\n\tif ((sp = malloc((u_int)sizeof(FTSOBJ))) == NULL)\n\t\treturn (NULL);\n\tmemset(sp, 0, sizeof(FTSOBJ));\n\tsp->fts_compar = (int (*) (const void *, const void *)) compar;\n\tsp->fts_options = options;\n\n\t/* Logical walks turn on NOCHDIR; symbolic links are too hard. */\n\tif (ISSET(FTS_LOGICAL))\n\t\tSET(FTS_NOCHDIR);\n\n\t/*\n\t * Start out with 1K of path space, and enough, in any case,\n\t * to hold the user's paths.\n\t */\n#ifndef MAXPATHLEN\n#define MAXPATHLEN 1024\n#endif\n\tsize_t maxarglen = fts_maxarglen(argv);\n\tif (fts_palloc(sp, MAX(maxarglen, MAXPATHLEN)))\n\t\tgoto mem1;\n\n\t/* Allocate/initialize root's parent. */\n\tif (*argv != NULL) {\n\t\tif ((parent = fts_alloc(sp, \"\", 0)) == NULL)\n\t\t\tgoto mem2;\n\t\tparent->fts_level = FTS_ROOTPARENTLEVEL;\n\t  }\n\n\t/* Allocate/initialize root(s). */\n\tfor (root = NULL, nitems = 0; *argv != NULL; ++argv, ++nitems) {\n\t\t/* Don't allow zero-length paths. */\n\t\tsize_t len = strlen(*argv);\n\t\tif (len == 0) {\n\t\t\t__set_errno (ENOENT);\n\t\t\tgoto mem3;\n\t\t}\n\n\t\tp = fts_alloc(sp, *argv, len);\n\t\tp->fts_level = FTS_ROOTLEVEL;\n\t\tp->fts_parent = parent;\n\t\tp->fts_accpath = p->fts_name;\n\t\tp->fts_info = fts_stat(sp, p, ISSET(FTS_COMFOLLOW));\n\n\t\t/* Command-line \".\" and \"..\" are real directories. */\n\t\tif (p->fts_info == FTS_DOT)\n\t\t\tp->fts_info = FTS_D;\n\n\t\t/*\n\t\t * If comparison routine supplied, traverse in sorted\n\t\t * order; otherwise traverse in the order specified.\n\t\t */\n\t\tif (compar) {\n\t\t\tp->fts_link = root;\n\t\t\troot = p;\n\t\t} else {\n\t\t\tp->fts_link = NULL;\n\t\t\tif (root == NULL)\n\t\t\t\ttmp = root = p;\n\t\t\telse {\n\t\t\t\ttmp->fts_link = p;\n\t\t\t\ttmp = p;\n\t\t\t}\n\t\t}\n\t}\n\tif (compar && nitems > 1)\n\t\troot = fts_sort(sp, root, nitems);\n\n\t/*\n\t * Allocate a dummy pointer and make fts_read think that we've just\n\t * finished the node before the root(s); set p->fts_info to FTS_INIT\n\t * so that everything about the \"current\" node is ignored.\n\t */\n\tif ((sp->fts_cur = fts_alloc(sp, \"\", 0)) == NULL)\n\t\tgoto mem3;\n\tsp->fts_cur->fts_link = root;\n\tsp->fts_cur->fts_info = FTS_INIT;\n\n\t/*\n\t * If using chdir(2), grab a file descriptor pointing to dot to ensure\n\t * that we can get back here; this could be avoided for some paths,\n\t * but almost certainly not worth the effort.  Slashes, symbolic links,\n\t * and \"..\" are all fairly nasty problems.  Note, if we can't get the\n\t * descriptor we run anyway, just more slowly.\n\t */\n\tif (!ISSET(FTS_NOCHDIR)\n\t    && (sp->fts_rfd = __open(\".\", O_RDONLY, 0)) < 0)\n\t\tSET(FTS_NOCHDIR);\n\n\treturn (sp);\n\nmem3:\tfts_lfree(root);\n\tfree(parent);\nmem2:\tfree(sp->fts_path);\nmem1:\tfree(sp);\n\treturn (NULL);\n}",
    "fts64_close(int *)": "int\nFTS_CLOSE (FTSOBJ *sp)\n{\n\tFTSENTRY *freep, *p;\n\tint saved_errno;\n\n\t/*\n\t * This still works if we haven't read anything -- the dummy structure\n\t * points to the root list, so we step through to the end of the root\n\t * list which has a valid parent pointer.\n\t */\n\tif (sp->fts_cur) {\n\t\tfor (p = sp->fts_cur; p->fts_level >= FTS_ROOTLEVEL;) {\n\t\t\tfreep = p;\n\t\t\tp = p->fts_link != NULL ? p->fts_link : p->fts_parent;\n\t\t\tfree(freep);\n\t\t}\n\t\tfree(p);\n\t}\n\n\t/* Free up child linked list, sort array, path buffer. */\n\tif (sp->fts_child)\n\t\tfts_lfree(sp->fts_child);\n\tfree(sp->fts_array);\n\tfree(sp->fts_path);\n\n\t/* Return to original directory, save errno if necessary. */\n\tif (!ISSET(FTS_NOCHDIR)) {\n\t\tsaved_errno = __fchdir(sp->fts_rfd) ? errno : 0;\n\t\t(void)__close(sp->fts_rfd);\n\n\t\t/* Set errno and return. */\n\t\tif (saved_errno != 0) {\n\t\t\t/* Free up the stream pointer. */\n\t\t\tfree(sp);\n\t\t\t__set_errno (saved_errno);\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t/* Free up the stream pointer. */\n\tfree(sp);\n\treturn (0);\n}",
    "fts64_read(int *)": "FTSENTRY *\nFTS_READ (FTSOBJ *sp)\n{\n\tFTSENTRY *p, *tmp;\n\tint instr;\n\tchar *t;\n\tint saved_errno;\n\n\t/* If finished or unrecoverable error, return NULL. */\n\tif (sp->fts_cur == NULL || ISSET(FTS_STOP))\n\t\treturn (NULL);\n\n\t/* Set current node pointer. */\n\tp = sp->fts_cur;\n\n\t/* Save and zero out user instructions. */\n\tinstr = p->fts_instr;\n\tp->fts_instr = FTS_NOINSTR;\n\n\t/* Any type of file may be re-visited; re-stat and re-turn. */\n\tif (instr == FTS_AGAIN) {\n\t\tp->fts_info = fts_stat(sp, p, 0);\n\t\treturn (p);\n\t}\n\n\t/*\n\t * Following a symlink -- SLNONE test allows application to see\n\t * SLNONE and recover.  If indirecting through a symlink, have\n\t * keep a pointer to current location.  If unable to get that\n\t * pointer, follow fails.\n\t */\n\tif (instr == FTS_FOLLOW &&\n\t    (p->fts_info == FTS_SL || p->fts_info == FTS_SLNONE)) {\n\t\tp->fts_info = fts_stat(sp, p, 1);\n\t\tif (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n\t\t\tif ((p->fts_symfd = __open(\".\", O_RDONLY, 0)) < 0) {\n\t\t\t\tp->fts_errno = errno;\n\t\t\t\tp->fts_info = FTS_ERR;\n\t\t\t} else\n\t\t\t\tp->fts_flags |= FTS_SYMFOLLOW;\n\t\t}\n\t\treturn (p);\n\t}\n\n\t/* Directory in pre-order. */\n\tif (p->fts_info == FTS_D) {\n\t\t/* If skipped or crossed mount point, do post-order visit. */\n\t\tif (instr == FTS_SKIP ||\n\t\t    (ISSET(FTS_XDEV) && p->fts_dev != sp->fts_dev)) {\n\t\t\tif (p->fts_flags & FTS_SYMFOLLOW)\n\t\t\t\t(void)__close(p->fts_symfd);\n\t\t\tif (sp->fts_child) {\n\t\t\t\tfts_lfree(sp->fts_child);\n\t\t\t\tsp->fts_child = NULL;\n\t\t\t}\n\t\t\tp->fts_info = FTS_DP;\n\t\t\treturn (p);\n\t\t}\n\n\t\t/* Rebuild if only read the names and now traversing. */\n\t\tif (sp->fts_child != NULL && ISSET(FTS_NAMEONLY)) {\n\t\t\tCLR(FTS_NAMEONLY);\n\t\t\tfts_lfree(sp->fts_child);\n\t\t\tsp->fts_child = NULL;\n\t\t}\n\n\t\t/*\n\t\t * Cd to the subdirectory.\n\t\t *\n\t\t * If have already read and now fail to chdir, whack the list\n\t\t * to make the names come out right, and set the parent errno\n\t\t * so the application will eventually get an error condition.\n\t\t * Set the FTS_DONTCHDIR flag so that when we logically change\n\t\t * directories back to the parent we don't do a chdir.\n\t\t *\n\t\t * If haven't read do so.  If the read fails, fts_build sets\n\t\t * FTS_STOP or the fts_info field of the node.\n\t\t */\n\t\tif (sp->fts_child != NULL) {\n\t\t\tif (fts_safe_changedir(sp, p, -1, p->fts_accpath)) {\n\t\t\t\tp->fts_errno = errno;\n\t\t\t\tp->fts_flags |= FTS_DONTCHDIR;\n\t\t\t\tfor (p = sp->fts_child; p != NULL;\n\t\t\t\t     p = p->fts_link)\n\t\t\t\t\tp->fts_accpath =\n\t\t\t\t\t    p->fts_parent->fts_accpath;\n\t\t\t}\n\t\t} else if ((sp->fts_child = fts_build(sp, BREAD)) == NULL) {\n\t\t\tif (ISSET(FTS_STOP))\n\t\t\t\treturn (NULL);\n\t\t\treturn (p);\n\t\t}\n\t\tp = sp->fts_child;\n\t\tsp->fts_child = NULL;\n\t\tsp->fts_cur = p;\n\t\tgoto name;\n\t}\n\n\t/* Move to the next node on this level. */\nnext:\ttmp = p;\n\tif ((p = p->fts_link) != NULL) {\n\t\tsp->fts_cur = p;\n\t\tfree(tmp);\n\n\t\t/*\n\t\t * If reached the top, return to the original directory (or\n\t\t * the root of the tree), and load the paths for the next root.\n\t\t */\n\t\tif (p->fts_level == FTS_ROOTLEVEL) {\n\t\t\tif (FCHDIR(sp, sp->fts_rfd)) {\n\t\t\t\tSET(FTS_STOP);\n\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t\tfts_load(sp, p);\n\t\t\treturn p;\n\t\t}\n\n\t\t/*\n\t\t * User may have called fts_set on the node.  If skipped,\n\t\t * ignore.  If followed, get a file descriptor so we can\n\t\t * get back if necessary.\n\t\t */\n\t\tif (p->fts_instr == FTS_SKIP)\n\t\t\tgoto next;\n\t\tif (p->fts_instr == FTS_FOLLOW) {\n\t\t\tp->fts_info = fts_stat(sp, p, 1);\n\t\t\tif (p->fts_info == FTS_D && !ISSET(FTS_NOCHDIR)) {\n\t\t\t\tif ((p->fts_symfd =\n\t\t\t\t    __open(\".\", O_RDONLY, 0)) < 0) {\n\t\t\t\t\tp->fts_errno = errno;\n\t\t\t\t\tp->fts_info = FTS_ERR;\n\t\t\t\t} else\n\t\t\t\t\tp->fts_flags |= FTS_SYMFOLLOW;\n\t\t\t}\n\t\t\tp->fts_instr = FTS_NOINSTR;\n\t\t}\n\nname:\t\tt = sp->fts_path + NAPPEND(p->fts_parent);\n\t\t*t++ = '/';\n\t\tmemmove(t, p->fts_name, p->fts_namelen + 1);\n\t\treturn p;\n\t}\n\n\t/* Move up to the parent node. */\n\tp = tmp->fts_parent;\n\tsp->fts_cur = p;\n\tfree(tmp);\n\n\tif (p->fts_level == FTS_ROOTPARENTLEVEL) {\n\t\t/*\n\t\t * Done; free everything up and set errno to 0 so the user\n\t\t * can distinguish between error and EOF.\n\t\t */\n\t\tfree(p);\n\t\t__set_errno (0);\n\t\treturn (sp->fts_cur = NULL);\n\t}\n\n\t/* NUL terminate the pathname. */\n\tsp->fts_path[p->fts_pathlen] = '\\0';\n\n\t/*\n\t * Return to the parent directory.  If at a root node or came through\n\t * a symlink, go back through the file descriptor.  Otherwise, cd up\n\t * one directory.\n\t */\n\tif (p->fts_level == FTS_ROOTLEVEL) {\n\t\tif (FCHDIR(sp, sp->fts_rfd)) {\n\t\t\tSET(FTS_STOP);\n\t\t\treturn (NULL);\n\t\t}\n\t} else if (p->fts_flags & FTS_SYMFOLLOW) {\n\t\tif (FCHDIR(sp, p->fts_symfd)) {\n\t\t\tsaved_errno = errno;\n\t\t\t(void)__close(p->fts_symfd);\n\t\t\t__set_errno (saved_errno);\n\t\t\tSET(FTS_STOP);\n\t\t\treturn (NULL);\n\t\t}\n\t\t(void)__close(p->fts_symfd);\n\t} else if (!(p->fts_flags & FTS_DONTCHDIR) &&\n\t\t   fts_safe_changedir(sp, p->fts_parent, -1, \"..\")) {\n\t\tSET(FTS_STOP);\n\t\treturn (NULL);\n\t}\n\tp->fts_info = p->fts_errno ? FTS_ERR : FTS_DP;\n\treturn p;\n}",
    "fts64_set(int *, int *, int)": "int\nFTS_SET (FTSOBJ *sp, FTSENTRY *p, int instr)\n{\n\tif (instr != 0 && instr != FTS_AGAIN && instr != FTS_FOLLOW &&\n\t    instr != FTS_NOINSTR && instr != FTS_SKIP) {\n\t\t__set_errno (EINVAL);\n\t\treturn (1);\n\t}\n\tp->fts_instr = instr;\n\treturn (0);\n}",
    "fts64_children(int *, int)": "FTSENTRY *\nFTS_CHILDREN(FTSOBJ *sp, int instr)\n{\n\tFTSENTRY *p;\n\tint fd;\n\n\tif (instr != 0 && instr != FTS_NAMEONLY) {\n\t\t__set_errno (EINVAL);\n\t\treturn (NULL);\n\t}\n\n\t/* Set current node pointer. */\n\tp = sp->fts_cur;\n\n\t/*\n\t * Errno set to 0 so user can distinguish empty directory from\n\t * an error.\n\t */\n\t__set_errno (0);\n\n\t/* Fatal errors stop here. */\n\tif (ISSET(FTS_STOP))\n\t\treturn (NULL);\n\n\t/* Return logical hierarchy of user's arguments. */\n\tif (p->fts_info == FTS_INIT)\n\t\treturn (p->fts_link);\n\n\t/*\n\t * If not a directory being visited in pre-order, stop here.  Could\n\t * allow FTS_DNR, assuming the user has fixed the problem, but the\n\t * same effect is available with FTS_AGAIN.\n\t */\n\tif (p->fts_info != FTS_D /* && p->fts_info != FTS_DNR */)\n\t\treturn (NULL);\n\n\t/* Free up any previous child list. */\n\tif (sp->fts_child != NULL)\n\t\tfts_lfree(sp->fts_child);\n\n\tif (instr == FTS_NAMEONLY) {\n\t\tSET(FTS_NAMEONLY);\n\t\tinstr = BNAMES;\n\t} else\n\t\tinstr = BCHILD;\n\n\t/*\n\t * If using chdir on a relative path and called BEFORE fts_read does\n\t * its chdir to the root of a traversal, we can lose -- we need to\n\t * chdir into the subdirectory, and we don't know where the current\n\t * directory is, so we can't get back so that the upcoming chdir by\n\t * fts_read will work.\n\t */\n\tif (p->fts_level != FTS_ROOTLEVEL || p->fts_accpath[0] == '/' ||\n\t    ISSET(FTS_NOCHDIR))\n\t\treturn (sp->fts_child = fts_build(sp, instr));\n\n\tif ((fd = __open(\".\", O_RDONLY, 0)) < 0)\n\t\treturn (NULL);\n\tsp->fts_child = fts_build(sp, instr);\n\tif (__fchdir(fd))\n\t\treturn (NULL);\n\t(void)__close(fd);\n\treturn (sp->fts_child);\n}",
    "ftw(const char *, __ftw_func_t, int)": "int\nFTW_NAME (const char *path, FTW_FUNC_T func, int descriptors)\n{\n  return ftw_startup (path, 0, func, descriptors, 0);\n}",
    "ftw64(const char *, int, int)": "int\nFTW_NAME (const char *path, FTW_FUNC_T func, int descriptors)\n{\n  return ftw_startup (path, 0, func, descriptors, 0);\n}",
    "futimens(int, const struct timespec *)": "int\nfutimens (int fd, const struct timespec tsp[2])\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "get_current_dir_name()": "char *\nget_current_dir_name (void)\n{\n  char *pwd;\n  struct __stat64_t64 dotstat, pwdstat;\n\n  pwd = getenv (\"PWD\");\n  if (pwd != NULL\n      && __stat64_time64 (\".\", &dotstat) == 0\n      && __stat64_time64 (pwd, &pwdstat) == 0\n      && pwdstat.st_dev == dotstat.st_dev\n      && pwdstat.st_ino == dotstat.st_ino)\n    /* The PWD value is correct.  Use it.  */\n    return __strdup (pwd);\n\n  return __getcwd ((char *) NULL, 0);\n}",
    "getwd(char *)": "char *\ngetwd (char *buf)\n{\n#ifndef PATH_MAX\n#define PATH_MAX 1024\n#endif\n  char tmpbuf[PATH_MAX];\n\n  if (buf == NULL)\n    {\n      __set_errno (EINVAL);\n      return NULL;\n    }\n\n  if (__getcwd (tmpbuf, PATH_MAX) == NULL)\n    {\n      /* We use 1024 here since it should really be enough and because\n\t this is a safe value.  */\n      __strerror_r (errno, buf, 1024);\n      return NULL;\n    }\n\n  /* This is completely unsafe.  Nobody can say how big the user\n     provided buffer is.  Perhaps the application and the libc\n     disagree about the value of PATH_MAX.  */\n  return strcpy (buf, tmpbuf);\n}",
    "lchmod(const char *, mode_t)": "int\nlchmod (const char *file, mode_t mode)\n{\n  error_t err;\n  file_t port = __file_name_lookup (file, O_NOLINK, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = __file_chmod (port, mode);\n  __mach_port_deallocate (__mach_task_self (), port);\n  if (err)\n    return __hurd_fail (err);\n  return 0;\n}",
    "linkat(int, const char *, int, const char *, int)": "int\nlinkat (int fromfd, const char *from, int tofd, const char *to, int flags)\n{\n  if (from == NULL || to == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if ((tofd != AT_FDCWD && tofd < 0 && *to != '/')\n      || (fromfd != AT_FDCWD && fromfd < 0 && *from != '/'))\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mkdirat(int, const char *, mode_t)": "int\nmkdirat (int fd, const char *path, mode_t mode)\n{\n  if (path == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (fd != AT_FDCWD && path[0] != '/')\n    {\n      /* Check FD is associated with a directory.  */\n      struct stat64 st;\n      if (__fstat64 (fd, &st) != 0)\n\treturn -1;\n\n      if (!S_ISDIR (st.st_mode))\n\t{\n\t  __set_errno (ENOTDIR);\n\t  return -1;\n\t}\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mkfifo(const char *, mode_t)": "int\nmkfifo (const char *path, mode_t mode)\n{\n  return __mknod (path, mode | S_IFIFO, 0);\n}",
    "mkfifoat(int, const char *, mode_t)": "int\nmkfifoat (int fd, const char *file, mode_t mode)\n{\n  return __mknodat (fd, file, mode | S_IFIFO, 0);\n}",
    "__open64_2(const char *, int)": "int\n__open64_2 (const char *file, int oflag)\n{\n  if (__OPEN_NEEDS_MODE (oflag))\n    __fortify_fail (\"invalid open64 call: O_CREAT or O_TMPFILE without mode\");\n\n  return __open64 (file, oflag);\n}",
    "__open_2(const char *, int)": "int\n__open_2 (const char *file, int oflag)\n{\n  if (__OPEN_NEEDS_MODE (oflag))\n    __fortify_fail (\"invalid open call: O_CREAT or O_TMPFILE without mode\");\n\n  return __open (file, oflag);\n}",
    "__openat64_2(int, const char *, int)": "int\n__openat64_2 (int fd, const char *file, int oflag)\n{\n  if (__OPEN_NEEDS_MODE (oflag))\n    __fortify_fail (\"invalid openat64 call: O_CREAT or O_TMPFILE without mode\");\n\n  return __openat64 (fd, file, oflag);\n}",
    "__openat_2(int, const char *, int)": "int\n__openat_2 (int fd, const char *file, int oflag)\n{\n  if (__OPEN_NEEDS_MODE (oflag))\n    __fortify_fail (\"invalid openat call: O_CREAT or O_TMPFILE without mode\");\n\n  return __openat (fd, file, oflag);\n}",
    "__pipe(int *)": "int\n__pipe (int __pipedes[2])\n{\n  return INLINE_SYSCALL_CALL (pipe2, (int *) __pipedes, 0);\n}",
    "__poll(struct pollfd *, nfds_t, int)": "int\n__poll (struct pollfd *fds, nfds_t nfds, int timeout)\n{\n  struct timespec ts, *to;\n\n  if (timeout < 0)\n    to = NULL;\n  else\n    {\n      ts.tv_sec = timeout / 1000;\n      ts.tv_nsec = (timeout % 1000) * 1000000;\n      to = &ts;\n    }\n\n  return _hurd_select (nfds, fds, NULL, NULL, NULL, to, NULL);\n}",
    "posix_fadvise(int, __off_t, __off_t, int)": "int\nposix_fadvise (int fd, __off_t offset, __off_t len, int advise)\n{\n  return ENOSYS;\n}",
    "posix_fadvise64(int, __off64_t, __off64_t, int)": "int\nposix_fadvise64 (int fd, __off64_t offset, __off64_t len, int advise)\n{\n  return ENOSYS;\n}",
    "posix_fallocate(int, __off_t, __off_t)": "int\nposix_fallocate (int fd, __off_t offset, __off_t len)\n{\n  int res = INTERNAL_SYSCALL_CALL (fallocate, fd, 0,\n\t\t\t\t   SYSCALL_LL (offset), SYSCALL_LL (len));\n  if (! INTERNAL_SYSCALL_ERROR_P (res))\n    return 0;\n  if (INTERNAL_SYSCALL_ERRNO (res) != EOPNOTSUPP)\n    return INTERNAL_SYSCALL_ERRNO (res);\n  return internal_fallocate (fd, offset, len);\n}",
    "posix_fallocate64(int, __off64_t, __off64_t)": "int\nposix_fallocate64 (int fd, __off64_t offset, __off64_t len)\n{\n  return ENOSYS;\n}",
    "ppoll(struct pollfd *, nfds_t, const struct timespec *, const sigset_t *)": "int\nppoll (struct pollfd *fds, nfds_t nfds,\n       const struct timespec *timeout, const sigset_t *sigmask)\n{\n  return _hurd_select (nfds, fds, NULL, NULL, NULL, timeout, sigmask);\n}",
    "readlinkat(int, const char *, char *, int)": "ssize_t\nreadlinkat (int fd, const char *path, char *buf, size_t len)\n{\n  if (path == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (fd != AT_FDCWD && fd < 0 && *path != '/')\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "sendfile(int, int, off_t *, int)": "ssize_t\nsendfile (int out_fd, int in_fd, off_t *offset, size_t count)\n{\n  if (offset == NULL || sizeof (off_t) == sizeof (off64_t))\n    return __sendfile64 (out_fd, in_fd, (off64_t *) offset, count);\n  else\n    {\n      off64_t ofs = *offset;\n      ssize_t ret = __sendfile64 (out_fd, in_fd, &ofs, count);\n      *offset = ofs;\n      return ret;\n    }\n}",
    "sendfile64(int, int, int *, int)": "ssize_t\nsendfile64 (int out_fd, int in_fd, off64_t *offset, size_t count)\n{\n#ifndef __NR_sendfile64\n# define __NR_sendfile64 __NR_sendfile\n#endif\n  return INLINE_SYSCALL_CALL (sendfile64, out_fd, in_fd, offset, count);\n}",
    "__statfs(const char *, struct statfs *)": "int\n__statfs (const char *file, struct statfs *buf)\n{\n  return INLINE_SYSCALL_CALL (statfs, file, buf);\n}",
    "statx(int, const char *, int, unsigned int, struct statx *)": "int\nstatx (int fd, const char *path, int flags,\n       unsigned int mask, struct statx *buf)\n{\n  int ret = INLINE_SYSCALL_CALL (statx, fd, path, flags, mask, buf);\n#ifdef __ASSUME_STATX\n  return ret;\n#else\n  if (ret == 0 || errno != ENOSYS)\n    /* Preserve non-error/non-ENOSYS return values.  */\n    return ret;\n  else\n    return statx_generic (fd, path, flags, mask, buf);\n#endif\n}",
    "symlinkat(const char *, int, const char *)": "int\nsymlinkat (const char *from, int fd, const char *to)\n{\n  if (from == NULL || to == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (fd != AT_FDCWD && fd < 0 && *to != '/')\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "ttyname(int)": "char *\nttyname (int fd)\n{\n  struct stat st;\n  int dostat = 0;\n  char *name;\n  int save = errno;\n\n  if (!__isatty (fd))\n    return NULL;\n\n  if (fstat (fd, &st) < 0)\n    return NULL;\n\n#ifdef _STATBUF_ST_RDEV\n  name = getttyname (fd, st.st_rdev, st.st_ino, save, &dostat);\n#else\n  name = getttyname (fd, st.st_dev, st.st_ino, save, &dostat);\n#endif\n\n  if (!name && dostat != -1)\n    {\n      dostat = 1;\n#ifdef _STATBUF_ST_RDEV\n      name = getttyname (fd, st.st_rdev, st.st_ino, save, &dostat);\n#else\n      name = getttyname (fd, st.st_dev, st.st_ino, save, &dostat);\n#endif\n    }\n\n  return name;\n}",
    "unlinkat(int, const char *, int)": "int\nunlinkat (int fd, const char *name, int flag)\n{\n  if (name == NULL || (flag & AT_REMOVEDIR) != 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (fd < 0 && fd != AT_FDCWD)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "utime(const char *, const struct utimbuf *)": "int\nutime (const char *file, const struct utimbuf *times)\n{\n  struct timeval timevals[2];\n  struct timeval *tvp;\n\n  if (times != NULL)\n    {\n      timevals[0].tv_sec = (time_t) times->actime;\n      timevals[0].tv_usec = 0L;\n      timevals[1].tv_sec = (time_t) times->modtime;\n      timevals[1].tv_usec = 0L;\n      tvp = timevals;\n    }\n  else\n    tvp = NULL;\n\n  return __utimes (file, tvp);\n}",
    "utimensat(int, const char *, const struct timespec *, int)": "int\nutimensat (int fd, const char *file, const struct timespec tsp[2],\n\t   int flags)\n{\n  error_t err;\n  file_t port;\n\n  port = __file_name_lookup_at (fd, flags, file, 0, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n\n  err = hurd_futimens (port, tsp);\n\n  __mach_port_deallocate (__mach_task_self (), port);\n  if (err)\n    return __hurd_fail (err);\n  return 0;\n}",
    "__fbufsize(FILE *)": "size_t\n__fbufsize (FILE *fp)\n{\n  if (fp->_mode > 0)\n    return fp->_wide_data->_IO_buf_end - fp->_wide_data->_IO_buf_base;\n  else\n    return fp->_IO_buf_end - fp->_IO_buf_base;\n}",
    "__flbf(FILE *)": "int\n__flbf (FILE *fp)\n{\n  return fp->_flags & _IO_LINE_BUF;\n}",
    "__fpending(FILE *)": "size_t\n__fpending (FILE *fp)\n{\n  if (fp->_mode > 0)\n    return fp->_wide_data->_IO_write_ptr - fp->_wide_data->_IO_write_base;\n  else\n    return fp->_IO_write_ptr - fp->_IO_write_base;\n}",
    "__fpurge(FILE *)": "void\n__fpurge (FILE *fp)\n{\n  if (fp->_mode > 0)\n    {\n      /* Wide-char stream.  */\n      if (_IO_in_backup (fp))\n\t_IO_free_wbackup_area (fp);\n\n      fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_read_ptr;\n      fp->_wide_data->_IO_write_ptr = fp->_wide_data->_IO_write_base;\n    }\n  else\n    {\n      /* Byte stream.  */\n      if (_IO_in_backup (fp))\n\t_IO_free_backup_area (fp);\n\n      fp->_IO_read_end = fp->_IO_read_ptr;\n      fp->_IO_write_ptr = fp->_IO_write_base;\n    }\n}",
    "__freadable(FILE *)": "int\n__freadable (FILE *fp)\n{\n  return (fp->_flags & _IO_NO_READS) == 0;\n}",
    "__freading(FILE *)": "int\n__freading (FILE *fp)\n{\n  return ((fp->_flags & _IO_NO_WRITES)\n\t  || ((fp->_flags & (_IO_CURRENTLY_PUTTING | _IO_NO_READS)) == 0\n\t      && fp->_IO_read_base != NULL));\n}",
    "__fsetlocking(FILE *, int)": "int\n__fsetlocking (FILE *fp, int type)\n{\n  int result = ((fp->_flags & _IO_USER_LOCK)\n\t\t? FSETLOCKING_BYCALLER : FSETLOCKING_INTERNAL);\n\n  if (type != FSETLOCKING_QUERY)\n    {\n      fp->_flags &= ~_IO_USER_LOCK;\n      if (type == FSETLOCKING_BYCALLER)\n\t fp->_flags |= _IO_USER_LOCK;\n    }\n\n  return result;\n}",
    "__fwritable(FILE *)": "int\n__fwritable (FILE *fp)\n{\n  return (fp->_flags & _IO_NO_WRITES) == 0;\n}",
    "__fwriting(FILE *)": "int\n__fwriting (FILE *fp)\n{\n  return fp->_flags & (_IO_NO_READS | _IO_CURRENTLY_PUTTING);\n}",
    "clearerr(FILE *)": "void\nclearerr (FILE *fp)\n{\n  CHECK_FILE (fp, /*nothing*/);\n  _IO_flockfile (fp);\n  _IO_clearerr (fp);\n  _IO_funlockfile (fp);\n}",
    "clearerr_unlocked(FILE *)": "void\nclearerr_unlocked (FILE *fp)\n{\n  CHECK_FILE (fp, /*nothing*/);\n  _IO_clearerr (fp);\n}",
    "_IO_feof(FILE *)": "int\n_IO_feof (FILE *fp)\n{\n  int result;\n  CHECK_FILE (fp, EOF);\n  if (!_IO_need_lock (fp))\n    return _IO_feof_unlocked (fp);\n  _IO_flockfile (fp);\n  result = _IO_feof_unlocked (fp);\n  _IO_funlockfile (fp);\n  return result;\n}",
    "_IO_ferror(FILE *)": "int\n_IO_ferror (FILE *fp)\n{\n  int result;\n  CHECK_FILE (fp, EOF);\n  if (!_IO_need_lock (fp))\n    return _IO_ferror_unlocked (fp);\n  _IO_flockfile (fp);\n  result = _IO_ferror_unlocked (fp);\n  _IO_funlockfile (fp);\n  return result;\n}",
    "_IO_file_doallocate(FILE *)": "int\n_IO_file_doallocate (FILE *fp)\n{\n  size_t size;\n  char *p;\n  struct __stat64_t64 st;\n\n  size = BUFSIZ;\n  if (fp->_fileno >= 0 && __builtin_expect (_IO_SYSSTAT (fp, &st), 0) >= 0)\n    {\n      if (S_ISCHR (st.st_mode))\n\t{\n\t  /* Possibly a tty.  */\n\t  if (\n#ifdef DEV_TTY_P\n\t      DEV_TTY_P (&st) ||\n#endif\n\t      local_isatty (fp->_fileno))\n\t    fp->_flags |= _IO_LINE_BUF;\n\t}\n#if defined _STATBUF_ST_BLKSIZE\n      if (st.st_blksize > 0 && st.st_blksize < BUFSIZ)\n\tsize = st.st_blksize;\n#endif\n    }\n  p = malloc (size);\n  if (__glibc_unlikely (p == NULL))\n    return EOF;\n  _IO_setb (fp, p, p + size, 1);\n  return 1;\n}",
    "fputc(int, FILE *)": "int\nfputc (int c, FILE *fp)\n{\n  int result;\n  CHECK_FILE (fp, EOF);\n  if (!_IO_need_lock (fp))\n    return _IO_putc_unlocked (c, fp);\n  _IO_acquire_lock (fp);\n  result = _IO_putc_unlocked (c, fp);\n  _IO_release_lock (fp);\n  return result;\n}",
    "fputwc(int, FILE *)": "wint_t\nfputwc (wchar_t wc, FILE *fp)\n{\n  wint_t result;\n  CHECK_FILE (fp, EOF);\n  _IO_acquire_lock (fp);\n  if (_IO_fwide (fp, 1) < 0)\n    result = WEOF;\n  else\n    result = _IO_putwc_unlocked (wc, fp);\n  _IO_release_lock (fp);\n  return result;\n}",
    "fputwc_unlocked(int, FILE *)": "wint_t\nfputwc_unlocked (wchar_t wc, FILE *fp)\n{\n  CHECK_FILE (fp, WEOF);\n  if (_IO_fwide (fp, 1) < 0)\n    return WEOF;\n  return _IO_putwc_unlocked (wc, fp);\n}",
    "freopen(const char *, const char *, FILE *)": "FILE *\nfreopen (const char *filename, const char *mode, FILE *fp)\n{\n  FILE *result = NULL;\n  struct fd_to_filename fdfilename;\n\n  CHECK_FILE (fp, NULL);\n\n  _IO_acquire_lock (fp);\n  /* First flush the stream (failure should be ignored).  */\n  _IO_SYNC (fp);\n\n  if (!(fp->_flags & _IO_IS_FILEBUF))\n    goto end;\n\n  int fd = _IO_fileno (fp);\n  const char *gfilename\n    = filename != NULL ? filename : __fd_to_filename (fd, &fdfilename);\n\n  fp->_flags2 |= _IO_FLAGS2_NOCLOSE;\n#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)\n  if (&_IO_stdin_used == NULL)\n    {\n      /* If the shared C library is used by the application binary which\n\t was linked against the older version of libio, we just use the\n\t older one even for internal use to avoid trouble since a pointer\n\t to the old libio may be passed into shared C library and wind\n\t up here. */\n      _IO_old_file_close_it (fp);\n      _IO_JUMPS_FUNC_UPDATE (fp, &_IO_old_file_jumps);\n      result = _IO_old_file_fopen (fp, gfilename, mode);\n    }\n  else\n#endif\n    {\n      _IO_file_close_it (fp);\n      _IO_JUMPS_FILE_plus (fp) = &_IO_file_jumps;\n      if (_IO_vtable_offset (fp) == 0 && fp->_wide_data != NULL)\n\tfp->_wide_data->_wide_vtable = &_IO_wfile_jumps;\n      result = _IO_file_fopen (fp, gfilename, mode, 1);\n      if (result != NULL)\n\tresult = __fopen_maybe_mmap (result);\n    }\n  fp->_flags2 &= ~_IO_FLAGS2_NOCLOSE;\n  if (result != NULL)\n    {\n      /* unbound stream orientation */\n      result->_mode = 0;\n\n      if (fd != -1 && _IO_fileno (result) != fd)\n\t{\n\t  /* At this point we have both file descriptors already allocated,\n\t     so __dup3 will not fail with EBADF, EINVAL, or EMFILE.  But\n\t     we still need to check for EINVAL and, due Linux internal\n\t     implementation, EBUSY.  It is because on how it internally opens\n\t     the file by splitting the buffer allocation operation and VFS\n\t     opening (a dup operation may run when a file is still pending\n\t     'install' on VFS).  */\n\t  if (__dup3 (_IO_fileno (result), fd,\n\t\t      (result->_flags2 & _IO_FLAGS2_CLOEXEC) != 0\n\t\t      ? O_CLOEXEC : 0) == -1)\n\t    {\n\t      _IO_file_close_it (result);\n\t      result = NULL;\n\t      goto end;\n\t    }\n\t  __close (_IO_fileno (result));\n\t  _IO_fileno (result) = fd;\n\t}\n    }\n  else if (fd != -1)\n    __close (fd);\n\nend:\n  _IO_release_lock (fp);\n  return result;\n}",
    "freopen64(const char *, const char *, FILE *)": "FILE *\nfreopen64 (const char *filename, const char *mode, FILE *fp)\n{\n  FILE *result = NULL;\n  struct fd_to_filename fdfilename;\n\n  CHECK_FILE (fp, NULL);\n\n  _IO_acquire_lock (fp);\n  /* First flush the stream (failure should be ignored).  */\n  _IO_SYNC (fp);\n\n  if (!(fp->_flags & _IO_IS_FILEBUF))\n    goto end;\n\n  int fd = _IO_fileno (fp);\n  const char *gfilename\n    = filename != NULL ? filename : __fd_to_filename (fd, &fdfilename);\n\n  fp->_flags2 |= _IO_FLAGS2_NOCLOSE;\n  _IO_file_close_it (fp);\n  _IO_JUMPS_FILE_plus (fp) = &_IO_file_jumps;\n  if (_IO_vtable_offset (fp) == 0 && fp->_wide_data != NULL)\n    fp->_wide_data->_wide_vtable = &_IO_wfile_jumps;\n  result = _IO_file_fopen (fp, gfilename, mode, 0);\n  fp->_flags2 &= ~_IO_FLAGS2_NOCLOSE;\n  if (result != NULL)\n    result = __fopen_maybe_mmap (result);\n  if (result != NULL)\n    {\n      /* unbound stream orientation */\n      result->_mode = 0;\n\n      if (fd != -1 && _IO_fileno (result) != fd)\n\t{\n\t  /* At this point we have both file descriptors already allocated,\n\t     so __dup3 will not fail with EBADF, EINVAL, or EMFILE.  But\n\t     we still need to check for EINVAL and, due Linux internal\n\t     implementation, EBUSY.  It is because on how it internally opens\n\t     the file by splitting the buffer allocation operation and VFS\n\t     opening (a dup operation may run when a file is still pending\n\t     'install' on VFS).  */\n\t  if (__dup3 (_IO_fileno (result), fd,\n\t\t      (result->_flags2 & _IO_FLAGS2_CLOEXEC) != 0\n\t\t      ? O_CLOEXEC : 0) == -1)\n\t    {\n\t      _IO_file_close_it (result);\n\t      result = NULL;\n\t      goto end;\n\t    }\n\t  __close (_IO_fileno (result));\n\t  _IO_fileno (result) = fd;\n\t}\n    }\n  else if (fd != -1)\n    __close (fd);\n\nend:\n  _IO_release_lock (fp);\n  return result;\n}",
    "fseek(FILE *, long, int)": "int\nfseek (FILE *fp, long int offset, int whence)\n{\n  int result;\n  CHECK_FILE (fp, -1);\n  _IO_acquire_lock (fp);\n  result = _IO_fseek (fp, offset, whence);\n  _IO_release_lock (fp);\n  return result;\n}",
    "fwide(FILE *, int)": "int\nfwide (FILE *fp, int mode)\n{\n  int result;\n\n  /* Normalize the value.  */\n  mode = mode < 0 ? -1 : (mode == 0 ? 0 : 1);\n\n  if (mode == 0 || fp->_mode != 0)\n    /* The caller simply wants to know about the current orientation\n       or the orientation already has been determined.  */\n    return fp->_mode;\n\n  _IO_acquire_lock (fp);\n  result = _IO_fwide (fp, mode);\n  _IO_release_lock (fp);\n\n  return result;\n}",
    "_IO_un_link(struct _IO_FILE_plus *)": "void\n_IO_un_link (struct _IO_FILE_plus *fp)\n{\n  if (fp->file._flags & _IO_LINKED)\n    {\n      FILE **f;\n#ifdef _IO_MTSAFE_IO\n      _IO_cleanup_region_start_noarg (flush_cleanup);\n      _IO_lock_lock (list_all_lock);\n      run_fp = (FILE *) fp;\n      _IO_flockfile ((FILE *) fp);\n#endif\n      if (_IO_list_all == NULL)\n\t;\n      else if (fp == _IO_list_all)\n\t_IO_list_all = (struct _IO_FILE_plus *) _IO_list_all->file._chain;\n      else\n\tfor (f = &_IO_list_all->file._chain; *f; f = &(*f)->_chain)\n\t  if (*f == (FILE *) fp)\n\t    {\n\t      *f = fp->file._chain;\n\t      break;\n\t    }\n      fp->file._flags &= ~_IO_LINKED;\n#ifdef _IO_MTSAFE_IO\n      _IO_funlockfile ((FILE *) fp);\n      run_fp = NULL;\n      _IO_lock_unlock (list_all_lock);\n      _IO_cleanup_region_end (0);\n#endif\n    }\n}",
    "_IO_switch_to_get_mode(FILE *)": "int\n_IO_switch_to_get_mode (FILE *fp)\n{\n  if (fp->_IO_write_ptr > fp->_IO_write_base)\n    if (_IO_OVERFLOW (fp, EOF) == EOF)\n      return EOF;\n  if (_IO_in_backup (fp))\n    fp->_IO_read_base = fp->_IO_backup_base;\n  else\n    {\n      fp->_IO_read_base = fp->_IO_buf_base;\n      if (fp->_IO_write_ptr > fp->_IO_read_end)\n\tfp->_IO_read_end = fp->_IO_write_ptr;\n    }\n  fp->_IO_read_ptr = fp->_IO_write_ptr;\n\n  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end = fp->_IO_read_ptr;\n\n  fp->_flags &= ~_IO_CURRENTLY_PUTTING;\n  return 0;\n}",
    "__underflow(FILE *)": "int\n__underflow (FILE *fp)\n{\n  if (_IO_vtable_offset (fp) == 0 && _IO_fwide (fp, -1) != -1)\n    return EOF;\n\n  if (fp->_mode == 0)\n    _IO_fwide (fp, -1);\n  if (_IO_in_put_mode (fp))\n    if (_IO_switch_to_get_mode (fp) == EOF)\n      return EOF;\n  if (fp->_IO_read_ptr < fp->_IO_read_end)\n    return *(unsigned char *) fp->_IO_read_ptr;\n  if (_IO_in_backup (fp))\n    {\n      _IO_switch_to_main_get_area (fp);\n      if (fp->_IO_read_ptr < fp->_IO_read_end)\n\treturn *(unsigned char *) fp->_IO_read_ptr;\n    }\n  if (_IO_have_markers (fp))\n    {\n      if (save_for_backup (fp, fp->_IO_read_end))\n\treturn EOF;\n    }\n  else if (_IO_have_backup (fp))\n    _IO_free_backup_area (fp);\n  return _IO_UNDERFLOW (fp);\n}",
    "_IO_default_uflow(FILE *)": "int\n_IO_default_uflow (FILE *fp)\n{\n  int ch = _IO_UNDERFLOW (fp);\n  if (ch == EOF)\n    return EOF;\n  return *(unsigned char *) fp->_IO_read_ptr++;\n}",
    "_IO_enable_locks()": "void\n_IO_enable_locks (void)\n{\n  _IO_ITER i;\n\n  if (stdio_needs_locking)\n    return;\n  stdio_needs_locking = 1;\n  for (i = _IO_iter_begin (); i != _IO_iter_end (); i = _IO_iter_next (i))\n    _IO_iter_file (i)->_flags2 |= _IO_FLAGS2_NEED_LOCK;\n}",
    "_IO_default_finish(FILE *, int)": "void\n_IO_default_finish (FILE *fp, int dummy)\n{\n  struct _IO_marker *mark;\n  if (fp->_IO_buf_base && !(fp->_flags & _IO_USER_BUF))\n    {\n      free (fp->_IO_buf_base);\n      fp->_IO_buf_base = fp->_IO_buf_end = NULL;\n    }\n\n  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n    mark->_sbuf = NULL;\n\n  if (fp->_IO_save_base)\n    {\n      free (fp->_IO_save_base);\n      fp->_IO_save_base = NULL;\n    }\n\n  _IO_un_link ((struct _IO_FILE_plus *) fp);\n\n#ifdef _IO_MTSAFE_IO\n  if (fp->_lock != NULL)\n    _IO_lock_fini (*fp->_lock);\n#endif\n}",
    "_IO_init_marker(struct _IO_marker *, FILE *)": "void\n_IO_init_marker (struct _IO_marker *marker, FILE *fp)\n{\n  marker->_sbuf = fp;\n  if (_IO_in_put_mode (fp))\n    _IO_switch_to_get_mode (fp);\n  if (_IO_in_backup (fp))\n    marker->_pos = fp->_IO_read_ptr - fp->_IO_read_end;\n  else\n    marker->_pos = fp->_IO_read_ptr - fp->_IO_read_base;\n\n  /* Should perhaps sort the chain? */\n  marker->_next = fp->_markers;\n  fp->_markers = marker;\n}",
    "_IO_remove_marker(struct _IO_marker *)": "void\n_IO_remove_marker (struct _IO_marker *marker)\n{\n  /* Unlink from sb's chain. */\n  struct _IO_marker **ptr = &marker->_sbuf->_markers;\n  for (; ; ptr = &(*ptr)->_next)\n    {\n      if (*ptr == NULL)\n\tbreak;\n      else if (*ptr == marker)\n\t{\n\t  *ptr = marker->_next;\n\t  return;\n\t}\n    }\n  /* FIXME: if _sbuf has a backup area that is no longer needed,\n     should we delete it now, or wait until the next underflow? */\n}",
    "_IO_marker_difference(struct _IO_marker *, struct _IO_marker *)": "int\n_IO_marker_difference (struct _IO_marker *mark1, struct _IO_marker *mark2)\n{\n  return mark1->_pos - mark2->_pos;\n}",
    "_IO_marker_delta(struct _IO_marker *)": "int\n_IO_marker_delta (struct _IO_marker *mark)\n{\n  int cur_pos;\n  if (mark->_sbuf == NULL)\n    return BAD_DELTA;\n  if (_IO_in_backup (mark->_sbuf))\n    cur_pos = mark->_sbuf->_IO_read_ptr - mark->_sbuf->_IO_read_end;\n  else\n    cur_pos = mark->_sbuf->_IO_read_ptr - mark->_sbuf->_IO_read_base;\n  return mark->_pos - cur_pos;\n}",
    "_IO_seekmark(FILE *, struct _IO_marker *, int)": "int\n_IO_seekmark (FILE *fp, struct _IO_marker *mark, int delta)\n{\n  if (mark->_sbuf != fp)\n    return EOF;\n if (mark->_pos >= 0)\n    {\n      if (_IO_in_backup (fp))\n\t_IO_switch_to_main_get_area (fp);\n      fp->_IO_read_ptr = fp->_IO_read_base + mark->_pos;\n    }\n  else\n    {\n      if (!_IO_in_backup (fp))\n\t_IO_switch_to_backup_area (fp);\n      fp->_IO_read_ptr = fp->_IO_read_end + mark->_pos;\n    }\n  return 0;\n}",
    "_IO_unsave_markers(FILE *)": "void\n_IO_unsave_markers (FILE *fp)\n{\n  struct _IO_marker *mark = fp->_markers;\n  if (mark)\n    {\n      fp->_markers = 0;\n    }\n\n  if (_IO_have_backup (fp))\n    _IO_free_backup_area (fp);\n}",
    "_IO_getc(FILE *)": "int\n_IO_getc (FILE *fp)\n{\n  int result;\n  CHECK_FILE (fp, EOF);\n  if (!_IO_need_lock (fp))\n    return _IO_getc_unlocked (fp);\n  _IO_acquire_lock (fp);\n  result = _IO_getc_unlocked (fp);\n  _IO_release_lock (fp);\n  return result;\n}",
    "getwchar()": "wint_t\ngetwchar (void)\n{\n  wint_t result;\n  _IO_acquire_lock (stdin);\n  result = _IO_getwc_unlocked (stdin);\n  _IO_release_lock (stdin);\n  return result;\n}",
    "getwchar_unlocked()": "wint_t\ngetwchar_unlocked (void)\n{\n  return _IO_getwc_unlocked (stdin);\n}",
    "_IO_fflush(FILE *)": "int\n_IO_fflush (FILE *fp)\n{\n  if (fp == NULL)\n    return _IO_flush_all ();\n  else\n    {\n      int result;\n      CHECK_FILE (fp, EOF);\n      _IO_acquire_lock (fp);\n      result = _IO_SYNC (fp) ? EOF : 0;\n      _IO_release_lock (fp);\n      return result;\n    }\n}",
    "_IO_fgets(char *, int, FILE *)": "char *\n_IO_fgets (char *buf, int n, FILE *fp)\n{\n  size_t count;\n  char *result;\n  int old_error;\n  CHECK_FILE (fp, NULL);\n  if (n <= 0)\n    return NULL;\n  if (__glibc_unlikely (n == 1))\n    {\n      /* Another irregular case: since we have to store a NUL byte and\n\t there is only room for exactly one byte, we don't have to\n\t read anything.  */\n      buf[0] = '\\0';\n      return buf;\n    }\n  _IO_acquire_lock (fp);\n  /* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */\n  old_error = fp->_flags & _IO_ERR_SEEN;\n  fp->_flags &= ~_IO_ERR_SEEN;\n  count = _IO_getline (fp, buf, n - 1, '\\n', 1);\n  /* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */\n  if (count == 0 || ((fp->_flags & _IO_ERR_SEEN) && errno != EAGAIN))\n    result = NULL;\n  else\n    {\n      buf[count] = '\\0';\n      result = buf;\n    }\n  fp->_flags |= old_error;\n  _IO_release_lock (fp);\n  return result;\n}",
    "fgetws(int *, int, FILE *)": "wchar_t *\nfgetws (wchar_t *buf, int n, FILE *fp)\n{\n  size_t count;\n  wchar_t *result;\n  int old_error;\n  CHECK_FILE (fp, NULL);\n  if (n <= 0)\n    return NULL;\n  if (__glibc_unlikely (n == 1))\n    {\n      /* Another irregular case: since we have to store a NUL byte and\n\t there is only room for exactly one byte, we don't have to\n\t read anything.  */\n      buf[0] = L'\\0';\n      return buf;\n    }\n  _IO_acquire_lock (fp);\n  /* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */\n  old_error = fp->_flags & _IO_ERR_SEEN;\n  fp->_flags &= ~_IO_ERR_SEEN;\n  count = _IO_getwline (fp, buf, n - 1, L'\\n', 1);\n  /* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */\n  if (count == 0 || (_IO_ferror_unlocked (fp) && errno != EAGAIN))\n    result = NULL;\n  else\n    {\n      buf[count] = '\\0';\n      result = buf;\n    }\n  fp->_flags |= old_error;\n  _IO_release_lock (fp);\n  return result;\n}",
    "fgetws_unlocked(int *, int, FILE *)": "wchar_t *\nfgetws_unlocked (wchar_t *buf, int n, FILE *fp)\n{\n  size_t count;\n  wchar_t *result;\n  int old_error;\n  CHECK_FILE (fp, NULL);\n  if (n <= 0)\n    return NULL;\n  if (__glibc_unlikely (n == 1))\n    {\n      /* Another irregular case: since we have to store a NUL byte and\n\t there is only room for exactly one byte, we don't have to\n\t read anything.  */\n      buf[0] = L'\\0';\n      return buf;\n    }\n  /* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */\n  old_error = fp->_flags & _IO_ERR_SEEN;\n  fp->_flags &= ~_IO_ERR_SEEN;\n  count = _IO_getwline (fp, buf, n - 1, L'\\n', 1);\n  /* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */\n  if (count == 0 || ((fp->_flags & _IO_ERR_SEEN) && errno != EAGAIN))\n    result = NULL;\n  else\n    {\n      buf[count] = '\\0';\n      result = buf;\n    }\n  fp->_flags |= old_error;\n  return result;\n}",
    "_IO_fputs(const char *, FILE *)": "int\n_IO_fputs (const char *str, FILE *fp)\n{\n  size_t len = strlen (str);\n  int result = EOF;\n  CHECK_FILE (fp, EOF);\n  _IO_acquire_lock (fp);\n  if ((_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1)\n      && _IO_sputn (fp, str, len) == len)\n    result = 1;\n  _IO_release_lock (fp);\n  return result;\n}",
    "fputws(const int *, FILE *)": "int\nfputws (const wchar_t *str, FILE *fp)\n{\n  size_t len = __wcslen (str);\n  int result = EOF;\n  CHECK_FILE (fp, EOF);\n  _IO_acquire_lock (fp);\n  if (_IO_fwide (fp, 1) == 1\n      && _IO_sputn (fp, (char *) str, len) == len)\n    result = 1;\n  _IO_release_lock (fp);\n  return result;\n}",
    "fputws_unlocked(const int *, FILE *)": "int\nfputws_unlocked (const wchar_t *str, FILE *fp)\n{\n  size_t len = __wcslen (str);\n  int result = EOF;\n  CHECK_FILE (fp, EOF);\n  if (_IO_fwide (fp, 1) == 1\n      && _IO_sputn (fp, (char *) str, len) == len)\n    result = 1;\n  return result;\n}",
    "_IO_fread(void *, int, int, FILE *)": "size_t\n_IO_fread (void *buf, size_t size, size_t count, FILE *fp)\n{\n  size_t bytes_requested = size * count;\n  size_t bytes_read;\n  CHECK_FILE (fp, 0);\n  if (bytes_requested == 0)\n    return 0;\n  _IO_acquire_lock (fp);\n  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);\n  _IO_release_lock (fp);\n  return bytes_requested == bytes_read ? count : bytes_read / size;\n}",
    "_IO_ftell(FILE *)": "long int\n_IO_ftell (FILE *fp)\n{\n  off64_t pos;\n  CHECK_FILE (fp, -1L);\n  _IO_acquire_lock (fp);\n  pos = _IO_seekoff_unlocked (fp, 0, _IO_seek_cur, 0);\n  if (_IO_in_backup (fp) && pos != _IO_pos_BAD)\n    {\n      if (_IO_vtable_offset (fp) != 0 || fp->_mode <= 0)\n\tpos -= fp->_IO_save_end - fp->_IO_save_base;\n    }\n  _IO_release_lock (fp);\n  if (pos == _IO_pos_BAD)\n    {\n      if (errno == 0)\n\t__set_errno (EIO);\n      return -1L;\n    }\n  if ((off64_t) (long int) pos != pos)\n    {\n      __set_errno (EOVERFLOW);\n      return -1L;\n    }\n  return pos;\n}",
    "_IO_fwrite(const void *, int, int, FILE *)": "size_t\n_IO_fwrite (const void *buf, size_t size, size_t count, FILE *fp)\n{\n  size_t request = size * count;\n  size_t written = 0;\n  CHECK_FILE (fp, 0);\n  if (request == 0)\n    return 0;\n  _IO_acquire_lock (fp);\n  if (_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1)\n    written = _IO_sputn (fp, (const char *) buf, request);\n  _IO_release_lock (fp);\n  /* We have written all of the input in case the return value indicates\n     this or EOF is returned.  The latter is a special case where we\n     simply did not manage to flush the buffer.  But the data is in the\n     buffer and therefore written as far as fwrite is concerned.  */\n  if (written == request || written == EOF)\n    return count;\n  else\n    return written / size;\n}",
    "fwrite_unlocked(const void *, int, int, FILE *)": "size_t\nfwrite_unlocked (const void *buf, size_t size, size_t count, FILE *fp)\n{\n  size_t request = size * count;\n  size_t written = 0;\n  CHECK_FILE (fp, 0);\n  if (request == 0)\n    return 0;\n  if (_IO_fwide (fp, -1) == -1)\n    {\n      written = _IO_sputn (fp, (const char *) buf, request);\n      /* We have written all of the input in case the return value indicates\n\t this or EOF is returned.  The latter is a special case where we\n\t simply did not manage to flush the buffer.  But the data is in the\n\t buffer and therefore written as far as fwrite is concerned.  */\n      if (written == request || written == EOF)\n\treturn count;\n    }\n\n  return written / size;\n}",
    "__getdelim(char **, int *, int, FILE *)": "ssize_t\n__getdelim (char **lineptr, size_t *n, int delimiter, FILE *fp)\n{\n  ssize_t result;\n  ssize_t cur_len = 0;\n  ssize_t len;\n\n  CHECK_FILE (fp, -1);\n  _IO_acquire_lock (fp);\n  if (_IO_ferror_unlocked (fp))\n    {\n      result = -1;\n      goto unlock_return;\n    }\n\n  if (lineptr == NULL || n == NULL)\n    {\n      __set_errno (EINVAL);\n      fseterr_unlocked (fp);\n      result = -1;\n      goto unlock_return;\n    }\n\n  if (*lineptr == NULL || *n == 0)\n    {\n      *n = 120;\n      *lineptr = (char *) malloc (*n);\n      if (*lineptr == NULL)\n\t{\n\t  fseterr_unlocked (fp);\n\t  result = -1;\n\t  goto unlock_return;\n\t}\n    }\n\n  len = fp->_IO_read_end - fp->_IO_read_ptr;\n  if (len <= 0)\n    {\n      if (__underflow (fp) == EOF)\n\t{\n\t  result = -1;\n\t  goto unlock_return;\n\t}\n      len = fp->_IO_read_end - fp->_IO_read_ptr;\n    }\n\n  for (;;)\n    {\n      size_t needed;\n      char *t;\n      t = (char *) memchr ((void *) fp->_IO_read_ptr, delimiter, len);\n      if (t != NULL)\n\tlen = (t - fp->_IO_read_ptr) + 1;\n      if (__glibc_unlikely (len >= SSIZE_MAX - cur_len))\n\t{\n\t  __set_errno (EOVERFLOW);\n\t  fseterr_unlocked (fp);\n\t  result = -1;\n\t  goto unlock_return;\n\t}\n      /* Make enough space for len+1 (for final NUL) bytes.  */\n      needed = cur_len + len + 1;\n      if (needed > *n)\n\t{\n\t  char *new_lineptr;\n\n\t  if (needed < 2 * *n)\n\t    needed = 2 * *n;  /* Be generous. */\n\t  new_lineptr = (char *) realloc (*lineptr, needed);\n\t  if (new_lineptr == NULL)\n\t    {\n\t      fseterr_unlocked (fp);\n\t      result = -1;\n\t      goto unlock_return;\n\t    }\n\t  *lineptr = new_lineptr;\n\t  *n = needed;\n\t}\n      memcpy (*lineptr + cur_len, (void *) fp->_IO_read_ptr, len);\n      fp->_IO_read_ptr += len;\n      cur_len += len;\n      if (t != NULL || __underflow (fp) == EOF)\n\tbreak;\n      len = fp->_IO_read_end - fp->_IO_read_ptr;\n    }\n  (*lineptr)[cur_len] = '\\0';\n  result = cur_len;\n\nunlock_return:\n  _IO_release_lock (fp);\n  return result;\n}",
    "_IO_getline(FILE *, char *, int, int, int)": "size_t\n_IO_getline (FILE *fp, char *buf, size_t n, int delim,\n\t     int extract_delim)\n{\n  return _IO_getline_info (fp, buf, n, delim, extract_delim, (int *) 0);\n}",
    "_IO_gets(char *)": "char *\n_IO_gets (char *buf)\n{\n  size_t count;\n  int ch;\n  char *retval;\n\n  _IO_acquire_lock (stdin);\n  ch = _IO_getc_unlocked (stdin);\n  if (ch == EOF)\n    {\n      retval = NULL;\n      goto unlock_return;\n    }\n  if (ch == '\\n')\n    count = 0;\n  else\n    {\n      /* This is very tricky since a file descriptor may be in the\n\t non-blocking mode. The error flag doesn't mean much in this\n\t case. We return an error only when there is a new error. */\n      int old_error = stdin->_flags & _IO_ERR_SEEN;\n      stdin->_flags &= ~_IO_ERR_SEEN;\n      buf[0] = (char) ch;\n      count = _IO_getline (stdin, buf + 1, INT_MAX, '\\n', 0) + 1;\n      if (stdin->_flags & _IO_ERR_SEEN)\n\t{\n\t  retval = NULL;\n\t  goto unlock_return;\n\t}\n      else\n\tstdin->_flags |= old_error;\n    }\n  buf[count] = 0;\n  retval = buf;\nunlock_return:\n  _IO_release_lock (stdin);\n  return retval;\n}",
    "_IO_padn(FILE *, int, ssize_t)": "ssize_t\n_IO_padn (FILE *fp, int pad, ssize_t count)\n{\n  char padbuf[PADSIZE];\n  const char *padptr;\n  int i;\n  size_t written = 0;\n  size_t w;\n\n  if (pad == ' ')\n    padptr = blanks;\n  else if (pad == '0')\n    padptr = zeroes;\n  else\n    {\n      for (i = PADSIZE; --i >= 0; )\n\tpadbuf[i] = pad;\n      padptr = padbuf;\n    }\n  for (i = count; i >= PADSIZE; i -= PADSIZE)\n    {\n      w = _IO_sputn (fp, padptr, PADSIZE);\n      written += w;\n      if (w != PADSIZE)\n\treturn written;\n    }\n\n  if (i > 0)\n    {\n      w = _IO_sputn (fp, padptr, i);\n      written += w;\n    }\n  return written;\n}",
    "_IO_puts(const char *)": "int\n_IO_puts (const char *str)\n{\n  int result = EOF;\n  size_t len = strlen (str);\n  _IO_acquire_lock (stdout);\n\n  if ((_IO_vtable_offset (stdout) != 0\n       || _IO_fwide (stdout, -1) == -1)\n      && _IO_sputn (stdout, str, len) == len\n      && _IO_putc_unlocked ('\\n', stdout) != EOF)\n    result = MIN (INT_MAX, len + 1);\n\n  _IO_release_lock (stdout);\n  return result;\n}",
    "_IO_seekoff(FILE *, int, int, int)": "off64_t\n_IO_seekoff (FILE *fp, off64_t offset, int dir, int mode)\n{\n  off64_t retval;\n\n  _IO_acquire_lock (fp);\n  retval = _IO_seekoff_unlocked (fp, offset, dir, mode);\n  _IO_release_lock (fp);\n  return retval;\n}",
    "_IO_seekpos(FILE *, int, int)": "off64_t\n_IO_seekpos (FILE *fp, off64_t pos, int mode)\n{\n  off64_t retval;\n\n  _IO_acquire_lock (fp);\n  retval = _IO_seekpos_unlocked (fp, pos, mode);\n  _IO_release_lock (fp);\n  return retval;\n}",
    "_IO_setbuffer(FILE *, char *, int)": "void\n_IO_setbuffer (FILE *fp, char *buf, size_t size)\n{\n  CHECK_FILE (fp, );\n  _IO_acquire_lock (fp);\n  fp->_flags &= ~_IO_LINE_BUF;\n  if (!buf)\n    size = 0;\n  (void) _IO_SETBUF (fp, buf, size);\n  if (_IO_vtable_offset (fp) == 0 && fp->_mode == 0 && _IO_CHECK_WIDE (fp))\n    /* We also have to set the buffer using the wide char function.  */\n    (void) _IO_WSETBUF (fp, buf, size);\n  _IO_release_lock (fp);\n}",
    "_IO_setvbuf(FILE *, char *, int, int)": "int\n_IO_setvbuf (FILE *fp, char *buf, int mode, size_t size)\n{\n  int result;\n  CHECK_FILE (fp, EOF);\n  _IO_acquire_lock (fp);\n  switch (mode)\n    {\n    case _IOFBF:\n      fp->_flags &= ~(_IO_LINE_BUF|_IO_UNBUFFERED);\n      if (buf == NULL)\n\t{\n\t  if (fp->_IO_buf_base == NULL)\n\t    {\n\t      /* There is no flag to distinguish between \"fully buffered\n\t\t mode has been explicitly set\" as opposed to \"line\n\t\t buffering has not been explicitly set\".  In both\n\t\t cases, _IO_LINE_BUF is off.  If this is a tty, and\n\t\t _IO_filedoalloc later gets called, it cannot know if\n\t\t it should set the _IO_LINE_BUF flag (because that is\n\t\t the default), or not (because we have explicitly asked\n\t\t for fully buffered mode).  So we make sure a buffer\n\t\t gets allocated now, and explicitly turn off line\n\t\t buffering.\n\n\t\t A possibly cleaner alternative would be to add an\n\t\t extra flag, but then flags are a finite resource.  */\n\t      if (_IO_DOALLOCATE (fp) < 0)\n\t\t{\n\t\t  result = EOF;\n\t\t  goto unlock_return;\n\t\t}\n\t      fp->_flags &= ~_IO_LINE_BUF;\n\t    }\n\t  result = 0;\n\t  goto unlock_return;\n\t}\n      break;\n    case _IOLBF:\n      fp->_flags &= ~_IO_UNBUFFERED;\n      fp->_flags |= _IO_LINE_BUF;\n      if (buf == NULL)\n\t{\n\t  result = 0;\n\t  goto unlock_return;\n\t}\n      break;\n    case _IONBF:\n      fp->_flags &= ~_IO_LINE_BUF;\n      fp->_flags |= _IO_UNBUFFERED;\n      buf = NULL;\n      size = 0;\n      break;\n    default:\n      result = EOF;\n      goto unlock_return;\n    }\n  result = _IO_SETBUF (fp, buf, size) == NULL ? EOF : 0;\n\nunlock_return:\n  _IO_release_lock (fp);\n  return result;\n}",
    "ungetc(int, FILE *)": "int\nungetc (int c, FILE *fp)\n{\n  int result;\n  CHECK_FILE (fp, EOF);\n  if (c == EOF)\n    return EOF;\n  if (!_IO_need_lock (fp))\n    return _IO_sputbackc (fp, (unsigned char) c);\n  _IO_acquire_lock (fp);\n  result = _IO_sputbackc (fp, (unsigned char) c);\n  _IO_release_lock (fp);\n  return result;\n}",
    "ungetwc(wint_t, FILE *)": "wint_t\nungetwc (wint_t c, FILE *fp)\n{\n  wint_t result;\n  CHECK_FILE (fp, WEOF);\n  _IO_acquire_lock (fp);\n  _IO_fwide (fp, 1);\n  if (c == WEOF)\n    result = WEOF;\n  else\n    result = _IO_sputbackwc (fp, c);\n  _IO_release_lock (fp);\n  return result;\n}",
    "__libc_fatal(const char *)": "void\n__libc_fatal (const char *message)\n{\n  /* The loop is added only to keep gcc happy.  */\n  while (1)\n    __libc_message (\"%s\", message);\n}",
    "_IO_peekc_locked(FILE *)": "int\n_IO_peekc_locked (FILE *fp)\n{\n  int result;\n  CHECK_FILE (fp, EOF);\n  _IO_acquire_lock (fp);\n  result = _IO_peekc_unlocked (fp);\n  _IO_release_lock (fp);\n  return result;\n}",
    "_IO_putc(int, FILE *)": "int\n_IO_putc (int c, FILE *fp)\n{\n  int result;\n  CHECK_FILE (fp, EOF);\n  if (!_IO_need_lock (fp))\n    return _IO_putc_unlocked (c, fp);\n  _IO_acquire_lock (fp);\n  result = _IO_putc_unlocked (c, fp);\n  _IO_release_lock (fp);\n  return result;\n}",
    "putwc(int, FILE *)": "wint_t\nputwc (wchar_t wc, FILE *fp)\n{\n  wint_t result;\n  CHECK_FILE (fp, WEOF);\n  _IO_acquire_lock (fp);\n  result = _IO_putwc_unlocked (wc, fp);\n  _IO_release_lock (fp);\n  return result;\n}",
    "putwc_unlocked(int, FILE *)": "wint_t\nputwc_unlocked (wchar_t wc, FILE *fp)\n{\n  CHECK_FILE (fp, WEOF);\n  return _IO_putwc_unlocked (wc, fp);\n}",
    "putwchar(int)": "wint_t\nputwchar (wchar_t wc)\n{\n  wint_t result;\n  _IO_acquire_lock (stdout);\n  result = _IO_putwc_unlocked (wc, stdout);\n  _IO_release_lock (stdout);\n  return result;\n}",
    "putwchar_unlocked(int)": "wint_t\nputwchar_unlocked (wchar_t wc)\n{\n  CHECK_FILE (stdout, WEOF);\n  return _IO_putwc_unlocked (wc, stdout);\n}",
    "rewind(FILE *)": "void\nrewind (FILE *fp)\n{\n  CHECK_FILE (fp, );\n  _IO_acquire_lock (fp);\n  _IO_rewind (fp);\n  _IO_clearerr (fp);\n  _IO_release_lock (fp);\n}",
    "setbuf(FILE *, char *)": "void\nsetbuf (FILE *fp, char *buf)\n{\n  _IO_setbuffer (fp, buf, BUFSIZ);\n}",
    "setlinebuf(FILE *)": "void\nsetlinebuf (FILE *stream)\n{\n  _IO_setvbuf (stream, NULL, 1, 0);\n}",
    "_IO_str_init_static(_IO_strfile *, char *, int, char *)": "void\n_IO_str_init_static (_IO_strfile *sf, char *ptr, int size, char *pstart)\n{\n  return _IO_str_init_static_internal (sf, ptr, size < 0 ? -1 : size, pstart);\n}",
    "_IO_str_init_readonly(_IO_strfile *, const char *, int)": "void\n_IO_str_init_readonly (_IO_strfile *sf, const char *ptr, int size)\n{\n  _IO_str_init_static_internal (sf, (char *) ptr, size < 0 ? -1 : size, NULL);\n  sf->_sbf._f._flags |= _IO_NO_WRITES;\n}",
    "_IO_str_overflow(FILE *, int)": "int\n_IO_str_overflow (FILE *fp, int c)\n{\n  int flush_only = c == EOF;\n  size_t pos;\n  if (fp->_flags & _IO_NO_WRITES)\n      return flush_only ? 0 : EOF;\n  if ((fp->_flags & _IO_TIED_PUT_GET) && !(fp->_flags & _IO_CURRENTLY_PUTTING))\n    {\n      fp->_flags |= _IO_CURRENTLY_PUTTING;\n      fp->_IO_write_ptr = fp->_IO_read_ptr;\n      fp->_IO_read_ptr = fp->_IO_read_end;\n    }\n  pos = fp->_IO_write_ptr - fp->_IO_write_base;\n  if (pos >= (size_t) (_IO_blen (fp) + flush_only))\n    {\n      if (fp->_flags & _IO_USER_BUF) /* not allowed to enlarge */\n\treturn EOF;\n      else\n\t{\n\t  char *new_buf;\n\t  char *old_buf = fp->_IO_buf_base;\n\t  size_t old_blen = _IO_blen (fp);\n\t  size_t new_size = 2 * old_blen + 100;\n\t  if (new_size < old_blen)\n\t    return EOF;\n\t  new_buf = malloc (new_size);\n\t  if (new_buf == NULL)\n\t    {\n\t      /*\t  __ferror(fp) = 1; */\n\t      return EOF;\n\t    }\n\t  if (old_buf)\n\t    {\n\t      memcpy (new_buf, old_buf, old_blen);\n\t      free (old_buf);\n\t      /* Make sure _IO_setb won't try to delete _IO_buf_base. */\n\t      fp->_IO_buf_base = NULL;\n\t    }\n\t  memset (new_buf + old_blen, '\\0', new_size - old_blen);\n\n\t  _IO_setb (fp, new_buf, new_buf + new_size, 1);\n\t  fp->_IO_read_base = new_buf + (fp->_IO_read_base - old_buf);\n\t  fp->_IO_read_ptr = new_buf + (fp->_IO_read_ptr - old_buf);\n\t  fp->_IO_read_end = new_buf + (fp->_IO_read_end - old_buf);\n\t  fp->_IO_write_ptr = new_buf + (fp->_IO_write_ptr - old_buf);\n\n\t  fp->_IO_write_base = new_buf;\n\t  fp->_IO_write_end = fp->_IO_buf_end;\n\t}\n    }\n\n  if (!flush_only)\n    *fp->_IO_write_ptr++ = (unsigned char) c;\n  if (fp->_IO_write_ptr > fp->_IO_read_end)\n    fp->_IO_read_end = fp->_IO_write_ptr;\n  if (flush_only)\n    return 0;\n  else\n    return c;\n}",
    "_IO_str_seekoff(FILE *, int, int, int)": "off64_t\n_IO_str_seekoff (FILE *fp, off64_t offset, int dir, int mode)\n{\n  off64_t new_pos;\n\n  if (mode == 0 && (fp->_flags & _IO_TIED_PUT_GET))\n    mode = (fp->_flags & _IO_CURRENTLY_PUTTING ? _IOS_OUTPUT : _IOS_INPUT);\n\n  bool was_writing = (fp->_IO_write_ptr > fp->_IO_write_base\n\t\t     || _IO_in_put_mode (fp));\n  if (was_writing)\n    _IO_str_switch_to_get_mode (fp);\n\n  if (mode == 0)\n    {\n      new_pos = fp->_IO_read_ptr - fp->_IO_read_base;\n    }\n  else\n    {\n      ssize_t cur_size = _IO_str_count(fp);\n      new_pos = EOF;\n\n      /* Move the get pointer, if requested. */\n      if (mode & _IOS_INPUT)\n\t{\n\t  ssize_t base;\n\t  switch (dir)\n\t    {\n\t    case _IO_seek_set:\n\t      base = 0;\n\t      break;\n\t    case _IO_seek_cur:\n\t      base = fp->_IO_read_ptr - fp->_IO_read_base;\n\t      break;\n\t    default: /* case _IO_seek_end: */\n\t      base = cur_size;\n\t      break;\n\t    }\n\t  ssize_t maxval = SSIZE_MAX - base;\n\t  if (offset < -base || offset > maxval)\n\t    {\n\t      __set_errno (EINVAL);\n\t      return EOF;\n\t    }\n\t  base += offset;\n\t  if (base > cur_size\n\t      && enlarge_userbuf (fp, base, 1) != 0)\n\t    return EOF;\n\t  fp->_IO_read_ptr = fp->_IO_read_base + base;\n\t  fp->_IO_read_end = fp->_IO_read_base + cur_size;\n\t  new_pos = base;\n\t}\n\n      /* Move the put pointer, if requested. */\n      if (mode & _IOS_OUTPUT)\n\t{\n\t  ssize_t base;\n\t  switch (dir)\n\t    {\n\t    case _IO_seek_set:\n\t      base = 0;\n\t      break;\n\t    case _IO_seek_cur:\n\t      base = fp->_IO_write_ptr - fp->_IO_write_base;\n\t      break;\n\t    default: /* case _IO_seek_end: */\n\t      base = cur_size;\n\t      break;\n\t    }\n\t  ssize_t maxval = SSIZE_MAX - base;\n\t  if (offset < -base || offset > maxval)\n\t    {\n\t      __set_errno (EINVAL);\n\t      return EOF;\n\t    }\n\t  base += offset;\n\t  if (base > cur_size\n\t      && enlarge_userbuf (fp, base, 0) != 0)\n\t    return EOF;\n\t  fp->_IO_write_ptr = fp->_IO_write_base + base;\n\t  new_pos = base;\n\t}\n    }\n  return new_pos;\n}",
    "_IO_wdo_write(FILE *, const int *, int)": "int\n_IO_wdo_write (FILE *fp, const wchar_t *data, size_t to_do)\n{\n  struct _IO_codecvt *cc = fp->_codecvt;\n\n  if (to_do > 0)\n    {\n      if (fp->_IO_write_end == fp->_IO_write_ptr\n\t  && fp->_IO_write_end != fp->_IO_write_base)\n\t{\n\t  if (_IO_new_do_write (fp, fp->_IO_write_base,\n\t\t\t\tfp->_IO_write_ptr - fp->_IO_write_base) == EOF)\n\t    return WEOF;\n\t}\n\n      do\n\t{\n\t  enum __codecvt_result result;\n\t  const wchar_t *new_data;\n\t  char mb_buf[MB_LEN_MAX];\n\t  char *write_base, *write_ptr, *buf_end;\n\n\t  if (fp->_IO_buf_end - fp->_IO_write_ptr < sizeof (mb_buf))\n\t    {\n\t      /* Make sure we have room for at least one multibyte\n\t\t character.  */\n\t      write_ptr = write_base = mb_buf;\n\t      buf_end = mb_buf + sizeof (mb_buf);\n\t    }\n\t  else\n\t    {\n\t      write_ptr = fp->_IO_write_ptr;\n\t      write_base = fp->_IO_write_base;\n\t      buf_end = fp->_IO_buf_end;\n\t    }\n\n\t  /* Now convert from the internal format into the external buffer.  */\n\t  result = __libio_codecvt_out (cc, &fp->_wide_data->_IO_state,\n\t\t\t\t\tdata, data + to_do, &new_data,\n\t\t\t\t\twrite_ptr,\n\t\t\t\t\tbuf_end,\n\t\t\t\t\t&write_ptr);\n\n\t  /* Write out what we produced so far.  */\n\t  if (_IO_new_do_write (fp, write_base, write_ptr - write_base) == EOF)\n\t    /* Something went wrong.  */\n\t    return WEOF;\n\n\t  to_do -= new_data - data;\n\n\t  /* Next see whether we had problems during the conversion.  If yes,\n\t     we cannot go on.  */\n\t  if (result != __codecvt_ok\n\t      && (result != __codecvt_partial || new_data - data == 0))\n\t    break;\n\n\t  data = new_data;\n\t}\n      while (to_do > 0);\n    }\n\n  _IO_wsetg (fp, fp->_wide_data->_IO_buf_base, fp->_wide_data->_IO_buf_base,\n\t     fp->_wide_data->_IO_buf_base);\n  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_write_ptr\n    = fp->_wide_data->_IO_buf_base;\n  fp->_wide_data->_IO_write_end = ((fp->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))\n\t\t\t\t   ? fp->_wide_data->_IO_buf_base\n\t\t\t\t   : fp->_wide_data->_IO_buf_end);\n\n  return to_do == 0 ? 0 : WEOF;\n}",
    "_IO_wfile_overflow(FILE *, wint_t)": "wint_t\n_IO_wfile_overflow (FILE *f, wint_t wch)\n{\n  if (f->_flags & _IO_NO_WRITES) /* SET ERROR */\n    {\n      f->_flags |= _IO_ERR_SEEN;\n      __set_errno (EBADF);\n      return WEOF;\n    }\n  /* If currently reading or no buffer allocated. */\n  if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0\n      || f->_wide_data->_IO_write_base == NULL)\n    {\n      /* Allocate a buffer if needed. */\n      if (f->_wide_data->_IO_write_base == 0)\n\t{\n\t  _IO_wdoallocbuf (f);\n\t  _IO_free_wbackup_area (f);\n\t  _IO_wsetg (f, f->_wide_data->_IO_buf_base,\n\t\t     f->_wide_data->_IO_buf_base, f->_wide_data->_IO_buf_base);\n\n\t  if (f->_IO_write_base == NULL)\n\t    {\n\t      _IO_doallocbuf (f);\n\t      _IO_setg (f, f->_IO_buf_base, f->_IO_buf_base, f->_IO_buf_base);\n\t    }\n\t}\n      else\n\t{\n\t  /* Otherwise must be currently reading.  If _IO_read_ptr\n\t     (and hence also _IO_read_end) is at the buffer end,\n\t     logically slide the buffer forwards one block (by setting\n\t     the read pointers to all point at the beginning of the\n\t     block).  This makes room for subsequent output.\n\t     Otherwise, set the read pointers to _IO_read_end (leaving\n\t     that alone, so it can continue to correspond to the\n\t     external position). */\n\t  if (f->_wide_data->_IO_read_ptr == f->_wide_data->_IO_buf_end)\n\t    {\n\t      f->_IO_read_end = f->_IO_read_ptr = f->_IO_buf_base;\n\t      f->_wide_data->_IO_read_end = f->_wide_data->_IO_read_ptr =\n\t\tf->_wide_data->_IO_buf_base;\n\t    }\n\t}\n      f->_wide_data->_IO_write_ptr = f->_wide_data->_IO_read_ptr;\n      f->_wide_data->_IO_write_base = f->_wide_data->_IO_write_ptr;\n      f->_wide_data->_IO_write_end = f->_wide_data->_IO_buf_end;\n      f->_wide_data->_IO_read_base = f->_wide_data->_IO_read_ptr =\n\tf->_wide_data->_IO_read_end;\n\n      f->_IO_write_ptr = f->_IO_read_ptr;\n      f->_IO_write_base = f->_IO_write_ptr;\n      f->_IO_write_end = f->_IO_buf_end;\n      f->_IO_read_base = f->_IO_read_ptr = f->_IO_read_end;\n\n      f->_flags |= _IO_CURRENTLY_PUTTING;\n      if (f->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))\n\tf->_wide_data->_IO_write_end = f->_wide_data->_IO_write_ptr;\n    }\n  if (wch == WEOF)\n    return _IO_do_flush (f);\n  if (f->_wide_data->_IO_write_ptr == f->_wide_data->_IO_buf_end)\n    /* Buffer is really full */\n    if (_IO_do_flush (f) == EOF)\n      return WEOF;\n  *f->_wide_data->_IO_write_ptr++ = wch;\n  if ((f->_flags & _IO_UNBUFFERED)\n      || ((f->_flags & _IO_LINE_BUF) && wch == L'\\n'))\n    if (_IO_do_flush (f) == EOF)\n      return WEOF;\n  return wch;\n}",
    "_IO_wfile_seekoff(FILE *, int, int, int)": "off64_t\n_IO_wfile_seekoff (FILE *fp, off64_t offset, int dir, int mode)\n{\n  off64_t result;\n  off64_t delta, new_offset;\n  long int count;\n\n  /* Short-circuit into a separate function.  We don't want to mix any\n     functionality and we don't want to touch anything inside the FILE\n     object. */\n  if (mode == 0)\n    return do_ftell_wide (fp);\n\n  /* POSIX.1 8.2.3.7 says that after a call the fflush() the file\n     offset of the underlying file must be exact.  */\n  int must_be_exact = ((fp->_wide_data->_IO_read_base\n\t\t\t== fp->_wide_data->_IO_read_end)\n\t\t       && (fp->_wide_data->_IO_write_base\n\t\t\t   == fp->_wide_data->_IO_write_ptr));\n\n  bool was_writing = ((fp->_wide_data->_IO_write_ptr\n\t\t       > fp->_wide_data->_IO_write_base)\n\t\t      || _IO_in_put_mode (fp));\n\n  /* Flush unwritten characters.\n     (This may do an unneeded write if we seek within the buffer.\n     But to be able to switch to reading, we would need to set\n     egptr to pptr.  That can't be done in the current design,\n     which assumes file_ptr() is eGptr.  Anyway, since we probably\n     end up flushing when we close(), it doesn't make much difference.)\n     FIXME: simulate mem-mapped files. */\n  if (was_writing && _IO_switch_to_wget_mode (fp))\n    return WEOF;\n\n  if (fp->_wide_data->_IO_buf_base == NULL)\n    {\n      /* It could be that we already have a pushback buffer.  */\n      if (fp->_wide_data->_IO_read_base != NULL)\n\t{\n\t  free (fp->_wide_data->_IO_read_base);\n\t  fp->_flags &= ~_IO_IN_BACKUP;\n\t}\n      _IO_doallocbuf (fp);\n      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n      _IO_wsetp (fp, fp->_wide_data->_IO_buf_base,\n\t\t fp->_wide_data->_IO_buf_base);\n      _IO_wsetg (fp, fp->_wide_data->_IO_buf_base,\n\t\t fp->_wide_data->_IO_buf_base, fp->_wide_data->_IO_buf_base);\n    }\n\n  switch (dir)\n    {\n      struct _IO_codecvt *cv;\n      int clen;\n\n    case _IO_seek_cur:\n      /* Adjust for read-ahead (bytes is buffer).  To do this we must\n\t find out which position in the external buffer corresponds to\n\t the current position in the internal buffer.  */\n      cv = fp->_codecvt;\n      clen = __libio_codecvt_encoding (cv);\n\n      if (mode != 0 || !was_writing)\n\t{\n\t  if (clen > 0)\n\t    {\n\t      offset -= (fp->_wide_data->_IO_read_end\n\t\t\t - fp->_wide_data->_IO_read_ptr) * clen;\n\t      /* Adjust by readahead in external buffer.  */\n\t      offset -= fp->_IO_read_end - fp->_IO_read_ptr;\n\t    }\n\t  else\n\t    {\n\t      int nread;\n\n\t      delta = (fp->_wide_data->_IO_read_ptr\n\t\t       - fp->_wide_data->_IO_read_base);\n\t      fp->_wide_data->_IO_state = fp->_wide_data->_IO_last_state;\n\t      nread = __libio_codecvt_length (cv,\n\t\t\t\t\t      &fp->_wide_data->_IO_state,\n\t\t\t\t\t      fp->_IO_read_base,\n\t\t\t\t\t      fp->_IO_read_end, delta);\n\t      fp->_IO_read_ptr = fp->_IO_read_base + nread;\n\t      fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_read_ptr;\n\t      offset -= fp->_IO_read_end - fp->_IO_read_base - nread;\n\t    }\n\t}\n\n      if (fp->_offset == _IO_pos_BAD)\n\tgoto dumb;\n\n      /* Make offset absolute, assuming current pointer is file_ptr(). */\n      offset += fp->_offset;\n\n      dir = _IO_seek_set;\n      break;\n    case _IO_seek_set:\n      break;\n    case _IO_seek_end:\n      {\n\tstruct __stat64_t64 st;\n\tif (_IO_SYSSTAT (fp, &st) == 0 && S_ISREG (st.st_mode))\n\t  {\n\t    offset += st.st_size;\n\t    dir = _IO_seek_set;\n\t  }\n\telse\n\t  goto dumb;\n      }\n    }\n\n  _IO_free_wbackup_area (fp);\n\n  /* At this point, dir==_IO_seek_set. */\n\n  /* If destination is within current buffer, optimize: */\n  if (fp->_offset != _IO_pos_BAD && fp->_IO_read_base != NULL\n      && !_IO_in_backup (fp))\n    {\n      off64_t start_offset = (fp->_offset\n                              - (fp->_IO_read_end - fp->_IO_buf_base));\n      if (offset >= start_offset && offset < fp->_offset)\n\t{\n\t  _IO_setg (fp, fp->_IO_buf_base,\n\t\t    fp->_IO_buf_base + (offset - start_offset),\n\t\t    fp->_IO_read_end);\n\t  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n\t  _IO_wsetg (fp, fp->_wide_data->_IO_buf_base,\n\t\t     fp->_wide_data->_IO_buf_base,\n\t\t     fp->_wide_data->_IO_buf_base);\n\t  _IO_wsetp (fp, fp->_wide_data->_IO_buf_base,\n\t\t     fp->_wide_data->_IO_buf_base);\n\n\t  if (adjust_wide_data (fp, false))\n\t    goto dumb;\n\n\t  _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n\t  goto resync;\n\t}\n    }\n\n  if (fp->_flags & _IO_NO_READS)\n    goto dumb;\n\n  /* Try to seek to a block boundary, to improve kernel page management. */\n  new_offset = offset & ~(fp->_IO_buf_end - fp->_IO_buf_base - 1);\n  delta = offset - new_offset;\n  if (delta > fp->_IO_buf_end - fp->_IO_buf_base)\n    {\n      new_offset = offset;\n      delta = 0;\n    }\n  result = _IO_SYSSEEK (fp, new_offset, 0);\n  if (result < 0)\n    return EOF;\n  if (delta == 0)\n    count = 0;\n  else\n    {\n      count = _IO_SYSREAD (fp, fp->_IO_buf_base,\n\t\t\t   (must_be_exact\n\t\t\t    ? delta : fp->_IO_buf_end - fp->_IO_buf_base));\n      if (count < delta)\n\t{\n\t  /* We weren't allowed to read, but try to seek the remainder. */\n\t  offset = count == EOF ? delta : delta-count;\n\t  dir = _IO_seek_cur;\n\t  goto dumb;\n\t}\n    }\n  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base + delta,\n\t    fp->_IO_buf_base + count);\n  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n  _IO_wsetg (fp, fp->_wide_data->_IO_buf_base,\n\t     fp->_wide_data->_IO_buf_base, fp->_wide_data->_IO_buf_base);\n  _IO_wsetp (fp, fp->_wide_data->_IO_buf_base, fp->_wide_data->_IO_buf_base);\n\n  if (adjust_wide_data (fp, true))\n    goto dumb;\n\n  fp->_offset = result + count;\n  _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n  return offset;\n dumb:\n\n  _IO_unsave_markers (fp);\n  result = _IO_SYSSEEK (fp, offset, dir);\n  if (result != EOF)\n    {\n      _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n      fp->_offset = result;\n      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n      _IO_wsetg (fp, fp->_wide_data->_IO_buf_base,\n\t\t fp->_wide_data->_IO_buf_base, fp->_wide_data->_IO_buf_base);\n      _IO_wsetp (fp, fp->_wide_data->_IO_buf_base,\n\t\t fp->_wide_data->_IO_buf_base);\n    }\n  return result;\n\nresync:\n  /* We need to do it since it is possible that the file offset in\n     the kernel may be changed behind our back. It may happen when\n     we fopen a file and then do a fork. One process may access the\n     file and the kernel file offset will be changed. */\n  if (fp->_offset >= 0)\n    _IO_SYSSEEK (fp, fp->_offset, 0);\n\n  return offset;\n}",
    "_IO_least_wmarker(FILE *, int *)": "ssize_t\n_IO_least_wmarker (FILE *fp, wchar_t *end_p)\n{\n  ssize_t least_so_far = end_p - fp->_wide_data->_IO_read_base;\n  struct _IO_marker *mark;\n  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n    if (mark->_pos < least_so_far)\n      least_so_far = mark->_pos;\n  return least_so_far;\n}",
    "open_wmemstream(int **, int *)": "FILE *\nopen_wmemstream (wchar_t **bufloc, size_t *sizeloc)\n{\n  struct locked_FILE\n  {\n    struct _IO_FILE_wmemstream fp;\n#ifdef _IO_MTSAFE_IO\n    _IO_lock_t lock;\n#endif\n    struct _IO_wide_data wd;\n  } *new_f;\n  wchar_t *buf;\n\n  new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));\n  if (new_f == NULL)\n    return NULL;\n#ifdef _IO_MTSAFE_IO\n  new_f->fp._sf._sbf._f._lock = &new_f->lock;\n#endif\n\n  buf = calloc (1, BUFSIZ);\n  if (buf == NULL)\n    {\n      free (new_f);\n      return NULL;\n    }\n  _IO_no_init (&new_f->fp._sf._sbf._f, 0, 0, &new_f->wd, &_IO_wmem_jumps);\n  _IO_fwide (&new_f->fp._sf._sbf._f, 1);\n  _IO_wstr_init_static (&new_f->fp._sf._sbf._f, buf,\n\t\t\tBUFSIZ / sizeof (wchar_t), buf);\n  new_f->fp._sf._sbf._f._flags2 &= ~_IO_FLAGS2_USER_WBUF;\n  new_f->fp._sf._s._allocate_buffer_unused = (_IO_alloc_type) malloc;\n  new_f->fp._sf._s._free_buffer_unused = (_IO_free_type) free;\n\n  new_f->fp.bufloc = bufloc;\n  new_f->fp.sizeloc = sizeloc;\n\n  /* Disable single thread optimization.  BZ 21735.  */\n  new_f->fp._sf._sbf._f._flags2 |= _IO_FLAGS2_NEED_LOCK;\n\n  return (FILE *) &new_f->fp._sf._sbf;\n}",
    "__ctype_get_mb_cur_max()": "size_t\n__ctype_get_mb_cur_max (void)\n{\n  union locale_data_value u;\n\n  u.string = nl_langinfo (_NL_CTYPE_MB_CUR_MAX);\n  return ((size_t []) { 1, 1, 1, 2, 2, 3, 4 })[u.word];\n}",
    "__duplocale(locale_t)": "locale_t\n__duplocale (locale_t dataset)\n{\n  /* This static object is returned for newlocale (LC_ALL_MASK, \"C\").  */\n  if (dataset == _nl_C_locobj_ptr)\n    return dataset;\n\n  /* Handle a special value.  */\n  if (dataset == LC_GLOBAL_LOCALE)\n    dataset = &_nl_global_locale;\n\n  locale_t result;\n  int cnt;\n  size_t names_len = 0;\n\n  /* Calculate the total space we need to store all the names.  */\n  for (cnt = 0; cnt < __LC_LAST; ++cnt)\n    if (cnt != LC_ALL && dataset->__names[cnt] != _nl_C_name)\n      names_len += strlen (dataset->__names[cnt]) + 1;\n\n  /* Get memory.  */\n  result = malloc (sizeof (struct __locale_struct) + names_len);\n\n  if (result != NULL)\n    {\n      char *namep = (char *) (result + 1);\n\n      /* We modify global data (the usage counts).  */\n      __libc_rwlock_wrlock (__libc_setlocale_lock);\n\n      for (cnt = 0; cnt < __LC_LAST; ++cnt)\n\tif (cnt != LC_ALL)\n\t  {\n\t    result->__locales[cnt] = dataset->__locales[cnt];\n\t    if (result->__locales[cnt]->usage_count < MAX_USAGE_COUNT)\n\t      ++result->__locales[cnt]->usage_count;\n\n\t    if (dataset->__names[cnt] == _nl_C_name)\n\t      result->__names[cnt] = _nl_C_name;\n\t    else\n\t      {\n\t\tresult->__names[cnt] = namep;\n\t\tnamep = __stpcpy (namep, dataset->__names[cnt]) + 1;\n\t      }\n\t  }\n\n      /* Update the special members.  */\n      result->__ctype_b = dataset->__ctype_b;\n      result->__ctype_tolower = dataset->__ctype_tolower;\n      result->__ctype_toupper = dataset->__ctype_toupper;\n\n      /* It's done.  */\n      __libc_rwlock_unlock (__libc_setlocale_lock);\n    }\n\n  return result;\n}",
    "__freelocale(locale_t)": "void\n__freelocale (locale_t dataset)\n{\n  int cnt;\n\n  /* This static object is returned for newlocale (LC_ALL_MASK, \"C\").  */\n  if (dataset == _nl_C_locobj_ptr)\n    return;\n\n  /* We modify global data (the usage counts).  */\n  __libc_rwlock_wrlock (__libc_setlocale_lock);\n\n  for (cnt = 0; cnt < __LC_LAST; ++cnt)\n    if (cnt != LC_ALL && dataset->__locales[cnt]->usage_count != UNDELETABLE)\n      /* We can remove the data.  */\n      _nl_remove_locale (cnt, dataset->__locales[cnt]);\n\n  /* It's done.  */\n  __libc_rwlock_unlock (__libc_setlocale_lock);\n\n  /* Free the locale_t handle itself.  */\n  free (dataset);\n}",
    "__newlocale(int, const char *, locale_t)": "locale_t\n__newlocale (int category_mask, const char *locale, locale_t base)\n{\n  /* Intermediate memory for result.  */\n  const char *newnames[__LC_LAST];\n  struct __locale_struct result;\n  locale_t result_ptr;\n  char *locale_path;\n  size_t locale_path_len;\n  const char *locpath_var;\n  int cnt;\n  size_t names_len;\n\n  /* We treat LC_ALL in the same way as if all bits were set.  */\n  if (category_mask == 1 << LC_ALL)\n    category_mask = (1 << __LC_LAST) - 1 - (1 << LC_ALL);\n\n  /* Sanity check for CATEGORY argument.  */\n  if ((category_mask & ~((1 << __LC_LAST) - 1 - (1 << LC_ALL))) != 0)\n    ERROR_RETURN;\n\n  /* `newlocale' does not support asking for the locale name. */\n  if (locale == NULL)\n    ERROR_RETURN;\n\n  if (base == _nl_C_locobj_ptr)\n    /* We're to modify BASE, returned for a previous call with \"C\".\n       We can't really modify the read-only structure, so instead\n       start over by copying it.  */\n    base = NULL;\n\n  if ((base == NULL || category_mask == (1 << __LC_LAST) - 1 - (1 << LC_ALL))\n      && (category_mask == 0 || !strcmp (locale, \"C\")))\n    /* Asking for the \"C\" locale needn't allocate a new object.  */\n    return _nl_C_locobj_ptr;\n\n  /* Allocate memory for the result.  */\n  if (base != NULL)\n    result = *base;\n  else\n    /* Fill with pointers to C locale data.  */\n    result = _nl_C_locobj;\n\n  /* If no category is to be set we return BASE if available or a\n     dataset using the C locale data.  */\n  if (category_mask == 0)\n    {\n      result_ptr = (locale_t) malloc (sizeof (struct __locale_struct));\n      if (result_ptr == NULL)\n\treturn NULL;\n      *result_ptr = result;\n\n      goto update;\n    }\n\n  /* We perhaps really have to load some data.  So we determine the\n     path in which to look for the data now.  The environment variable\n     `LOCPATH' must only be used when the binary has no SUID or SGID\n     bit set.  If using the default path, we tell _nl_find_locale\n     by passing null and it can check the canonical locale archive.  */\n  locale_path = NULL;\n  locale_path_len = 0;\n\n  locpath_var = getenv (\"LOCPATH\");\n  if (locpath_var != NULL && locpath_var[0] != '\\0')\n    {\n      if (__argz_create_sep (locpath_var, ':',\n\t\t\t     &locale_path, &locale_path_len) != 0)\n\treturn NULL;\n\n      if (__argz_add_sep (&locale_path, &locale_path_len,\n\t\t\t  _nl_default_locale_path, ':') != 0)\n\treturn NULL;\n    }\n\n  /* Get the names for the locales we are interested in.  We either\n     allow a composite name or a single name.  */\n  for (cnt = 0; cnt < __LC_LAST; ++cnt)\n    if (cnt != LC_ALL)\n      newnames[cnt] = locale;\n  if (strchr (locale, ';') != NULL)\n    {\n      /* This is a composite name.  Make a copy and split it up.  */\n      char *np = strdupa (locale);\n      char *cp;\n      int specified_mask = 0;\n\n      while ((cp = strchr (np, '=')) != NULL)\n\t{\n\t  for (cnt = 0; cnt < __LC_LAST; ++cnt)\n\t    if (cnt != LC_ALL\n\t\t&& (size_t) (cp - np) == _nl_category_name_sizes[cnt]\n\t\t&& memcmp (np, (_nl_category_names_get (cnt)), cp - np) == 0)\n\t      break;\n\n\t  if (cnt == __LC_LAST)\n\t    /* Bogus category name.  */\n\t    ERROR_RETURN;\n\n\t  /* Found the category this clause sets.  */\n\t  specified_mask |= 1 << cnt;\n\t  newnames[cnt] = ++cp;\n\t  cp = strchr (cp, ';');\n\t  if (cp != NULL)\n\t    {\n\t      /* Examine the next clause.  */\n\t      *cp = '\\0';\n\t      np = cp + 1;\n\t    }\n\t  else\n\t    /* This was the last clause.  We are done.  */\n\t    break;\n\t}\n\n      if (category_mask &~ specified_mask)\n\t/* The composite name did not specify all categories we need.  */\n\tERROR_RETURN;\n    }\n\n  /* Protect global data.  */\n  __libc_rwlock_wrlock (__libc_setlocale_lock);\n\n  /* Now process all categories we are interested in.  */\n  names_len = 0;\n  for (cnt = 0; cnt < __LC_LAST; ++cnt)\n    {\n      if ((category_mask & 1 << cnt) != 0)\n\t{\n\t  result.__locales[cnt] = _nl_find_locale (locale_path,\n\t\t\t\t\t\t   locale_path_len,\n\t\t\t\t\t\t   cnt, &newnames[cnt]);\n\t  if (result.__locales[cnt] == NULL)\n\t    {\n\t    free_cnt_data_and_exit:\n\t      while (cnt-- > 0)\n\t\tif (((category_mask & 1 << cnt) != 0)\n\t\t    && result.__locales[cnt]->usage_count != UNDELETABLE)\n\t\t  /* We can remove the data.  */\n\t\t  _nl_remove_locale (cnt, result.__locales[cnt]);\n\n              /* Critical section left.  */\n              __libc_rwlock_unlock (__libc_setlocale_lock);\n\t      return NULL;\n\t    }\n\n\t  if (newnames[cnt] != _nl_C_name)\n\t    names_len += strlen (newnames[cnt]) + 1;\n\t}\n      else if (cnt != LC_ALL && result.__names[cnt] != _nl_C_name)\n\t/* Tally up the unchanged names from BASE as well.  */\n\tnames_len += strlen (result.__names[cnt]) + 1;\n    }\n\n  /* We successfully loaded all required data.  Allocate a new structure.\n     We can't just reuse the BASE pointer, because the name strings are\n     changing and we need the old name string area intact so we can copy\n     out of it into the new one without overlap problems should some\n     category's name be getting longer.  */\n  result_ptr = malloc (sizeof (struct __locale_struct) + names_len);\n  if (result_ptr == NULL)\n    {\n      cnt = __LC_LAST;\n      goto free_cnt_data_and_exit;\n    }\n\n  if (base == NULL)\n    {\n      /* Fill in this new structure from scratch.  */\n\n      char *namep = (char *) (result_ptr + 1);\n\n      /* Install copied new names in the new structure's __names array.\n\t If resolved to \"C\", that is already in RESULT.__names to start.  */\n      for (cnt = 0; cnt < __LC_LAST; ++cnt)\n\tif ((category_mask & 1 << cnt) != 0 && newnames[cnt] != _nl_C_name)\n\t  {\n\t    result.__names[cnt] = namep;\n\t    namep = __stpcpy (namep, newnames[cnt]) + 1;\n\t  }\n\n      *result_ptr = result;\n    }\n  else\n    {\n      /* We modify the base structure.  */\n\n      char *namep = (char *) (result_ptr + 1);\n\n      for (cnt = 0; cnt < __LC_LAST; ++cnt)\n\tif ((category_mask & 1 << cnt) != 0)\n\t  {\n\t    if (base->__locales[cnt]->usage_count != UNDELETABLE)\n\t      /* We can remove the old data.  */\n\t      _nl_remove_locale (cnt, base->__locales[cnt]);\n\t    result_ptr->__locales[cnt] = result.__locales[cnt];\n\n\t    if (newnames[cnt] == _nl_C_name)\n\t      result_ptr->__names[cnt] = _nl_C_name;\n\t    else\n\t      {\n\t\tresult_ptr->__names[cnt] = namep;\n\t\tnamep = __stpcpy (namep, newnames[cnt]) + 1;\n\t      }\n\t  }\n\telse if (cnt != LC_ALL)\n\t  {\n\t    /* The RESULT members point into the old BASE structure.  */\n\t    result_ptr->__locales[cnt] = result.__locales[cnt];\n\t    if (result.__names[cnt] == _nl_C_name)\n\t      result_ptr->__names[cnt] = _nl_C_name;\n\t    else\n\t      {\n\t\tresult_ptr->__names[cnt] = namep;\n\t\tnamep = __stpcpy (namep, result.__names[cnt]) + 1;\n\t      }\n\t  }\n\n      free (base);\n    }\n\n  /* Critical section left.  */\n  __libc_rwlock_unlock (__libc_setlocale_lock);\n\n  /* Update the special members.  */\n update:\n  {\n    union locale_data_value *ctypes = result_ptr->__locales[LC_CTYPE]->values;\n    result_ptr->__ctype_b = (const unsigned short int *)\n      ctypes[_NL_ITEM_INDEX (_NL_CTYPE_CLASS)].string + 128;\n    result_ptr->__ctype_tolower = (const int *)\n      ctypes[_NL_ITEM_INDEX (_NL_CTYPE_TOLOWER)].string + 128;\n    result_ptr->__ctype_toupper = (const int *)\n      ctypes[_NL_ITEM_INDEX (_NL_CTYPE_TOUPPER)].string + 128;\n  }\n\n  return result_ptr;\n}",
    "nl_langinfo(nl_item)": "char *\nnl_langinfo (nl_item item)\n{\n  return __nl_langinfo_l (item, _NL_CURRENT_LOCALE);\n}",
    "__nl_langinfo_l(nl_item, locale_t)": "char *\n__nl_langinfo_l (nl_item item, locale_t l)\n{\n  int category = _NL_ITEM_CATEGORY (item);\n  unsigned int index = _NL_ITEM_INDEX (item);\n  const struct __locale_data *data;\n\n  if (category < 0 || category == LC_ALL || category >= __LC_LAST)\n    /* Bogus category: bogus item.  */\n    return (char *) \"\";\n\n  /* Special case value for NL_LOCALE_NAME (category).\n     This is not a real item index in the string table.  */\n  if (index == _NL_ITEM_INDEX (_NL_LOCALE_NAME (category)))\n    return (char *) l->__names[category];\n\n#if defined NL_CURRENT_INDIRECT\n  /* Make direct reference to every _nl_current_CATEGORY symbol,\n     since we know only at runtime which categories are used.  */\n  switch (category)\n    {\n# define DEFINE_CATEGORY(category, category_name, items, a) \\\n      case category: data = *_nl_current_##category; break;\n# include \"categories.def\"\n# undef DEFINE_CATEGORY\n    default:                   /* Should be impossible.  */\n      abort();\n    }\n#else\n  data = l->__locales[category];\n#endif\n\n  if (index >= data->nstrings)\n    /* Bogus index for this category: bogus item.  */\n    return (char *) \"\";\n\n  /* Return the string for the specified item.  */\n  return (char *) data->values[index].string;\n}",
    "setlocale(int, const char *)": "char *\nsetlocale (int category, const char *locale)\n{\n  char *locale_path;\n  size_t locale_path_len;\n  const char *locpath_var;\n  char *composite;\n\n  /* Sanity check for CATEGORY argument.  */\n  if (__builtin_expect (category, 0) < 0\n      || __builtin_expect (category, 0) >= __LC_LAST)\n    ERROR_RETURN;\n\n  /* Does user want name of current locale?  */\n  if (locale == NULL)\n    return (char *) _nl_global_locale.__names[category];\n\n  /* Protect global data.  */\n  __libc_rwlock_wrlock (__libc_setlocale_lock);\n\n  if (strcmp (locale, _nl_global_locale.__names[category]) == 0)\n    {\n      /* Changing to the same thing.  */\n      __libc_rwlock_unlock (__libc_setlocale_lock);\n\n      return (char *) _nl_global_locale.__names[category];\n    }\n\n  /* We perhaps really have to load some data.  So we determine the\n     path in which to look for the data now.  The environment variable\n     `LOCPATH' must only be used when the binary has no SUID or SGID\n     bit set.  If using the default path, we tell _nl_find_locale\n     by passing null and it can check the canonical locale archive.  */\n  locale_path = NULL;\n  locale_path_len = 0;\n\n  locpath_var = getenv (\"LOCPATH\");\n  if (locpath_var != NULL && locpath_var[0] != '\\0')\n    {\n      if (__argz_create_sep (locpath_var, ':',\n\t\t\t     &locale_path, &locale_path_len) != 0\n\t  || __argz_add_sep (&locale_path, &locale_path_len,\n\t\t\t     _nl_default_locale_path, ':') != 0)\n\t{\n\t  __libc_rwlock_unlock (__libc_setlocale_lock);\n\t  return NULL;\n\t}\n    }\n\n  if (category == LC_ALL)\n    {\n      /* The user wants to set all categories.  The desired locales\n\t for the individual categories can be selected by using a\n\t composite locale name.  This is a semi-colon separated list\n\t of entries of the form `CATEGORY=VALUE'.  */\n      const char *newnames[__LC_LAST];\n      struct __locale_data *newdata[__LC_LAST];\n      /* Copy of the locale argument, for in-place splitting.  */\n      char *locale_copy = NULL;\n\n      /* Set all name pointers to the argument name.  */\n      for (category = 0; category < __LC_LAST; ++category)\n\tif (category != LC_ALL)\n\t  newnames[category] = (char *) locale;\n\n      if (__glibc_unlikely (strchr (locale, ';') != NULL))\n\t{\n\t  /* This is a composite name.  Make a copy and split it up.  */\n\t  locale_copy = __strdup (locale);\n\t  if (__glibc_unlikely (locale_copy == NULL))\n\t    {\n\t      __libc_rwlock_unlock (__libc_setlocale_lock);\n\t      return NULL;\n\t    }\n\t  char *np = locale_copy;\n\t  char *cp;\n\t  int cnt;\n\n\t  while ((cp = strchr (np, '=')) != NULL)\n\t    {\n\t      for (cnt = 0; cnt < __LC_LAST; ++cnt)\n\t\tif (cnt != LC_ALL\n\t\t    && (size_t) (cp - np) == _nl_category_name_sizes[cnt]\n\t\t    && (memcmp (np, (_nl_category_names_get (cnt)), cp - np)\n\t\t\t== 0))\n\t\t  break;\n\n\t      if (cnt == __LC_LAST)\n\t\t{\n\t\terror_return:\n\t\t  __libc_rwlock_unlock (__libc_setlocale_lock);\n\t\t  free (locale_copy);\n\n\t\t  /* Bogus category name.  */\n\t\t  ERROR_RETURN;\n\t\t}\n\n\t      /* Found the category this clause sets.  */\n\t      newnames[cnt] = ++cp;\n\t      cp = strchr (cp, ';');\n\t      if (cp != NULL)\n\t\t{\n\t\t  /* Examine the next clause.  */\n\t\t  *cp = '\\0';\n\t\t  np = cp + 1;\n\t\t}\n\t      else\n\t\t/* This was the last clause.  We are done.  */\n\t\tbreak;\n\t    }\n\n\t  for (cnt = 0; cnt < __LC_LAST; ++cnt)\n\t    if (cnt != LC_ALL && newnames[cnt] == locale)\n\t      /* The composite name did not specify all categories.  */\n\t      goto error_return;\n\t}\n\n      /* Load the new data for each category.  */\n      while (category-- > 0)\n\tif (category != LC_ALL)\n\t  {\n\t    newdata[category] = _nl_find_locale (locale_path, locale_path_len,\n\t\t\t\t\t\t category,\n\t\t\t\t\t\t &newnames[category]);\n\n\t    if (newdata[category] == NULL)\n\t      {\n#ifdef NL_CURRENT_INDIRECT\n\t\tif (newnames[category] == _nl_C_name)\n\t\t  /* Null because it's the weak value of _nl_C_LC_FOO.  */\n\t\t  continue;\n#endif\n\t\tbreak;\n\t      }\n\n\t    /* We must not simply free a global locale since we have\n\t       no control over the usage.  So we mark it as\n\t       un-deletable.  And yes, the 'if' is needed, the data\n\t       might be in read-only memory.  */\n\t    if (newdata[category]->usage_count != UNDELETABLE)\n\t      newdata[category]->usage_count = UNDELETABLE;\n\n\t    /* Make a copy of locale name.  */\n\t    if (newnames[category] != _nl_C_name)\n\t      {\n\t\tif (strcmp (newnames[category],\n\t\t\t    _nl_global_locale.__names[category]) == 0)\n\t\t  newnames[category] = _nl_global_locale.__names[category];\n\t\telse\n\t\t  {\n\t\t    newnames[category] = __strdup (newnames[category]);\n\t\t    if (newnames[category] == NULL)\n\t\t      break;\n\t\t  }\n\t      }\n\t  }\n\n      /* Create new composite name.  */\n      composite = (category >= 0\n\t\t   ? NULL : new_composite_name (LC_ALL, newnames));\n      if (composite != NULL)\n\t{\n\t  /* Now we have loaded all the new data.  Put it in place.  */\n\t  for (category = 0; category < __LC_LAST; ++category)\n\t    if (category != LC_ALL)\n\t      {\n\t\tsetdata (category, newdata[category]);\n\t\tsetname (category, newnames[category]);\n\t      }\n\t  setname (LC_ALL, composite);\n\n\t  /* We successfully loaded a new locale.  Let the message catalog\n\t     functions know about this.  */\n\t  ++_nl_msg_cat_cntr;\n\t}\n      else\n\tfor (++category; category < __LC_LAST; ++category)\n\t  if (category != LC_ALL && newnames[category] != _nl_C_name\n\t      && newnames[category] != _nl_global_locale.__names[category])\n\t    free ((char *) newnames[category]);\n\n      /* Critical section left.  */\n      __libc_rwlock_unlock (__libc_setlocale_lock);\n\n      /* Free the resources.  */\n      free (locale_path);\n      free (locale_copy);\n\n      return composite;\n    }\n  else\n    {\n      struct __locale_data *newdata = NULL;\n      const char *newname[1] = { locale };\n\n      if (CATEGORY_USED (category))\n\t{\n\t  /* Only actually load the data if anything will use it.  */\n\t  newdata = _nl_find_locale (locale_path, locale_path_len, category,\n\t\t\t\t     &newname[0]);\n\t  if (newdata == NULL)\n\t    goto abort_single;\n\n\t  /* We must not simply free a global locale since we have no\n\t     control over the usage.  So we mark it as un-deletable.\n\n\t     Note: do not remove the `if', it's necessary to cope with\n\t     the builtin locale data.  */\n\t  if (newdata->usage_count != UNDELETABLE)\n\t    newdata->usage_count = UNDELETABLE;\n\t}\n\n      /* Make a copy of locale name.  */\n      if (newname[0] != _nl_C_name)\n\t{\n\t  newname[0] = __strdup (newname[0]);\n\t  if (newname[0] == NULL)\n\t    goto abort_single;\n\t}\n\n      /* Create new composite name.  */\n      composite = new_composite_name (category, newname);\n      if (composite == NULL)\n\t{\n\t  if (newname[0] != _nl_C_name)\n\t    free ((char *) newname[0]);\n\n\t  /* Say that we don't have any data loaded.  */\n\tabort_single:\n\t  newname[0] = NULL;\n\t}\n      else\n\t{\n\t  if (CATEGORY_USED (category))\n\t    setdata (category, newdata);\n\n\t  setname (category, newname[0]);\n\t  setname (LC_ALL, composite);\n\n\t  /* We successfully loaded a new locale.  Let the message catalog\n\t     functions know about this.  */\n\t  ++_nl_msg_cat_cntr;\n\t}\n\n      /* Critical section left.  */\n      __libc_rwlock_unlock (__libc_setlocale_lock);\n\n      /* Free the resources (the locale path variable.  */\n      free (locale_path);\n\n      return (char *) newname[0];\n    }\n}",
    "__uselocale(locale_t)": "locale_t\n__uselocale (locale_t newloc)\n{\n  locale_t oldloc = _NL_CURRENT_LOCALE;\n\n  if (newloc != NULL)\n    {\n      const locale_t locobj\n\t= newloc == LC_GLOBAL_LOCALE ? &_nl_global_locale : newloc;\n      __libc_tsd_set (locale_t, LOCALE, locobj);\n\n#ifdef NL_CURRENT_INDIRECT\n      /* Now we must update all the per-category thread-local variables to\n\t point into the new current locale for this thread.  The magic\n\t symbols _nl_current_LC_FOO_used are defined to meaningless values\n\t if _nl_current_LC_FOO was linked in.  By using weak references to\n\t both symbols and testing the address of _nl_current_LC_FOO_used,\n\t we can avoid accessing the _nl_current_LC_FOO thread-local\n\t variable at all when no code referring to it was linked in.  We\n\t need the special bogus symbol because while TLS symbols can be\n\t weak, there is no reasonable way to test for the default-zero\n\t value as with a heap symbol (taking the address would just use\n\t some bogus offset from our thread pointer).  */\n\n# define DEFINE_CATEGORY(category, category_name, items, a) \\\n      {\t\t\t\t\t\t\t\t\t      \\\n\textern char _nl_current_##category##_used;\t\t\t      \\\n\tweak_extern (_nl_current_##category##_used)\t\t\t      \\\n\tweak_extern (_nl_current_##category)\t\t\t\t      \\\n\tif (&_nl_current_##category##_used != 0)\t\t\t      \\\n\t  _nl_current_##category = &locobj->__locales[category];\t      \\\n      }\n# include \"categories.def\"\n# undef\tDEFINE_CATEGORY\n#endif\n\n      /* Update the special tsd cache of some locale data.  */\n      __libc_tsd_set (const uint16_t *, CTYPE_B, (void *) locobj->__ctype_b);\n      __libc_tsd_set (const int32_t *, CTYPE_TOLOWER,\n\t\t      (void *) locobj->__ctype_tolower);\n      __libc_tsd_set (const int32_t *, CTYPE_TOUPPER,\n\t\t      (void *) locobj->__ctype_toupper);\n    }\n\n  return oldloc == &_nl_global_locale ? LC_GLOBAL_LOCALE : oldloc;\n}",
    "endutxent()": "void\nendutxent (void)\n{\n  __endutent ();\n}",
    "getlogin()": "char *\ngetlogin (void)\n{\n  int res = __getlogin_r_loginuid (name, sizeof (name));\n  if (res >= 0)\n    return res == 0 ? name : NULL;\n\n  return getlogin_fd0 ();\n}",
    "__getlogin_r_chk(char *, int, int)": "int\n__getlogin_r_chk (char *buf, size_t buflen, size_t nreal)\n{\n  if (buflen > nreal)\n    __chk_fail ();\n\n  return getlogin_r (buf, buflen);\n}",
    "getutmp(const struct utmpx *, struct utmp *)": "void\ngetutmp (const struct utmpx *utmpx, struct utmp *utmp)\n{\n  assert (sizeof (struct utmp) == sizeof (struct utmpx));\n  memcpy (utmp, utmpx, sizeof (struct utmp));\n}",
    "getutmpx(const struct utmp *, struct utmpx *)": "void\ngetutmpx (const struct utmp *utmp, struct utmpx *utmpx)\n{\n  memset (utmpx, 0, sizeof (struct utmpx));\n  utmpx->ut_type = utmp->ut_type;\n  utmpx->ut_pid = utmp->ut_pid;\n  memcpy (utmpx->ut_line, utmp->ut_line, sizeof (utmp->ut_line));\n  memcpy (utmpx->ut_user, utmp->ut_user, sizeof (utmp->ut_user));\n  memcpy (utmpx->ut_id, utmp->ut_id, sizeof (utmp->ut_id));\n  memcpy (utmpx->ut_host, utmp->ut_host, sizeof (utmp->ut_host));\n  utmpx->ut_tv = utmp->ut_tv;\n}",
    "getutxent()": "struct utmpx *\ngetutxent (void)\n{\n  return (struct utmpx *) __getutent ();\n}",
    "getutxid(const struct utmpx *)": "struct utmpx *\ngetutxid (const struct utmpx *id)\n{\n  return (struct utmpx *) __getutid ((const struct utmp *) id);\n}",
    "getutxline(const struct utmpx *)": "struct utmpx *\ngetutxline (const struct utmpx *line)\n{\n  return (struct utmpx *) __getutline ((const struct utmp *) line);\n}",
    "grantpt(int)": "int\ngrantpt (int fd)\n{\n  /* Without pt_chown on Linux, we have delegated the creation of the\n     pty node with the right group and permission mode to the kernel, and\n     non-root users are unlikely to be able to change it. Therefore let's\n     consider that POSIX enforcement is the responsibility of the whole\n     system and not only the GNU libc.   */\n\n  /* Verify that fd refers to a ptmx descriptor.  */\n  unsigned int ptyno;\n  int ret = __ioctl (fd, TIOCGPTN, &ptyno);\n  if (ret != 0 && errno == ENOTTY)\n    /* POSIX requires EINVAL instead of ENOTTY provided by the kernel.  */\n    __set_errno (EINVAL);\n  return ret;\n}",
    "ptsname(int)": "char *\nptsname (int fd)\n{\n  return __ptsname_r (fd, buffer, sizeof (buffer)) != 0 ? NULL : buffer;\n}",
    "__ptsname_r_chk(int, char *, int, int)": "int\n__ptsname_r_chk (int fd, char *buf, size_t buflen, size_t nreal)\n{\n  if (buflen > nreal)\n    __chk_fail ();\n\n  return __ptsname_r (fd, buf, buflen);\n}",
    "pututxline(const struct utmpx *)": "struct utmpx *\npututxline (const struct utmpx *utmpx)\n{\n  return (struct utmpx *) __pututline ((const struct utmp *) utmpx);\n}",
    "setlogin(const char *)": "int\nsetlogin (const char *name)\n{\n  error_t err;\n  if (err = __USEPORT (PROC, __proc_setlogin (port, name)))\n    return __hurd_fail (err);\n  return 0;\n}",
    "setutxent()": "void\nsetutxent (void)\n{\n  return __setutent ();\n}",
    "unlockpt(int)": "int\nunlockpt (int fd)\n{\n  int unlock = 0;\n\n  int ret = __ioctl (fd, TIOCSPTLCK, &unlock);\n  if (ret != 0 && errno == ENOTTY)\n    /* POSIX mandates EINVAL for non-ptmx descriptors.  */\n    __set_errno (EINVAL);\n  return ret;\n}",
    "updwtmpx(const char *, const struct utmpx *)": "void\nupdwtmpx (const char *wtmpx_file, const struct utmpx *utmpx)\n{\n  __updwtmp (wtmpx_file, (const struct utmp *) utmpx);\n}",
    "utmpxname(const char *)": "int\nutmpxname (const char *file)\n{\n  return __utmpname (file);\n}",
    "__libc_alloc_buffer_alloc_array(struct alloc_buffer *, int, int, int)": "void *\n__libc_alloc_buffer_alloc_array (struct alloc_buffer *buf, size_t element_size,\n                                 size_t align, size_t count)\n{\n  uintptr_t current = buf->__alloc_buffer_current;\n  /* The caller asserts that align is a power of two.  */\n  uintptr_t aligned = ALIGN_UP (current, align);\n  size_t size;\n  bool overflow = __builtin_mul_overflow (element_size, count, &size);\n  uintptr_t new_current = aligned + size;\n  if (!overflow                /* Multiplication did not overflow.  */\n      && aligned >= current    /* No overflow in align step.  */\n      && new_current >= size   /* No overflow in size computation.  */\n      && new_current <= buf->__alloc_buffer_end) /* Room in buffer.  */\n    {\n      buf->__alloc_buffer_current = new_current;\n      return (void *) aligned;\n    }\n  else\n    {\n      alloc_buffer_mark_failed (buf);\n      return NULL;\n    }\n}",
    "__libc_alloc_buffer_allocate(int, void **)": "struct alloc_buffer\n__libc_alloc_buffer_allocate (size_t size, void **pptr)\n{\n  *pptr = malloc (size);\n  if (*pptr == NULL)\n    return (struct alloc_buffer)\n      {\n        .__alloc_buffer_current = __ALLOC_BUFFER_INVALID_POINTER,\n        .__alloc_buffer_end = __ALLOC_BUFFER_INVALID_POINTER\n      };\n  else\n    return alloc_buffer_create (*pptr, size);\n}",
    "__libc_alloc_buffer_copy_bytes(struct alloc_buffer, const void *, int)": "struct alloc_buffer\n__libc_alloc_buffer_copy_bytes (struct alloc_buffer buf,\n                                const void *src, size_t len)\n{\n  void *ptr = alloc_buffer_alloc_bytes (&buf, len);\n  if (ptr != NULL)\n    memcpy (ptr, src, len);\n  return buf;\n}",
    "__libc_alloc_buffer_copy_string(struct alloc_buffer, const char *)": "struct alloc_buffer\n__libc_alloc_buffer_copy_string (struct alloc_buffer buf, const char *src)\n{\n  return __libc_alloc_buffer_copy_bytes (buf, src, strlen (src) + 1);\n}",
    "__libc_alloc_buffer_create_failure(void *, int)": "void\n__libc_alloc_buffer_create_failure (void *start, size_t size)\n{\n  char buf[200];\n  __snprintf (buf, sizeof (buf), \"Fatal glibc error: \"\n              \"invalid allocation buffer of size %zu\\n\",\n              size);\n  __libc_fatal (buf);\n}",
    "__libc_dynarray_at_failure(int, int)": "void\n__libc_dynarray_at_failure (size_t size, size_t index)\n{\n#ifdef _LIBC\n  char buf[200];\n  __snprintf (buf, sizeof (buf), \"Fatal glibc error: \"\n              \"array index %zu not less than array length %zu\\n\",\n              index, size);\n __libc_fatal (buf);\n#else\n abort ();\n#endif\n}",
    "__libc_dynarray_emplace_enlarge(struct dynarray_header *, void *, int)": "bool\n__libc_dynarray_emplace_enlarge (struct dynarray_header *list,\n                                 void *scratch, size_t element_size)\n{\n  size_t new_allocated;\n  if (list->allocated == 0)\n    {\n      /* No scratch buffer provided.  Choose a reasonable default\n         size.  */\n      if (element_size < 4)\n        new_allocated = 16;\n      else if (element_size < 8)\n        new_allocated = 8;\n      else\n        new_allocated = 4;\n    }\n  else\n    /* Increase the allocated size, using an exponential growth\n       policy.  */\n    {\n      new_allocated = list->allocated + list->allocated / 2 + 1;\n      if (new_allocated <= list->allocated)\n        {\n          /* Overflow.  */\n          __set_errno (ENOMEM);\n          return false;\n        }\n    }\n\n  size_t new_size;\n  if (INT_MULTIPLY_WRAPV (new_allocated, element_size, &new_size))\n    return false;\n  void *new_array;\n  if (list->array == scratch)\n    {\n      /* The previous array was not heap-allocated.  */\n      new_array = malloc (new_size);\n      if (new_array != NULL && list->array != NULL)\n        memcpy (new_array, list->array, list->used * element_size);\n    }\n  else\n    new_array = realloc (list->array, new_size);\n  if (new_array == NULL)\n    return false;\n  list->array = new_array;\n  list->allocated = new_allocated;\n  return true;\n}",
    "__libc_dynarray_finalize(struct dynarray_header *, void *, int, struct dynarray_finalize_result *)": "bool\n__libc_dynarray_finalize (struct dynarray_header *list,\n                          void *scratch, size_t element_size,\n                          struct dynarray_finalize_result *result)\n{\n  if (__dynarray_error (list))\n    /* The caller will reported the deferred error.  */\n    return false;\n\n  size_t used = list->used;\n\n  /* Empty list.  */\n  if (used == 0)\n    {\n      /* An empty list could still be backed by a heap-allocated\n         array.  Free it if necessary.  */\n      if (list->array != scratch)\n        free (list->array);\n      *result = (struct dynarray_finalize_result) { NULL, 0 };\n      return true;\n    }\n\n  size_t allocation_size = used * element_size;\n  void *heap_array = malloc (allocation_size);\n  if (heap_array != NULL)\n    {\n      /* The new array takes ownership of the strings.  */\n      if (list->array != NULL)\n        memcpy (heap_array, list->array, allocation_size);\n      if (list->array != scratch)\n        free (list->array);\n      *result = (struct dynarray_finalize_result)\n        { .array = heap_array, .length = used };\n      return true;\n    }\n  else\n    /* The caller will perform the freeing operation.  */\n    return false;\n}",
    "__libc_dynarray_resize(struct dynarray_header *, int, void *, int)": "bool\n__libc_dynarray_resize (struct dynarray_header *list, size_t size,\n                        void *scratch, size_t element_size)\n{\n  /* The existing allocation provides sufficient room.  */\n  if (size <= list->allocated)\n    {\n      list->used = size;\n      return true;\n    }\n\n  /* Otherwise, use size as the new allocation size.  The caller is\n     expected to provide the final size of the array, so there is no\n     over-allocation here.  */\n\n  size_t new_size_bytes;\n  if (INT_MULTIPLY_WRAPV (size, element_size, &new_size_bytes))\n    {\n      /* Overflow.  */\n      __set_errno (ENOMEM);\n      return false;\n    }\n  void *new_array;\n  if (list->array == scratch)\n    {\n      /* The previous array was not heap-allocated.  */\n      new_array = malloc (new_size_bytes);\n      if (new_array != NULL && list->array != NULL)\n        memcpy (new_array, list->array, list->used * element_size);\n    }\n  else\n    new_array = realloc (list->array, new_size_bytes);\n  if (new_array == NULL)\n    return false;\n  list->array = new_array;\n  list->allocated = size;\n  list->used = size;\n  return true;\n}",
    "__libc_mallopt(int, int)": "int\n__libc_mallopt (int param_number, int value)\n{\n  mstate av = &main_arena;\n  int res = 1;\n\n  if (!__malloc_initialized)\n    ptmalloc_init ();\n  __libc_lock_lock (av->mutex);\n\n  LIBC_PROBE (memory_mallopt, 2, param_number, value);\n\n  /* We must consolidate main arena before changing max_fast\n     (see definition of set_max_fast).  */\n  malloc_consolidate (av);\n\n  /* Many of these helper functions take a size_t.  We do not worry\n     about overflow here, because negative int values will wrap to\n     very large size_t values and the helpers have sufficient range\n     checking for such conversions.  Many of these helpers are also\n     used by the tunables macros in arena.c.  */\n\n  switch (param_number)\n    {\n    case M_MXFAST:\n      res = do_set_mxfast (value);\n      break;\n\n    case M_TRIM_THRESHOLD:\n      res = do_set_trim_threshold (value);\n      break;\n\n    case M_TOP_PAD:\n      res = do_set_top_pad (value);\n      break;\n\n    case M_MMAP_THRESHOLD:\n      res = do_set_mmap_threshold (value);\n      break;\n\n    case M_MMAP_MAX:\n      res = do_set_mmaps_max (value);\n      break;\n\n    case M_CHECK_ACTION:\n      res = do_set_mallopt_check (value);\n      break;\n\n    case M_PERTURB:\n      res = do_set_perturb_byte (value);\n      break;\n\n    case M_ARENA_TEST:\n      if (value > 0)\n\tres = do_set_arena_test (value);\n      break;\n\n    case M_ARENA_MAX:\n      if (value > 0)\n\tres = do_set_arena_max (value);\n      break;\n    }\n  __libc_lock_unlock (av->mutex);\n  return res;\n}",
    "mcheck_check_all()": "void\nmcheck_check_all (void)\n{\n#if !IS_IN (libc)\n  __mcheck_checkptr (NULL);\n#endif\n}",
    "mcheck(void (*)(enum mcheck_status))": "int\nmcheck (void (*func) (enum mcheck_status))\n{\n#if IS_IN (libc)\n  return -1;\n#else\n  return __mcheck_initialize (func, false);\n#endif\n}",
    "mcheck_pedantic(void (*)(enum mcheck_status))": "int\nmcheck_pedantic (void (*func) (enum mcheck_status))\n{\n#if IS_IN (libc)\n  return -1;\n#else\n  return __mcheck_initialize (func, true);\n#endif\n}",
    "mprobe(void *)": "enum mcheck_status\nmprobe (void *ptr)\n{\n#if IS_IN (libc)\n  return MCHECK_DISABLED;\n#else\n  return __mcheck_checkptr (ptr);\n#endif\n}",
    "mtrace()": "void\nmtrace (void)\n{\n#if !IS_IN (libc)\n  do_mtrace ();\n#endif\n}",
    "muntrace()": "void\nmuntrace (void)\n{\n#if !IS_IN (libc)\n  do_muntrace ();\n#endif\n}",
    "realloc(void *, int)": "void *\nrealloc (void *ptr, size_t len)\n{\n  static void *(*fun) (void *, size_t);\n\n  if (!fun)\n    fun = dlsym (RTLD_NEXT, \"realloc\");\n\n  if (ts.tv_nsec)\n    nanosleep (&ts, NULL);\n\n  return (*fun) (ptr, len);\n}",
    "free(void *)": "void\nfree (void *ptr)\n{\n  if (ptr == NULL)\n    return;\n  lock ();\n  struct allocation_header *header = get_header (\"free\", ptr);\n  free_internal (\"free\", header);\n  unlock ();\n}",
    "mmap(void *, int, int, int, int, off_t)": "void *\nmmap (void *start, size_t len, int prot, int flags, int fd, off_t offset)\n{\n  void *result = NULL;\n\n  /* Determine real implementation if not already happened.  */\n  if (__glibc_unlikely (initialized <= 0))\n    {\n      if (initialized == -1)\n        return NULL;\n\n      me ();\n    }\n\n  /* Always get a block.  We don't need extra memory.  */\n  result = (*mmapp)(start, len, prot, flags, fd, offset);\n\n  if (!not_me && trace_mmap)\n    {\n      int idx = (flags & MAP_ANON\n                 ? idx_mmap_a : prot & PROT_WRITE ? idx_mmap_w : idx_mmap_r);\n\n      /* Keep track of number of calls.  */\n      atomic_fetch_add_explicit (&calls[idx], 1, memory_order_relaxed);\n      /* Keep track of total memory consumption for `malloc'.  */\n      atomic_fetch_add_explicit (&total[idx], len, memory_order_relaxed);\n      /* Keep track of total memory requirement.  */\n      atomic_fetch_add_explicit (&grand_total, len, memory_order_relaxed);\n      /* Remember the size of the request.  */\n      if (len < 65536)\n        atomic_fetch_add_explicit (&histogram[len / 16], 1,\n\t\t\t\t   memory_order_relaxed);\n      else\n        atomic_fetch_add_explicit (&large, 1, memory_order_relaxed);\n      /* Total number of calls of any of the functions.  */\n      atomic_fetch_add_explicit (&calls_total, 1, memory_order_relaxed);\n\n      /* Check for failures.  */\n      if (result == NULL)\n        atomic_fetch_add_explicit (&failed[idx], 1, memory_order_relaxed);\n      else if (idx == idx_mmap_w)\n        /* Update the allocation data and write out the records if\n           necessary.  Note the first parameter is NULL which means\n           the size is not tracked.  */\n        update_data (NULL, len, 0);\n    }\n\n  /* Return the pointer to the user buffer.  */\n  return result;\n}",
    "mmap64(void *, int, int, int, int, int)": "void *\nmmap64 (void *start, size_t len, int prot, int flags, int fd, off64_t offset)\n{\n  void *result = NULL;\n\n  /* Determine real implementation if not already happened.  */\n  if (__glibc_unlikely (initialized <= 0))\n    {\n      if (initialized == -1)\n        return NULL;\n\n      me ();\n    }\n\n  /* Always get a block.  We don't need extra memory.  */\n  result = (*mmap64p)(start, len, prot, flags, fd, offset);\n\n  if (!not_me && trace_mmap)\n    {\n      int idx = (flags & MAP_ANON\n                 ? idx_mmap_a : prot & PROT_WRITE ? idx_mmap_w : idx_mmap_r);\n\n      /* Keep track of number of calls.  */\n      atomic_fetch_add_explicit (&calls[idx], 1, memory_order_relaxed);\n      /* Keep track of total memory consumption for `malloc'.  */\n      atomic_fetch_add_explicit (&total[idx], len, memory_order_relaxed);\n      /* Keep track of total memory requirement.  */\n      atomic_fetch_add_explicit (&grand_total, len, memory_order_relaxed);\n      /* Remember the size of the request.  */\n      if (len < 65536)\n        atomic_fetch_add_explicit (&histogram[len / 16], 1,\n\t\t\t\t   memory_order_relaxed);\n      else\n        atomic_fetch_add_explicit (&large, 1, memory_order_relaxed);\n      /* Total number of calls of any of the functions.  */\n      atomic_fetch_add_explicit (&calls_total, 1, memory_order_relaxed);\n\n      /* Check for failures.  */\n      if (result == NULL)\n        atomic_fetch_add_explicit (&failed[idx], 1, memory_order_relaxed);\n      else if (idx == idx_mmap_w)\n        /* Update the allocation data and write out the records if\n           necessary.  Note the first parameter is NULL which means\n           the size is not tracked.  */\n        update_data (NULL, len, 0);\n    }\n\n  /* Return the pointer to the user buffer.  */\n  return result;\n}",
    "mremap(void *, int, int, int, ...)": "void *\nmremap (void *start, size_t old_len, size_t len, int flags, ...)\n{\n  void *result = NULL;\n  va_list ap;\n\n  va_start (ap, flags);\n  void *newaddr = (flags & MREMAP_FIXED) ? va_arg (ap, void *) : NULL;\n  va_end (ap);\n\n  /* Determine real implementation if not already happened.  */\n  if (__glibc_unlikely (initialized <= 0))\n    {\n      if (initialized == -1)\n        return NULL;\n\n      me ();\n    }\n\n  /* Always get a block.  We don't need extra memory.  */\n  result = (*mremapp)(start, old_len, len, flags, newaddr);\n\n  if (!not_me && trace_mmap)\n    {\n      /* Keep track of number of calls.  */\n      atomic_fetch_add_explicit (&calls[idx_mremap], 1, memory_order_relaxed);\n      if (len > old_len)\n        {\n          /* Keep track of total memory consumption for `malloc'.  */\n          atomic_fetch_add_explicit (&total[idx_mremap], len - old_len,\n\t\t\t\t     memory_order_relaxed);\n          /* Keep track of total memory requirement.  */\n          atomic_fetch_add_explicit (&grand_total, len - old_len,\n\t\t\t\t     memory_order_relaxed);\n        }\n      /* Remember the size of the request.  */\n      if (len < 65536)\n        atomic_fetch_add_explicit (&histogram[len / 16], 1,\n\t\t\t\t   memory_order_relaxed);\n      else\n        atomic_fetch_add_explicit (&large, 1, memory_order_relaxed);\n      /* Total number of calls of any of the functions.  */\n      atomic_fetch_add_explicit (&calls_total, 1, memory_order_relaxed);\n\n      /* Check for failures.  */\n      if (result == NULL)\n        atomic_fetch_add_explicit (&failed[idx_mremap], 1,\n\t\t\t\t   memory_order_relaxed);\n      else\n        {\n          /* Record whether the reduction/increase happened in place.  */\n          if (start == result)\n            atomic_fetch_add_explicit (&inplace_mremap, 1,\n\t\t\t\t       memory_order_relaxed);\n          /* Was the buffer increased?  */\n          if (old_len > len)\n            atomic_fetch_add_explicit (&decreasing_mremap, 1,\n\t\t\t\t       memory_order_relaxed);\n\n          /* Update the allocation data and write out the records if\n             necessary.  Note the first parameter is NULL which means\n             the size is not tracked.  */\n          update_data (NULL, len, old_len);\n        }\n    }\n\n  /* Return the pointer to the user buffer.  */\n  return result;\n}",
    "munmap(void *, int)": "int\nmunmap (void *start, size_t len)\n{\n  int result;\n\n  /* Determine real implementation if not already happened.  */\n  if (__glibc_unlikely (initialized <= 0))\n    {\n      if (initialized == -1)\n        return -1;\n\n      me ();\n    }\n\n  /* Do the real work.  */\n  result = (*munmapp)(start, len);\n\n  if (!not_me && trace_mmap)\n    {\n      /* Keep track of number of calls.  */\n      atomic_fetch_add_explicit (&calls[idx_munmap], 1, memory_order_relaxed);\n\n      if (__glibc_likely (result == 0))\n        {\n          /* Keep track of total memory freed using `free'.  */\n          atomic_fetch_add_explicit (&total[idx_munmap], len,\n\t\t\t\t     memory_order_relaxed);\n\n          /* Update the allocation data and write out the records if\n             necessary.  */\n          update_data (NULL, 0, len);\n        }\n      else\n        atomic_fetch_add_explicit (&failed[idx_munmap], 1,\n\t\t\t\t   memory_order_relaxed);\n    }\n\n  return result;\n}",
    "__libc_reallocarray(void *, int, int)": "void *\n__libc_reallocarray (void *optr, size_t nmemb, size_t elem_size)\n{\n  size_t bytes;\n  if (__builtin_mul_overflow (nmemb, elem_size, &bytes))\n    {\n      __set_errno (ENOMEM);\n      return 0;\n    }\n  return realloc (optr, bytes);\n}",
    "__libc_scratch_buffer_grow(struct scratch_buffer *)": "bool\n__libc_scratch_buffer_grow (struct scratch_buffer *buffer)\n{\n  void *new_ptr;\n  size_t new_length = buffer->length * 2;\n\n  /* Discard old buffer.  */\n  scratch_buffer_free (buffer);\n\n  /* Check for overflow.  */\n  if (__glibc_likely (new_length >= buffer->length))\n    new_ptr = malloc (new_length);\n  else\n    {\n      __set_errno (ENOMEM);\n      new_ptr = NULL;\n    }\n\n  if (__glibc_unlikely (new_ptr == NULL))\n    {\n      /* Buffer must remain valid to free.  */\n      scratch_buffer_init (buffer);\n      return false;\n    }\n\n  /* Install new heap-based buffer.  */\n  buffer->data = new_ptr;\n  buffer->length = new_length;\n  return true;\n}",
    "__libc_scratch_buffer_grow_preserve(struct scratch_buffer *)": "bool\n__libc_scratch_buffer_grow_preserve (struct scratch_buffer *buffer)\n{\n  size_t new_length = 2 * buffer->length;\n  void *new_ptr;\n\n  if (buffer->data == buffer->__space.__c)\n    {\n      /* Move buffer to the heap.  No overflow is possible because\n\t buffer->length describes a small buffer on the stack.  */\n      new_ptr = malloc (new_length);\n      if (new_ptr == NULL)\n\treturn false;\n      memcpy (new_ptr, buffer->__space.__c, buffer->length);\n    }\n  else\n    {\n      /* Buffer was already on the heap.  Check for overflow.  */\n      if (__glibc_likely (new_length >= buffer->length))\n\tnew_ptr = realloc (buffer->data, new_length);\n      else\n\t{\n\t  __set_errno (ENOMEM);\n\t  new_ptr = NULL;\n\t}\n\n      if (__glibc_unlikely (new_ptr == NULL))\n\t{\n\t  /* Deallocate, but buffer must remain valid to free.  */\n\t  free (buffer->data);\n\t  scratch_buffer_init (buffer);\n\t  return false;\n\t}\n    }\n\n  /* Install new heap-based buffer.  */\n  buffer->data = new_ptr;\n  buffer->length = new_length;\n  return true;\n}",
    "__libc_scratch_buffer_set_array_size(struct scratch_buffer *, int, int)": "bool\n__libc_scratch_buffer_set_array_size (struct scratch_buffer *buffer,\n\t\t\t\t      size_t nelem, size_t size)\n{\n  size_t new_length = nelem * size;\n\n  /* Avoid overflow check if both values are small. */\n  if ((nelem | size) >> (sizeof (size_t) * CHAR_BIT / 2) != 0\n      && nelem != 0 && size != new_length / nelem)\n    {\n      /* Overflow.  Discard the old buffer, but it must remain valid\n\t to free.  */\n      scratch_buffer_free (buffer);\n      scratch_buffer_init (buffer);\n      __set_errno (ENOMEM);\n      return false;\n    }\n\n  if (new_length <= buffer->length)\n    return true;\n\n  /* Discard old buffer.  */\n  scratch_buffer_free (buffer);\n\n  char *new_ptr = malloc (new_length);\n  if (new_ptr == NULL)\n    {\n      /* Buffer must remain valid to free.  */\n      scratch_buffer_init (buffer);\n      return false;\n    }\n\n  /* Install new heap-based buffer.  */\n  buffer->data = new_ptr;\n  buffer->length = new_length;\n  return true;\n}",
    "__libc_freeres()": "void\n__libc_freeres (void)\n{\n  /* This function might be called from different places.  So better\n     protect for multiple executions since these are fatal.  */\n  static long int already_called;\n\n  if (!atomic_compare_and_exchange_bool_acq (&already_called, 1, 0))\n    {\n      call_function_static_weak (__nss_module_freeres);\n      call_function_static_weak (__nss_action_freeres);\n      call_function_static_weak (__nss_database_freeres);\n\n      _IO_cleanup ();\n\n      /* We run the resource freeing after IO cleanup.  */\n      call_function_static_weak (__dl_libc_freemem);\n      call_function_static_weak (__hdestroy);\n      call_function_static_weak (__gconv_cache_freemem);\n      call_function_static_weak (__gconv_conf_freemem);\n      call_function_static_weak (__gconv_db_freemem);\n      call_function_static_weak (__gconv_dl_freemem);\n      call_function_static_weak (__intl_freemem);\n      call_function_static_weak (__libio_freemem);\n      call_function_static_weak (__libc_fstab_freemem);\n\n#ifdef USE_NSCD\n      call_function_static_weak (__nscd_gr_map_freemem);\n      call_function_static_weak (__nscd_hst_map_freemem);\n      call_function_static_weak (__nscd_pw_map_freemem);\n      call_function_static_weak (__nscd_serv_map_freemem);\n      call_function_static_weak (__nscd_group_map_freemem);\n#endif\n\n      call_function_static_weak (__libc_regcomp_freemem);\n      call_function_static_weak (__libc_atfork_freemem);\n      /* __res_thread_freeres deallocates the per-thread resolv_context);\n\t which in turn drop the reference count of the current global object.\n\t So it need to be before __libc_resolv_conf_freemem.  */\n      call_function_static_weak (__res_thread_freeres);\n      call_function_static_weak (__libc_resolv_conf_freemem);\n      call_function_static_weak (__libc_printf_freemem);\n      call_function_static_weak (__libc_fmtmsg_freemem);\n      call_function_static_weak (__libc_setenv_freemem);\n#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_31)\n      call_function_static_weak (__rpc_freemem);\n      call_function_static_weak (__rpc_thread_destroy);\n#endif\n      call_function_static_weak (__libc_getaddrinfo_freemem);\n      call_function_static_weak (__libc_tzset_freemem);\n      call_function_static_weak (__libc_localealias_freemem);\n\n#if PTHREAD_IN_LIBC\n      call_function_static_weak (__gai_freemem);\n\n      call_function_static_weak (__aio_freemem);\n#endif\n\n      call_function_static_weak (__libpthread_freeres);\n\n#ifdef SHARED\n      __libc_unwind_link_freeres ();\n#endif\n\n      call_function_static_weak (__libc_dlerror_result_free);\n\n#ifdef SHARED\n      GLRO (dl_libc_freeres) ();\n#endif\n\n      call_free_static_weak (__libc_fgetgrent_freemem_ptr);\n      call_free_static_weak (__libc_fgetsgent_freeres_ptr);\n      call_free_static_weak (__libc_getnetgrent_freemem_ptr);\n      call_free_static_weak (__libc_rcmd_freemem_ptr);\n      call_free_static_weak (__libc_rexec_freemem_ptr);\n      call_free_static_weak (__libc_mntent_freemem_ptr);\n      call_free_static_weak (__libc_fgetpwent_freemem_ptr);\n      call_free_static_weak (__libc_resolv_res_hconf_freemem_ptr);\n      call_free_static_weak (__libc_fgetspent_freemem_ptr);\n      call_free_static_weak (__libc_tzfile_freemem_ptr);\n      call_free_static_weak (__libc_getnameinfo_freemem_ptr);\n      call_free_static_weak (__libc_getutent_freemem_ptr);\n      call_free_static_weak (__libc_getutid_freemem_ptr);\n      call_free_static_weak (__libc_getutline_freemem_ptr);\n      call_free_static_weak (__libc_reg_printf_freemem_ptr);\n      call_free_static_weak (__libc_reg_type_freemem_ptr);\n\n      call_free_static_weak (__libc_getgrgid_freemem_ptr);\n      call_free_static_weak (__libc_getgrnam_freemem_ptr);\n      call_free_static_weak (__libc_getpwnam_freemem_ptr);\n      call_free_static_weak (__libc_getpwuid_freemem_ptr);\n      call_free_static_weak (__libc_getspnam_freemem_ptr);\n      call_free_static_weak (__libc_getaliasbyname_freemem_ptr);\n      call_free_static_weak (__libc_gethostbyaddr_freemem_ptr);\n      call_free_static_weak (__libc_gethostbyname_freemem_ptr);\n      call_free_static_weak (__libc_gethostbyname2_freemem_ptr);\n      call_free_static_weak (__libc_getnetbyaddr_freemem_ptr);\n      call_free_static_weak (__libc_getnetbyname_freemem_ptr);\n      call_free_static_weak (__libc_getprotobynumber_freemem_ptr);\n      call_free_static_weak (__libc_getprotobyname_freemem_ptr);\n      call_free_static_weak (__libc_getrpcbyname_freemem_ptr);\n      call_free_static_weak (__libc_getrpcbynumber_freemem_ptr);\n      call_free_static_weak (__libc_getservbyname_freemem_ptr);\n      call_free_static_weak (__libc_getservbyport_freemem_ptr);\n\n      call_free_static_weak (__libc_getgrent_freemem_ptr);\n      call_free_static_weak (__libc_getpwent_freemem_ptr);\n      call_free_static_weak (__libc_getspent_freemem_ptr);\n      call_free_static_weak (__libc_getaliasent_freemem_ptr);\n      call_free_static_weak (__libc_gethostent_freemem_ptr);\n      call_free_static_weak (__libc_getnetent_freemem_ptr);\n      call_free_static_weak (__libc_getprotoent_freemem_ptr);\n      call_free_static_weak (__libc_getrpcent_freemem_ptr);\n      call_free_static_weak (__libc_getservent_freemem_ptr);\n\n      call_free_static_weak (__libc_efgcvt_freemem_ptr);\n      call_free_static_weak (__libc_qefgcvt_freemem_ptr);\n\n      call_freeres_system_funcs;\n    }\n}",
    "twalk(const void *, void (*)(const void *, VISIT, int))": "void\ntwalk (const void *root, void (*action) (const void *, VISIT, int))\n{\n  struct twalk_with_twalk_r_closure closure = { action, 0 };\n  twalk_r (root, twalk_with_twalk_r_action, &closure);\n}",
    "fedisableexcept(int)": "int\nfedisableexcept (int excepts)\n{\n  unsigned short int new_exc, old_exc;\n  unsigned int new;\n\n  excepts &= FE_ALL_EXCEPT;\n\n  /* Get the current control word of the x87 FPU.  */\n  __asm__ (\"fstcw %0\" : \"=m\" (*&new_exc));\n\n  old_exc = (~new_exc) & FE_ALL_EXCEPT;\n\n  new_exc |= excepts;\n  __asm__ (\"fldcw %0\" : : \"m\" (*&new_exc));\n\n  /* And now the same for the SSE MXCSR register.  */\n  __asm__ (\"stmxcsr %0\" : \"=m\" (*&new));\n\n  /* The SSE exception masks are shifted by 7 bits.  */\n  new |= excepts << 7;\n  __asm__ (\"ldmxcsr %0\" : : \"m\" (*&new));\n\n  return old_exc;\n}",
    "feenableexcept(int)": "int\nfeenableexcept (int excepts)\n{\n  unsigned short int new_exc, old_exc;\n  unsigned int new;\n\n  excepts &= FE_ALL_EXCEPT;\n\n  /* Get the current control word of the x87 FPU.  */\n  __asm__ (\"fstcw %0\" : \"=m\" (*&new_exc));\n\n  old_exc = (~new_exc) & FE_ALL_EXCEPT;\n\n  new_exc &= ~excepts;\n  __asm__ (\"fldcw %0\" : : \"m\" (*&new_exc));\n\n  /* And now the same for the SSE MXCSR register.  */\n  __asm__ (\"stmxcsr %0\" : \"=m\" (*&new));\n\n  /* The SSE exception masks are shifted by 7 bits.  */\n  new &= ~(excepts << 7);\n  __asm__ (\"ldmxcsr %0\" : : \"m\" (*&new));\n\n  return old_exc;\n}",
    "fegetexcept()": "int\nfegetexcept (void)\n{\n  unsigned short int exc;\n\n  /* Get the current control word.  */\n  __asm__ (\"fstcw %0\" : \"=m\" (*&exc));\n\n  return (~exc) & FE_ALL_EXCEPT;\n}",
    "fegetmode(int *)": "int\nfegetmode (femode_t *modep)\n{\n  _FPU_GETCW (modep->__control_word);\n  __asm__ (\"stmxcsr %0\" : \"=m\" (modep->__mxcsr));\n  return 0;\n}",
    "fesetexcept(int)": "int\nfesetexcept (int excepts)\n{\n  unsigned int mxcsr;\n\n  __asm__ (\"stmxcsr %0\" : \"=m\" (*&mxcsr));\n  mxcsr |= excepts & FE_ALL_EXCEPT;\n  __asm__ (\"ldmxcsr %0\" : : \"m\" (*&mxcsr));\n\n  return 0;\n}",
    "fesetmode(const int *)": "int\nfesetmode (const femode_t *modep)\n{\n  fpu_control_t cw;\n  unsigned int mxcsr;\n  __asm__ (\"stmxcsr %0\" : \"=m\" (mxcsr));\n  /* Preserve SSE exception flags but restore other state in\n     MXCSR.  */\n  mxcsr &= FE_ALL_EXCEPT_X86;\n  if (modep == FE_DFL_MODE)\n    {\n      cw = _FPU_DEFAULT;\n      /* Default MXCSR state has all bits zero except for those\n\t masking exceptions.  */\n      mxcsr |= FE_ALL_EXCEPT_X86 << 7;\n    }\n  else\n    {\n      cw = modep->__control_word;\n      mxcsr |= modep->__mxcsr & ~FE_ALL_EXCEPT_X86;\n    }\n  _FPU_SETCW (cw);\n  __asm__ (\"ldmxcsr %0\" : : \"m\" (mxcsr));\n  return 0;\n}",
    "fetestexceptflag(const fexcept_t *, int)": "int\nfetestexceptflag (const fexcept_t *flagp, int excepts)\n{\n  /* Most versions of fegetexceptflag store exceptions in a form such\n     that this works.  */\n  return *flagp & excepts & FE_ALL_EXCEPT;\n}",
    "fetestexcept(int)": "int\nfetestexcept (int excepts)\n{\n  int temp;\n  unsigned int mxscr;\n\n  /* Get current exceptions.  */\n  __asm__ (\"fnstsw %0\\n\"\n\t   \"stmxcsr %1\" : \"=m\" (*&temp), \"=m\" (*&mxscr));\n\n  return (temp | mxscr) & excepts & FE_ALL_EXCEPT;\n}",
    "matherr(struct exception *)": "int\nmatherr (struct exception *s)\n{\n  printf (\"matherr is working\\n\");\n  fail = 0;\n  return 1;\n}",
    "cos(double)": "TYPE\n(F(cos)) (TYPE x)\n{\n  counts[T][C_cos]++;\n  P ();\n  return x;\n}",
    "acos(double)": "TYPE\n(F(acos)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "sin(double)": "TYPE\n(F(sin)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "asin(double)": "TYPE\n(F(asin)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "tan(double)": "TYPE\n(F(tan)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "atan(double)": "TYPE\n(F(atan)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "atan2(double, double)": "TYPE\n(F(atan2)) (TYPE x, TYPE y)\n{\n  counts[T][C_atan2]++;\n  P ();\n  return x + y;\n}",
    "cosh(double)": "TYPE\n(F(cosh)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "acosh(double)": "TYPE\n(F(acosh)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "sinh(double)": "TYPE\n(F(sinh)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "asinh(double)": "TYPE\n(F(asinh)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "tanh(double)": "TYPE\n(F(tanh)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "atanh(double)": "TYPE\n(F(atanh)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "exp(double)": "TYPE\n(F(exp)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "log(double)": "TYPE\n(F(log)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "log10(double)": "TYPE\n(F(log10)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "ldexp(double, int)": "TYPE\n(F(ldexp)) (TYPE x, int y)\n{\n  counts[T][C_ldexp]++;\n  P ();\n  return x + y;\n}",
    "frexp(double, int *)": "TYPE\n(F(frexp)) (TYPE x, int *y)\n{\n  ++count;\n  P ();\n  return x + *y;\n}",
    "expm1(double)": "TYPE\n(F(expm1)) (TYPE x)\n{\n  counts[T][C_expm1]++;\n  P ();\n  return x;\n}",
    "log1p(double)": "TYPE\n(F(log1p)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "logb(double)": "TYPE\n(F(logb)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "exp10(double)": "TYPE\n(F(exp10)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "exp2(double)": "TYPE\n(F(exp2)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "log2(double)": "TYPE\n(F(log2)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "pow(double, double)": "TYPE\n(F(pow)) (TYPE x, TYPE y)\n{\n  counts[T][C_pow]++;\n  P ();\n  return x + y;\n}",
    "sqrt(double)": "TYPE\n(F(sqrt)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "hypot(double, double)": "TYPE\n(F(hypot)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "cbrt(double)": "TYPE\n(F(cbrt)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "ceil(double)": "TYPE\n(F(ceil)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "fabs(double)": "TYPE\n(F(fabs)) (TYPE x)\n{\n  counts[T][C_fabs]++;\n  P ();\n  return x;\n}",
    "floor(double)": "TYPE\n(F(floor)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "fmod(double, double)": "TYPE\n(F(fmod)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "nearbyint(double)": "TYPE\n(F(nearbyint)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "round(double)": "TYPE\n(F(round)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "roundeven(double)": "TYPE\n(F(roundeven)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "trunc(double)": "TYPE\n(F(trunc)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "remquo(double, double, int *)": "TYPE\n(F(remquo)) (TYPE x, TYPE y, int *z)\n{\n  counts[T][C_remquo]++;\n  P ();\n  return x + y + *z;\n}",
    "lrint(double)": "long int\n(F(lrint)) (TYPE x)\n{\n  counts[T][C_lrint]++;\n  P ();\n  return x;\n}",
    "lround(double)": "long int\n(F(lround)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "llrint(double)": "long long int\n(F(llrint)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "llround(double)": "long long int\n(F(llround)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "fromfp(double, int, unsigned int)": "intmax_t\n(F(fromfp)) (TYPE x, int round, unsigned int width)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "fromfpx(double, int, unsigned int)": "intmax_t\n(F(fromfpx)) (TYPE x, int round, unsigned int width)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "ufromfp(double, int, unsigned int)": "uintmax_t\n(F(ufromfp)) (TYPE x, int round, unsigned int width)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "ufromfpx(double, int, unsigned int)": "uintmax_t\n(F(ufromfpx)) (TYPE x, int round, unsigned int width)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "erf(double)": "TYPE\n(F(erf)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "erfc(double)": "TYPE\n(F(erfc)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "tgamma(double)": "TYPE\n(F(tgamma)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "lgamma(double)": "TYPE\n(F(lgamma)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "rint(double)": "TYPE\n(F(rint)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "nextafter(double, double)": "TYPE\n(F(nextafter)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "nextdown(double)": "TYPE\n(F(nextdown)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "nexttoward(double, long double)": "TYPE\n(F(nexttoward)) (TYPE x, long double y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "nextup(double)": "TYPE\n(F(nextup)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "remainder(double, double)": "TYPE\n(F(remainder)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "scalb(double, double)": "TYPE\n(F(scalb)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "scalbn(double, int)": "TYPE\n(F(scalbn)) (TYPE x, int y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "scalbln(double, long)": "TYPE\n(F(scalbln)) (TYPE x, long int y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "ilogb(double)": "int\n(F(ilogb)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "llogb(double)": "long int\n(F(llogb)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "fdim(double, double)": "TYPE\n(F(fdim)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fmin(double, double)": "TYPE\n(F(fmin)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fmax(double, double)": "TYPE\n(F(fmax)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fminmag(double, double)": "TYPE\n(F(fminmag)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fmaxmag(double, double)": "TYPE\n(F(fmaxmag)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fminimum(double, double)": "TYPE\n(F(fminimum)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fmaximum(double, double)": "TYPE\n(F(fmaximum)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fminimum_num(double, double)": "TYPE\n(F(fminimum_num)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fmaximum_num(double, double)": "TYPE\n(F(fmaximum_num)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fminimum_mag(double, double)": "TYPE\n(F(fminimum_mag)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fmaximum_mag(double, double)": "TYPE\n(F(fmaximum_mag)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fminimum_mag_num(double, double)": "TYPE\n(F(fminimum_mag_num)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fmaximum_mag_num(double, double)": "TYPE\n(F(fmaximum_mag_num)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fma(double, double, double)": "TYPE\n(F(fma)) (TYPE x, TYPE y, TYPE z)\n{\n  counts[T][C_fma]++;\n  P ();\n  return x + y + z;\n}",
    "cacos(_Complex double)": "complex TYPE\n(F(cacos)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "casin(_Complex double)": "complex TYPE\n(F(casin)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "catan(_Complex double)": "complex TYPE\n(F(catan)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "ccos(_Complex double)": "complex TYPE\n(F(ccos)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "csin(_Complex double)": "complex TYPE\n(F(csin)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "ctan(_Complex double)": "complex TYPE\n(F(ctan)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "cacosh(_Complex double)": "complex TYPE\n(F(cacosh)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "casinh(_Complex double)": "complex TYPE\n(F(casinh)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "catanh(_Complex double)": "complex TYPE\n(F(catanh)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "ccosh(_Complex double)": "complex TYPE\n(F(ccosh)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "csinh(_Complex double)": "complex TYPE\n(F(csinh)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "ctanh(_Complex double)": "complex TYPE\n(F(ctanh)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "cexp(_Complex double)": "complex TYPE\n(F(cexp)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "clog(_Complex double)": "complex TYPE\n(F(clog)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "csqrt(_Complex double)": "complex TYPE\n(F(csqrt)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "cpow(_Complex double, _Complex double)": "complex TYPE\n(F(cpow)) (complex TYPE x, complex TYPE y)\n{\n  ++ccount;\n  P ();\n  return x + y;\n}",
    "cabs(_Complex double)": "TYPE\n(F(cabs)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "carg(_Complex double)": "TYPE\n(F(carg)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "creal(_Complex double)": "TYPE\n(F(creal)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return __real__ x;\n}",
    "cimag(_Complex double)": "TYPE\n(F(cimag)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return __imag__ x;\n}",
    "conj(_Complex double)": "complex TYPE\n(F(conj)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "cproj(_Complex double)": "complex TYPE\n(F(cproj)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "cosf(float)": "TYPE\n(F(cos)) (TYPE x)\n{\n  counts[T][C_cos]++;\n  P ();\n  return x;\n}",
    "acosf(float)": "TYPE\n(F(acos)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "sinf(float)": "TYPE\n(F(sin)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "asinf(float)": "TYPE\n(F(asin)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "tanf(float)": "TYPE\n(F(tan)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "atanf(float)": "TYPE\n(F(atan)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "atan2f(float, float)": "TYPE\n(F(atan2)) (TYPE x, TYPE y)\n{\n  counts[T][C_atan2]++;\n  P ();\n  return x + y;\n}",
    "coshf(float)": "TYPE\n(F(cosh)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "acoshf(float)": "TYPE\n(F(acosh)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "sinhf(float)": "TYPE\n(F(sinh)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "asinhf(float)": "TYPE\n(F(asinh)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "tanhf(float)": "TYPE\n(F(tanh)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "atanhf(float)": "TYPE\n(F(atanh)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "expf(float)": "TYPE\n(F(exp)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "logf(float)": "TYPE\n(F(log)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "log10f(float)": "TYPE\n(F(log10)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "ldexpf(float, int)": "TYPE\n(F(ldexp)) (TYPE x, int y)\n{\n  counts[T][C_ldexp]++;\n  P ();\n  return x + y;\n}",
    "frexpf(float, int *)": "TYPE\n(F(frexp)) (TYPE x, int *y)\n{\n  ++count;\n  P ();\n  return x + *y;\n}",
    "expm1f(float)": "TYPE\n(F(expm1)) (TYPE x)\n{\n  counts[T][C_expm1]++;\n  P ();\n  return x;\n}",
    "log1pf(float)": "TYPE\n(F(log1p)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "logbf(float)": "TYPE\n(F(logb)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "exp10f(float)": "TYPE\n(F(exp10)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "exp2f(float)": "TYPE\n(F(exp2)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "log2f(float)": "TYPE\n(F(log2)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "powf(float, float)": "TYPE\n(F(pow)) (TYPE x, TYPE y)\n{\n  counts[T][C_pow]++;\n  P ();\n  return x + y;\n}",
    "sqrtf(float)": "TYPE\n(F(sqrt)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "hypotf(float, float)": "TYPE\n(F(hypot)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "cbrtf(float)": "TYPE\n(F(cbrt)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "ceilf(float)": "TYPE\n(F(ceil)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "fabsf(float)": "TYPE\n(F(fabs)) (TYPE x)\n{\n  counts[T][C_fabs]++;\n  P ();\n  return x;\n}",
    "floorf(float)": "TYPE\n(F(floor)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "fmodf(float, float)": "TYPE\n(F(fmod)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "nearbyintf(float)": "TYPE\n(F(nearbyint)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "roundf(float)": "TYPE\n(F(round)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "roundevenf(float)": "TYPE\n(F(roundeven)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "truncf(float)": "TYPE\n(F(trunc)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "remquof(float, float, int *)": "TYPE\n(F(remquo)) (TYPE x, TYPE y, int *z)\n{\n  counts[T][C_remquo]++;\n  P ();\n  return x + y + *z;\n}",
    "lrintf(float)": "long int\n(F(lrint)) (TYPE x)\n{\n  counts[T][C_lrint]++;\n  P ();\n  return x;\n}",
    "lroundf(float)": "long int\n(F(lround)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "llrintf(float)": "long long int\n(F(llrint)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "llroundf(float)": "long long int\n(F(llround)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "fromfpf(float, int, unsigned int)": "intmax_t\n(F(fromfp)) (TYPE x, int round, unsigned int width)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "fromfpxf(float, int, unsigned int)": "intmax_t\n(F(fromfpx)) (TYPE x, int round, unsigned int width)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "ufromfpf(float, int, unsigned int)": "uintmax_t\n(F(ufromfp)) (TYPE x, int round, unsigned int width)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "ufromfpxf(float, int, unsigned int)": "uintmax_t\n(F(ufromfpx)) (TYPE x, int round, unsigned int width)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "erff(float)": "TYPE\n(F(erf)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "erfcf(float)": "TYPE\n(F(erfc)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "tgammaf(float)": "TYPE\n(F(tgamma)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "lgammaf(float)": "TYPE\n(F(lgamma)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "rintf(float)": "TYPE\n(F(rint)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "nextafterf(float, float)": "TYPE\n(F(nextafter)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "nextdownf(float)": "TYPE\n(F(nextdown)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "nexttowardf(float, long double)": "TYPE\n(F(nexttoward)) (TYPE x, long double y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "nextupf(float)": "TYPE\n(F(nextup)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "remainderf(float, float)": "TYPE\n(F(remainder)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "scalbf(float, float)": "TYPE\n(F(scalb)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "scalbnf(float, int)": "TYPE\n(F(scalbn)) (TYPE x, int y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "scalblnf(float, long)": "TYPE\n(F(scalbln)) (TYPE x, long int y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "ilogbf(float)": "int\n(F(ilogb)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "llogbf(float)": "long int\n(F(llogb)) (TYPE x)\n{\n  ++count;\n  P ();\n  return x;\n}",
    "fdimf(float, float)": "TYPE\n(F(fdim)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fminf(float, float)": "TYPE\n(F(fmin)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fmaxf(float, float)": "TYPE\n(F(fmax)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fminmagf(float, float)": "TYPE\n(F(fminmag)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fmaxmagf(float, float)": "TYPE\n(F(fmaxmag)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fminimumf(float, float)": "TYPE\n(F(fminimum)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fmaximumf(float, float)": "TYPE\n(F(fmaximum)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fminimum_numf(float, float)": "TYPE\n(F(fminimum_num)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fmaximum_numf(float, float)": "TYPE\n(F(fmaximum_num)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fminimum_magf(float, float)": "TYPE\n(F(fminimum_mag)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fmaximum_magf(float, float)": "TYPE\n(F(fmaximum_mag)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fminimum_mag_numf(float, float)": "TYPE\n(F(fminimum_mag_num)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fmaximum_mag_numf(float, float)": "TYPE\n(F(fmaximum_mag_num)) (TYPE x, TYPE y)\n{\n  ++count;\n  P ();\n  return x + y;\n}",
    "fmaf(float, float, float)": "TYPE\n(F(fma)) (TYPE x, TYPE y, TYPE z)\n{\n  counts[T][C_fma]++;\n  P ();\n  return x + y + z;\n}",
    "cacosf(_Complex float)": "complex TYPE\n(F(cacos)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "casinf(_Complex float)": "complex TYPE\n(F(casin)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "catanf(_Complex float)": "complex TYPE\n(F(catan)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "ccosf(_Complex float)": "complex TYPE\n(F(ccos)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "csinf(_Complex float)": "complex TYPE\n(F(csin)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "ctanf(_Complex float)": "complex TYPE\n(F(ctan)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "cacoshf(_Complex float)": "complex TYPE\n(F(cacosh)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "casinhf(_Complex float)": "complex TYPE\n(F(casinh)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "catanhf(_Complex float)": "complex TYPE\n(F(catanh)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "ccoshf(_Complex float)": "complex TYPE\n(F(ccosh)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "csinhf(_Complex float)": "complex TYPE\n(F(csinh)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "ctanhf(_Complex float)": "complex TYPE\n(F(ctanh)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "cexpf(_Complex float)": "complex TYPE\n(F(cexp)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "clogf(_Complex float)": "complex TYPE\n(F(clog)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "csqrtf(_Complex float)": "complex TYPE\n(F(csqrt)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "cpowf(_Complex float, _Complex float)": "complex TYPE\n(F(cpow)) (complex TYPE x, complex TYPE y)\n{\n  ++ccount;\n  P ();\n  return x + y;\n}",
    "cabsf(_Complex float)": "TYPE\n(F(cabs)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "cargf(_Complex float)": "TYPE\n(F(carg)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "crealf(_Complex float)": "TYPE\n(F(creal)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return __real__ x;\n}",
    "cimagf(_Complex float)": "TYPE\n(F(cimag)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return __imag__ x;\n}",
    "conjf(_Complex float)": "complex TYPE\n(F(conj)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "cprojf(_Complex float)": "complex TYPE\n(F(cproj)) (complex TYPE x)\n{\n  ++ccount;\n  P ();\n  return x;\n}",
    "ccos(cdouble)": "CTYPE\n(F(ccos)) (CTYPE x)\n{\n  counts[C][C_cos]++;\n  P ();\n  return x;\n}",
    "cabs(cdouble)": "TYPE\n(F(cabs)) (CTYPE x)\n{\n  counts[T][C_cabs]++;\n  P ();\n  return x;\n}",
    "conj(cdouble)": "CTYPE\n(F(conj)) (CTYPE x)\n{\n  counts[C][C_conj]++;\n  P ();\n  return x;\n}",
    "cpow(cdouble, cdouble)": "CTYPE\n(F(cpow)) (CTYPE x, CTYPE y)\n{\n  counts[C][C_pow]++;\n  P ();\n  return x + y;\n}",
    "ccosf(cfloat)": "CTYPE\n(F(ccos)) (CTYPE x)\n{\n  counts[C][C_cos]++;\n  P ();\n  return x;\n}",
    "cabsf(cfloat)": "TYPE\n(F(cabs)) (CTYPE x)\n{\n  counts[T][C_cabs]++;\n  P ();\n  return x;\n}",
    "conjf(cfloat)": "CTYPE\n(F(conj)) (CTYPE x)\n{\n  counts[C][C_conj]++;\n  P ();\n  return x;\n}",
    "cpowf(cfloat, cfloat)": "CTYPE\n(F(cpow)) (CTYPE x, CTYPE y)\n{\n  counts[C][C_pow]++;\n  P ();\n  return x + y;\n}",
    "acct(const char *)": "int\nacct (const char *name)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__libc_allocate_once_slow(void **, void *(*)(void *), void (*)(void *, void *), void *)": "void *\n__libc_allocate_once_slow (void **place, void *(*allocate) (void *closure),\n                           void (*deallocate) (void *closure, void *ptr),\n                           void *closure)\n{\n  void *result = allocate (closure);\n  if (result == NULL)\n    return NULL;\n\n  /* This loop implements a strong CAS on *place, with acquire-release\n     MO semantics, from a weak CAS with relaxed-release MO.  */\n  while (true)\n    {\n      /* Synchronizes with the acquire MO load in allocate_once.  */\n      void *expected = NULL;\n      if (atomic_compare_exchange_weak_release (place, &expected, result))\n        return result;\n\n      /* The failed CAS has relaxed MO semantics, so perform another\n         acquire MO load.  */\n      void *other_result = atomic_load_acquire (place);\n      if (other_result == NULL)\n        /* Spurious failure.  Try again.  */\n        continue;\n\n      /* We lost the race.  Free what we allocated and return the\n         other result.  */\n      if (deallocate == NULL)\n        free (result);\n      else\n        deallocate (closure, result);\n      return other_result;\n    }\n\n  return result;\n}",
    "chflags(const char *, unsigned long)": "int\nchflags (const char *file, unsigned long int flags)\n{\n  error_t err;\n  file_t port = __file_name_lookup (file, 0, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = __file_chflags (port, flags);\n  __mach_port_deallocate (__mach_task_self (), port);\n  if (err)\n    return __hurd_fail (err);\n  return 0;\n}",
    "chroot(const char *)": "int\nchroot (const char *path)\n{\n  const char *lookup;\n  size_t len;\n  file_t dir, root;\n  error_t err;\n\n  /* Append trailing \"/.\" to directory name to force ENOTDIR if it's not a\n     directory and EACCES if we don't have search permission.  */\n  len = strlen (path);\n  if (len >= 2 && path[len - 2] == '/' && path[len - 1] == '.')\n    lookup = path;\n  else if (len == 0)\n    /* Special-case empty file name according to POSIX.  */\n    return __hurd_fail (ENOENT);\n  else\n    {\n      char *n = alloca (len + 3);\n      memcpy (n, path, len);\n      n[len] = '/';\n      n[len + 1] = '.';\n      n[len + 2] = '\\0';\n      lookup = n;\n    }\n\n  dir = __file_name_lookup (lookup, 0, 0);\n  if (dir == MACH_PORT_NULL)\n    return -1;\n\n  /* Prevent going through DIR's ..  */\n  err = __file_reparent (dir, MACH_PORT_NULL, &root);\n  __mach_port_deallocate (__mach_task_self (), dir);\n  if (err)\n    return __hurd_fail (err);\n\n  _hurd_port_set (&_hurd_ports[INIT_PORT_CRDIR], root);\n  return 0;\n}",
    "daemon(int, int)": "int\ndaemon (int nochdir, int noclose)\n{\n  int fd;\n\n  switch (__fork ())\n    {\n    case -1:\n      return -1;\n\n    case 0:\n      break;\n\n    default:\n      _exit (0);\n    }\n\n  if (__setsid () == -1)\n    return -1;\n\n  if (!nochdir)\n    (void) __chdir (\"/\");\n\n  if (!noclose)\n    {\n      struct __stat64_t64 st;\n\n      fd = __open_nocancel (_PATH_DEVNULL, O_RDWR, 0);\n      if (fd != -1 && __glibc_likely (__fstat64_time64 (fd, &st) == 0))\n        {\n          if (__builtin_expect (S_ISCHR (st.st_mode), 1) != 0\n#if defined DEV_NULL_MAJOR && defined DEV_NULL_MINOR\n              && (st.st_rdev == makedev (DEV_NULL_MAJOR, DEV_NULL_MINOR))\n#endif\n             )\n            {\n              (void) __dup2 (fd, STDIN_FILENO);\n              (void) __dup2 (fd, STDOUT_FILENO);\n              (void) __dup2 (fd, STDERR_FILENO);\n              if (fd > 2)\n                (void) __close (fd);\n            }\n          else\n            {\n              /* We must set an errno value since no function call\n                 actually failed.  */\n              __close_nocancel_nostatus (fd);\n              __set_errno (ENODEV);\n              return -1;\n            }\n        }\n      else\n        {\n          __close_nocancel_nostatus (fd);\n          return -1;\n        }\n    }\n\n  return 0;\n}",
    "dirname(char *)": "char *\ndirname (char *path)\n{\n  static const char dot[] = \".\";\n  char *last_slash;\n\n  /* Find last '/'.  */\n  last_slash = path != NULL ? strrchr (path, '/') : NULL;\n\n  if (last_slash != NULL && last_slash != path && last_slash[1] == '\\0')\n    {\n      /* Determine whether all remaining characters are slashes.  */\n      char *runp;\n\n      for (runp = last_slash; runp != path; --runp)\n\tif (runp[-1] != '/')\n\t  break;\n\n      /* The '/' is the last character, we have to look further.  */\n      if (runp != path)\n\tlast_slash = __memrchr (path, '/', runp - path);\n    }\n\n  if (last_slash != NULL)\n    {\n      /* Determine whether all remaining characters are slashes.  */\n      char *runp;\n\n      for (runp = last_slash; runp != path; --runp)\n\tif (runp[-1] != '/')\n\t  break;\n\n      /* Terminate the path.  */\n      if (runp == path)\n\t{\n\t  /* The last slash is the first character in the string.  We have to\n\t     return \"/\".  As a special case we have to return \"//\" if there\n\t     are exactly two slashes at the beginning of the string.  See\n\t     XBD 4.10 Path Name Resolution for more information.  */\n\t  if (last_slash == path + 1)\n\t    ++last_slash;\n\t  else\n\t    last_slash = path + 1;\n\t}\n      else\n\tlast_slash = runp;\n\n      last_slash[0] = '\\0';\n    }\n  else\n    /* This assignment is ill-designed but the XPG specs require to\n       return a string containing \".\" in any case no directory part is\n       found and so a static and constant string is required.  */\n    path = (char *) dot;\n\n  return path;\n}",
    "vwarn(const char *, void *)": "void\nvwarn (const char *format, __gnuc_va_list ap)\n{\n  __vwarn_internal (format, ap, 0);\n}",
    "errx(int, const char *, ...)": "void\nerrx (int status, const char *format, ...)\n{\n  VA (verrx (status, format, ap))\n}",
    "error_at_line(int, int, const char *, unsigned int, const char *, ...)": "void\nerror_at_line (int status, int errnum, const char *file_name,\n\t       unsigned int line_number, const char *message, ...)\n{\n  va_list ap;\n  va_start (ap, message);\n  __error_at_line_internal (status, errnum, file_name, line_number,\n\t\t\t    message, ap, 0);\n  va_end (ap);\n}",
    "fchflags(int, unsigned long)": "int\nfchflags (int fd, unsigned long int flags)\n{\n  error_t err;\n\n  if (err = HURD_DPORT_USE (fd, __file_chflags (port, flags)))\n    return __hurd_dfail (fd, err);\n\n  return 0;\n}",
    "fdatasync(int)": "int\nfdatasync (int fd)\n{\n  error_t err;\n  int cancel_oldtype;\n\n  cancel_oldtype = LIBC_CANCEL_ASYNC();\n  err = HURD_DPORT_USE_CANCEL (fd, __file_sync (port, 1, 1));\n  LIBC_CANCEL_RESET (cancel_oldtype);\n  if (err)\n    {\n      if (err == EOPNOTSUPP)\n\t/* If the file descriptor does not support sync, return EINVAL\n\t   as POSIX specifies.  */\n\terr = EINVAL;\n      return __hurd_dfail (fd, err);\n    }\n  return 0;\n}",
    "fgetxattr(int, const char *, void *, int)": "ssize_t\nfgetxattr (int fd, const char *name, void *value, size_t size)\n{\n  error_t err;\n\n  err = HURD_DPORT_USE (fd, _hurd_xattr_get (port, name, value, &size));\n\n  return err ? __hurd_dfail (fd, err) : size;\n}",
    "flistxattr(int, char *, int)": "ssize_t\nflistxattr (int fd, char *list, size_t size)\n{\n  error_t err;\n\n  err = HURD_DPORT_USE (fd, _hurd_xattr_list (port, list, &size));\n\n  return err ? __hurd_dfail (fd, err) : size;\n}",
    "fremovexattr(int, const char *)": "int\nfremovexattr (int fd, const char *name)\n{\n  error_t err;\n\n  err = HURD_DPORT_USE (fd, _hurd_xattr_remove (port, name));\n\n  return err ? __hurd_dfail (fd, err) : 0;\n}",
    "fsetxattr(int, const char *, const void *, int, int)": "int\nfsetxattr (int fd, const char *name, const void *value, size_t size, int flags)\n{\n  error_t err;\n\n  err = HURD_DPORT_USE (fd, _hurd_xattr_set (port, name, value, size, flags));\n\n  return err ? __hurd_dfail (fd, err) : 0;\n}",
    "setfsent()": "int\nsetfsent (void)\n{\n  return fstab_init (1) != NULL;\n}",
    "getfsent()": "struct fstab *\ngetfsent (void)\n{\n  struct fstab_state *state;\n\n  state = fstab_init (0);\n  if (state == NULL)\n    return NULL;\n  if (fstab_fetch (state) == NULL)\n    return NULL;\n  return fstab_convert (state);\n}",
    "getfsspec(const char *)": "struct fstab *\ngetfsspec (const char *name)\n{\n  struct fstab_state *state;\n  struct mntent *m;\n\n  state = fstab_init (1);\n  if (state == NULL)\n    return NULL;\n  while ((m = fstab_fetch (state)) != NULL)\n    if (strcmp (m->mnt_fsname, name) == 0)\n      return fstab_convert (state);\n  return NULL;\n}",
    "getfsfile(const char *)": "struct fstab *\ngetfsfile (const char *name)\n{\n  struct fstab_state *state;\n  struct mntent *m;\n\n  state = fstab_init (1);\n  if (state == NULL)\n    return NULL;\n  while ((m = fstab_fetch (state)) != NULL)\n    if (strcmp (m->mnt_dir, name) == 0)\n      return fstab_convert (state);\n  return NULL;\n}",
    "endfsent()": "void\nendfsent (void)\n{\n  struct fstab_state *state;\n\n  state = &fstab_state;\n  if (state->fs_fp != NULL)\n    {\n      (void) __endmntent (state->fs_fp);\n      state->fs_fp = NULL;\n    }\n}",
    "fsync(int)": "int\nfsync (int fd)\n{\n  error_t err;\n  int cancel_oldtype;\n\n  cancel_oldtype = LIBC_CANCEL_ASYNC();\n  err = HURD_DPORT_USE_CANCEL (fd, __file_sync (port, 1, 0));\n  LIBC_CANCEL_RESET (cancel_oldtype);\n  if (err)\n    {\n      if (err == EOPNOTSUPP)\n\t/* If the file descriptor does not support sync, return EINVAL\n\t   as POSIX specifies.  */\n\terr = EINVAL;\n      return __hurd_dfail (fd, err);\n    }\n  return 0;\n}",
    "futimesat(int, const char *, const struct timeval *)": "int\nfutimesat (int fd, const char *file, const struct timeval tvp[2])\n{\n  if (fd < 0\n      && (file == NULL\n          || (fd != AT_FDCWD && file[0] != '/')))\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "getdomainname(char *, int)": "int\ngetdomainname (char *name, size_t len)\n{\n  /* The NIS domain name is just the contents of the file /etc/nisdomain.  */\n  ssize_t n = _hurd_get_host_config (\"/etc/nisdomain\", name, len);\n  return n < 0 ? -1 : 0;\n}",
    "gethostid()": "long int\ngethostid (void)\n{\n  char hostname[MAXHOSTNAMELEN + 1];\n  struct hostent hostbuf, *hp;\n  int32_t id;\n  struct in_addr in;\n  int herr;\n  int fd;\n\n  /* First try to get the ID from a former invocation of sethostid.  */\n  fd = __open_nocancel (HOSTIDFILE, O_RDONLY|O_LARGEFILE, 0);\n  if (fd >= 0)\n    {\n      ssize_t n = __read_nocancel (fd, &id, sizeof (id));\n\n      __close_nocancel_nostatus (fd);\n\n      if (n == sizeof (id))\n\treturn id;\n    }\n\n  /* Getting from the file was not successful.  An intelligent guess\n     for a unique number of a host is its IP address.  To get the IP\n     address we need to know the host name.  */\n  if (__gethostname (hostname, MAXHOSTNAMELEN) < 0 || hostname[0] == '\\0')\n    /* This also fails.  Return and arbitrary value.  */\n    return 0;\n\n  /* Determine the IP address of the host name.  */\n  struct scratch_buffer tmpbuf;\n  scratch_buffer_init (&tmpbuf);\n  while (true)\n    {\n      int ret = __gethostbyname_r (hostname, &hostbuf,\n\t\t\t\t   tmpbuf.data, tmpbuf.length, &hp, &herr);\n      if (ret == 0 && hp != NULL)\n\tbreak;\n      else\n\t{\n\t  /* Enlarge the buffer on ERANGE.  */\n\t  if (ret != 0 && herr == NETDB_INTERNAL && errno == ERANGE)\n\t    {\n\t      if (!scratch_buffer_grow (&tmpbuf))\n\t\treturn 0;\n\t    }\n\t  /* Other errors are a failure.  Return an arbitrary value.  */\n\t  else\n\t    {\n\t      scratch_buffer_free (&tmpbuf);\n\t      return 0;\n\t    }\n\t}\n    }\n\n  in.s_addr = 0;\n  memcpy (&in, hp->h_addr,\n\t  (int) sizeof (in) < hp->h_length ? (int) sizeof (in) : hp->h_length);\n  scratch_buffer_free (&tmpbuf);\n  /* For the return value to be not exactly the IP address we do some\n     bit fiddling.  */\n  return (int32_t) (in.s_addr << 16 | in.s_addr >> 16);\n}",
    "getloadavg(double *, int)": "int\ngetloadavg (double loadavg[], int nelem)\n{\n  struct sysinfo info;\n\n  if (__sysinfo (&info) != 0)\n    return -1;\n\n  nelem = CLAMP (nelem, 0, array_length (info.loads));\n\n  for (int i = 0; i < nelem; i++)\n    loadavg[i] = (double) info.loads[i] / SYSINFO_LOADS_SCALE;\n\n  return nelem;\n}",
    "__getpagesize()": "int\n__getpagesize (void)\n{\n  int result;\n\n  if (GLRO(dl_pagesize) != 0)\n    return GLRO(dl_pagesize);\n\n  result = INTERNAL_SYSCALL_CALL (getpagesize);\n  /* The only possible error is ENOSYS.  */\n  if (!INTERNAL_SYSCALL_ERROR_P (result))\n    return result;\n\n  return 4096;\n}",
    "getpass(const char *)": "char *\ngetpass (const char *prompt)\n{\n  FILE *in, *out;\n  struct termios s, t;\n  int tty_changed;\n  static char *buf;\n  static size_t bufsize;\n  ssize_t nread;\n\n  /* Try to write to and read from the terminal if we can.\n     If we can't open the terminal, use stderr and stdin.  */\n\n  in = fopen (\"/dev/tty\", \"w+ce\");\n  if (in == NULL)\n    {\n      in = stdin;\n      out = stderr;\n    }\n  else\n    {\n      /* We do the locking ourselves.  */\n      __fsetlocking (in, FSETLOCKING_BYCALLER);\n\n      out = in;\n    }\n\n  /* Make sure the stream we opened is closed even if the thread is\n     canceled.  */\n  __libc_cleanup_push (call_fclose, in == out ? in : NULL);\n\n  flockfile (out);\n\n  /* Turn echoing off if it is on now.  */\n\n  if (__tcgetattr (fileno (in), &t) == 0)\n    {\n      /* Save the old one. */\n      s = t;\n      /* Tricky, tricky. */\n      t.c_lflag &= ~(ECHO|ISIG);\n      tty_changed = (tcsetattr (fileno (in), TCSAFLUSH|TCSASOFT, &t) == 0);\n    }\n  else\n    tty_changed = 0;\n\n  /* Write the prompt.  */\n  __fxprintf (out, \"%s\", prompt);\n  __fflush_unlocked (out);\n\n  /* Read the password.  */\n  nread = __getline (&buf, &bufsize, in);\n  if (buf != NULL)\n    {\n      if (nread < 0)\n\tbuf[0] = '\\0';\n      else if (buf[nread - 1] == '\\n')\n\t{\n\t  /* Remove the newline.  */\n\t  buf[nread - 1] = '\\0';\n\t  if (tty_changed)\n\t    /* Write the newline that was not echoed.  */\n\t    __fxprintf (out, \"\\n\");\n\t}\n    }\n\n  /* Restore the original setting.  */\n  if (tty_changed)\n    (void) tcsetattr (fileno (in), TCSAFLUSH|TCSASOFT, &s);\n\n  funlockfile (out);\n\n  __libc_cleanup_pop (0);\n\n  if (in != stdin)\n    /* We opened the terminal; now close it.  */\n    fclose (in);\n\n  return buf;\n}",
    "getusershell()": "char *\ngetusershell (void)\n{\n\tchar *ret;\n\n\tif (curshell == NULL)\n\t\tcurshell = initshells();\n\tret = *curshell;\n\tif (ret != NULL)\n\t\tcurshell++;\n\treturn (ret);\n}",
    "endusershell()": "void\nendusershell (void)\n{\n\n\tfree(shells);\n\tshells = NULL;\n\tfree(strings);\n\tstrings = NULL;\n\tcurshell = NULL;\n}",
    "setusershell()": "void\nsetusershell (void)\n{\n\n\tcurshell = initshells();\n}",
    "getxattr(const char *, const char *, void *, int)": "ssize_t\ngetxattr (const char *path, const char *name, void *value, size_t size)\n{\n  error_t err;\n  file_t port = __file_name_lookup (path, 0, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = _hurd_xattr_get (port, name, value, &size);\n  __mach_port_deallocate (__mach_task_self (), port);\n  return err ? __hurd_fail (err) : size;\n}",
    "gtty(int, struct sgttyb *)": "int\ngtty (int fd, struct sgttyb *params)\n{\n  return __ioctl (fd, TIOCGETP, (void *) params);\n}",
    "hsearch(ENTRY, ACTION)": "ENTRY *\nhsearch (ENTRY item, ACTION action)\n{\n  ENTRY *result;\n\n  (void) __hsearch_r (item, action, &result, &htab);\n\n  return result;\n}",
    "hcreate(int)": "int\nhcreate (size_t nel)\n{\n  return __hcreate_r (nel, &htab);\n}",
    "__libc_ifunc_impl_list(const char *, struct libc_ifunc_impl *, int)": "size_t\n__libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,\n\t\t\tsize_t max)\n{\n  size_t i = max;\n\n  /* Support sysdeps/x86_64/multiarch/memcmpeq.c.  */\n  IFUNC_IMPL (i, name, __memcmpeq,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memcmpeq,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memcmpeq_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memcmpeq,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memcmpeq_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memcmpeq,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memcmpeq_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memcmpeq,\n\t\t\t\t     1,\n\t\t\t\t     __memcmpeq_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/memchr.c.  */\n  IFUNC_IMPL (i, name, memchr,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memchr_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memchr_evex512)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memchr_evex_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memchr_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memchr_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memchr,\n\t\t\t\t     1,\n\t\t\t\t     __memchr_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/memcmp.c.  */\n  IFUNC_IMPL (i, name, memcmp,\n\t      /* NB: If any of these names change or if any new\n\t         implementations are added be sure to update\n\t         sysdeps/x86_64/memcmp-isa-default-impl.h.  */\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (MOVBE)),\n\t\t\t\t     __memcmp_evex_movbe)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (MOVBE)),\n\t\t\t\t     __memcmp_avx2_movbe)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (MOVBE)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memcmp_avx2_movbe_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memcmp,\n\t\t\t\t     1,\n\t\t\t\t     __memcmp_sse2))\n\n#ifdef SHARED\n  /* Support sysdeps/x86_64/multiarch/memmove_chk.c.  */\n  IFUNC_IMPL (i, name, __memmove_chk,\n\t      IFUNC_IMPL_ADD (array, i, __memmove_chk, 1,\n\t\t\t      __memmove_chk_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memmove_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512F),\n\t\t\t\t     __memmove_chk_avx512_no_vzeroupper)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memmove_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memmove_chk_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memmove_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memmove_chk_avx512_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memmove_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memmove_chk_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memmove_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memmove_chk_evex_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memmove_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __memmove_chk_avx_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memmove_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __memmove_chk_avx_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memmove_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memmove_chk_avx_unaligned_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memmove_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memmove_chk_avx_unaligned_erms_rtm)\n\t      /* By V3 we assume fast aligned copy.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memmove_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (SSSE3),\n\t\t\t\t     __memmove_chk_ssse3)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memmove_chk, 1,\n\t\t\t\t     __memmove_chk_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memmove_chk, 1,\n\t\t\t\t     __memmove_chk_sse2_unaligned_erms))\n#endif\n\n  /* Support sysdeps/x86_64/multiarch/memmove.c.  */\n  IFUNC_IMPL (i, name, memmove,\n\t      IFUNC_IMPL_ADD (array, i, memmove, 1,\n\t\t\t      __memmove_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memmove,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512F),\n\t\t\t\t     __memmove_avx512_no_vzeroupper)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memmove,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memmove_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memmove,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memmove_avx512_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memmove,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memmove_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memmove,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memmove_evex_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memmove,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __memmove_avx_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memmove,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __memmove_avx_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memmove,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memmove_avx_unaligned_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memmove,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memmove_avx_unaligned_erms_rtm)\n\t      /* By V3 we assume fast aligned copy.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memmove,\n\t\t\t\t     CPU_FEATURE_USABLE (SSSE3),\n\t\t\t\t     __memmove_ssse3)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memmove, 1,\n\t\t\t\t     __memmove_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memmove, 1,\n\t\t\t\t     __memmove_sse2_unaligned_erms))\n\n  /* Support sysdeps/x86_64/multiarch/memrchr.c.  */\n  IFUNC_IMPL (i, name, memrchr,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (LZCNT)),\n\t\t\t\t     __memrchr_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (LZCNT)),\n\t\t\t\t     __memrchr_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (LZCNT)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memrchr_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memrchr,\n\t\t\t\t     1,\n\t\t\t\t     __memrchr_sse2))\n\n#ifdef SHARED\n  /* Support sysdeps/x86_64/multiarch/memset_chk.c.  */\n  IFUNC_IMPL (i, name, __memset_chk,\n\t      IFUNC_IMPL_ADD (array, i, __memset_chk, 1,\n\t\t\t      __memset_chk_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memset_chk_avx512_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memset_chk_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memset_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512F),\n\t\t\t\t     __memset_chk_avx512_no_vzeroupper)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memset_chk_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memset_chk_evex_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memset_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __memset_chk_avx2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memset_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __memset_chk_avx2_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memset_chk_avx2_unaligned_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memset_chk_avx2_unaligned_erms_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memset_chk, 1,\n\t\t\t\t     __memset_chk_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memset_chk, 1,\n\t\t\t\t     __memset_chk_sse2_unaligned_erms)\n\t      )\n#endif\n\n  /* Support sysdeps/x86_64/multiarch/memset.c.  */\n  IFUNC_IMPL (i, name, memset,\n\t      IFUNC_IMPL_ADD (array, i, memset, 1,\n\t\t\t      __memset_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memset_avx512_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memset_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memset,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512F),\n\t\t\t\t     __memset_avx512_no_vzeroupper)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memset_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memset_evex_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memset,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __memset_avx2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memset,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __memset_avx2_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memset_avx2_unaligned_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memset_avx2_unaligned_erms_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memset, 1,\n\t\t\t\t     __memset_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memset, 1,\n\t\t\t\t     __memset_sse2_unaligned_erms)\n\t     )\n\n  /* Support sysdeps/x86_64/multiarch/rawmemchr.c.  */\n  IFUNC_IMPL (i, name, rawmemchr,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, rawmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __rawmemchr_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, rawmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __rawmemchr_evex512)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, rawmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __rawmemchr_evex_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, rawmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __rawmemchr_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, rawmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __rawmemchr_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, rawmemchr,\n\t\t\t\t     1,\n\t\t\t\t     __rawmemchr_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strlen.c.  */\n  IFUNC_IMPL (i, name, strlen,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strlen_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strlen_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strlen_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strlen_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strlen,\n\t\t\t\t     1,\n\t\t\t\t     __strlen_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strnlen.c.  */\n  IFUNC_IMPL (i, name, strnlen,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strnlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strnlen_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strnlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strnlen_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strnlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strnlen_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strnlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strnlen_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strnlen,\n\t\t\t\t     1,\n\t\t\t\t     __strnlen_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/stpncpy.c.  */\n  IFUNC_IMPL (i, name, stpncpy,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, stpncpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __stpncpy_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, stpncpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __stpncpy_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, stpncpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __stpncpy_avx2_rtm)\n\t      /* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, stpncpy,\n\t\t\t\t     1,\n\t\t\t\t     __stpncpy_sse2_unaligned))\n\n  /* Support sysdeps/x86_64/multiarch/stpcpy.c.  */\n  IFUNC_IMPL (i, name, stpcpy,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, stpcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __stpcpy_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, stpcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __stpcpy_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, stpcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __stpcpy_avx2_rtm)\n\t      /* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, stpcpy,\n\t\t\t\t     1,\n\t\t\t\t     __stpcpy_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V1 (array, i, stpcpy,\n\t\t\t\t     1,\n\t\t\t\t     __stpcpy_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strcasecmp_l.c.  */\n  IFUNC_IMPL (i, name, strcasecmp,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strcasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strcasecmp_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strcasecmp_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strcasecmp_avx2_rtm)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcasecmp,\n\t\t\t\t     CPU_FEATURE_USABLE (SSE4_2),\n\t\t\t\t     __strcasecmp_sse42)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcasecmp,\n\t\t\t\t     1,\n\t\t\t\t     __strcasecmp_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strcasecmp_l.c.  */\n  IFUNC_IMPL (i, name, strcasecmp_l,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strcasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strcasecmp_l_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strcasecmp_l_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strcasecmp_l_avx2_rtm)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcasecmp_l,\n\t\t\t\t     CPU_FEATURE_USABLE (SSE4_2),\n\t\t\t\t     __strcasecmp_l_sse42)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcasecmp_l,\n\t\t\t\t     1,\n\t\t\t\t     __strcasecmp_l_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strcat.c.  */\n  IFUNC_IMPL (i, name, strcat,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strcat,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __strcat_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcat,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __strcat_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcat,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strcat_avx2_rtm)\n\t      /* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcat,\n\t\t\t\t     1,\n\t\t\t\t     __strcat_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V1 (array, i, strcat,\n\t\t\t\t     1,\n\t\t\t\t     __strcat_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strchr.c.  */\n  IFUNC_IMPL (i, name, strchr,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strchr_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __strchr_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strchr_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strchr_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strchr,\n\t\t\t\t     1,\n\t\t\t\t     __strchr_sse2)\n\t      X86_IFUNC_IMPL_ADD_V1 (array, i, strchr,\n\t\t\t\t     1,\n\t\t\t\t     __strchr_sse2_no_bsf))\n\n  /* Support sysdeps/x86_64/multiarch/strchrnul.c.  */\n  IFUNC_IMPL (i, name, strchrnul,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strchrnul,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strchrnul_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strchrnul,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __strchrnul_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strchrnul,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strchrnul_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strchrnul,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strchrnul_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strchrnul,\n\t\t\t\t     1,\n\t\t\t\t     __strchrnul_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strrchr.c.  */\n  IFUNC_IMPL (i, name, strrchr,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI1)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strrchr_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strrchr_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI1)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strrchr_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI1)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strrchr_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strrchr,\n\t\t\t\t     1,\n\t\t\t\t     __strrchr_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strcmp.c.  */\n  IFUNC_IMPL (i, name, strcmp,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strcmp_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strcmp_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strcmp_avx2_rtm)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcmp,\n                                 CPU_FEATURE_USABLE (SSE4_2),\n                                 __strcmp_sse42)\n\t      /* ISA V2 wrapper for SSE2 implementations because the SSE2\n\t         implementations are also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcmp,\n\t\t\t\t     1,\n\t\t\t\t     __strcmp_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcmp,\n\t\t\t\t     1,\n\t\t\t\t     __strcmp_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strcpy.c.  */\n  IFUNC_IMPL (i, name, strcpy,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __strcpy_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __strcpy_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strcpy_avx2_rtm)\n\t      /* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcpy,\n\t\t\t\t     1,\n\t\t\t\t     __strcpy_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V1 (array, i, strcpy,\n\t\t\t\t     1,\n\t\t\t\t     __strcpy_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strcspn.c.  */\n  IFUNC_IMPL (i, name, strcspn,\n\t      /* All implementations of strcspn are built at all ISA\n\t         levels.  */\n\t      IFUNC_IMPL_ADD (array, i, strcspn, CPU_FEATURE_USABLE (SSE4_2),\n\t\t\t      __strcspn_sse42)\n\t      IFUNC_IMPL_ADD (array, i, strcspn, 1, __strcspn_generic))\n\n  /* Support sysdeps/x86_64/multiarch/strncase_l.c.  */\n  IFUNC_IMPL (i, name, strncasecmp,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strncasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strncasecmp_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strncasecmp_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strncasecmp_avx2_rtm)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strncasecmp,\n\t\t\t\t     CPU_FEATURE_USABLE (SSE4_2),\n\t\t\t\t     __strncasecmp_sse42)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strncasecmp,\n\t\t\t\t     1,\n\t\t\t\t     __strncasecmp_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strncase_l.c.  */\n  IFUNC_IMPL (i, name, strncasecmp_l,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strncasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      & CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strncasecmp_l_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strncasecmp_l_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strncasecmp_l_avx2_rtm)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strncasecmp_l,\n\t\t\t\t     CPU_FEATURE_USABLE (SSE4_2),\n\t\t\t\t     __strncasecmp_l_sse42)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strncasecmp_l,\n\t\t\t\t     1,\n\t\t\t\t     __strncasecmp_l_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strncat.c.  */\n  IFUNC_IMPL (i, name, strncat,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strncat,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __strncat_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncat,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __strncat_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncat,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strncat_avx2_rtm)\n\t      /* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strncat,\n\t\t\t\t     1,\n\t\t\t\t     __strncat_sse2_unaligned))\n\n  /* Support sysdeps/x86_64/multiarch/strncpy.c.  */\n  IFUNC_IMPL (i, name, strncpy,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strncpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __strncpy_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __strncpy_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strncpy_avx2_rtm)\n\t      /* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strncpy,\n\t\t\t\t     1,\n\t\t\t\t     __strncpy_sse2_unaligned))\n\n  /* Support sysdeps/x86_64/multiarch/strpbrk.c.  */\n  IFUNC_IMPL (i, name, strpbrk,\n\t      /* All implementations of strpbrk are built at all ISA\n\t         levels.  */\n\t      IFUNC_IMPL_ADD (array, i, strpbrk, CPU_FEATURE_USABLE (SSE4_2),\n\t\t\t      __strpbrk_sse42)\n\t      IFUNC_IMPL_ADD (array, i, strpbrk, 1, __strpbrk_generic))\n\n\n  /* Support sysdeps/x86_64/multiarch/strspn.c.  */\n  IFUNC_IMPL (i, name, strspn,\n\t      /* All implementations of strspn are built at all ISA\n\t         levels.  */\n\t      IFUNC_IMPL_ADD (array, i, strspn, CPU_FEATURE_USABLE (SSE4_2),\n\t\t\t      __strspn_sse42)\n\t      IFUNC_IMPL_ADD (array, i, strspn, 1, __strspn_generic))\n\n  /* Support sysdeps/x86_64/multiarch/strstr.c.  */\n  IFUNC_IMPL (i, name, strstr,\n              IFUNC_IMPL_ADD (array, i, strstr,\n                              (CPU_FEATURE_USABLE (AVX512VL)\n                               && CPU_FEATURE_USABLE (AVX512BW)\n                               && CPU_FEATURE_USABLE (AVX512DQ)\n                               && CPU_FEATURE_USABLE (BMI2)),\n                              __strstr_avx512)\n\t      IFUNC_IMPL_ADD (array, i, strstr, 1, __strstr_sse2_unaligned)\n\t      IFUNC_IMPL_ADD (array, i, strstr, 1, __strstr_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wcschr.c.  */\n  IFUNC_IMPL (i, name, wcschr,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcschr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcschr_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcschr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __wcschr_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcschr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcschr_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcschr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wcschr_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcschr,\n\t\t\t\t     1,\n\t\t\t\t     __wcschr_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/wcsrchr.c.  */\n  IFUNC_IMPL (i, name, wcsrchr,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcsrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI1)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsrchr_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcsrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsrchr_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcsrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI1)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsrchr_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcsrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI1)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wcsrchr_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcsrchr,\n\t\t\t\t     1,\n\t\t\t\t     __wcsrchr_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/wcscmp.c.  */\n  IFUNC_IMPL (i, name, wcscmp,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcscmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcscmp_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcscmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcscmp_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcscmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wcscmp_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcscmp,\n\t\t\t\t     1,\n\t\t\t\t     __wcscmp_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/wcsncmp.c.  */\n  IFUNC_IMPL (i, name, wcsncmp,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcsncmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsncmp_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcsncmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsncmp_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcsncmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wcsncmp_avx2_rtm)\n\t      /* ISA V2 wrapper for GENERIC implementation because the\n\t         GENERIC implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcsncmp,\n\t\t\t\t     1,\n\t\t\t\t     __wcsncmp_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wcscpy.c.  */\n  IFUNC_IMPL (i, name, wcscpy,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcscpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcscpy_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcscpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcscpy_avx2)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcscpy,\n\t\t\t\t     CPU_FEATURE_USABLE (SSSE3),\n\t\t\t\t     __wcscpy_ssse3)\n\t      X86_IFUNC_IMPL_ADD_V1 (array, i, wcscpy,\n\t\t\t\t     1,\n\t\t\t\t     __wcscpy_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wcsncpy.c.  */\n  IFUNC_IMPL (i, name, wcsncpy,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcsncpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsncpy_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcsncpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsncpy_avx2)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcpncpy,\n\t\t\t\t     1,\n\t\t\t\t     __wcsncpy_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wcpcpy.c.  */\n  IFUNC_IMPL (i, name, wcpcpy,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcpcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcpcpy_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcpcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcpcpy_avx2)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcpcpy,\n\t\t\t\t     1,\n\t\t\t\t     __wcpcpy_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wcpncpy.c.  */\n  IFUNC_IMPL (i, name, wcpncpy,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcpncpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcpncpy_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcpncpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcpncpy_avx2)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcsncpy,\n\t\t\t\t     1,\n\t\t\t\t     __wcpncpy_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wcscat.c.  */\n  IFUNC_IMPL (i, name, wcscat,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcscat,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcscat_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcscat,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcscat_avx2)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcscat,\n\t\t\t\t     1,\n\t\t\t\t     __wcscat_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wcsncat.c.  */\n  IFUNC_IMPL (i, name, wcsncat,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcsncat,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsncat_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcsncat,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsncat_avx2)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcsncat,\n\t\t\t\t     1,\n\t\t\t\t     __wcsncat_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wcslen.c.  */\n  IFUNC_IMPL (i, name, wcslen,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcslen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcslen_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcslen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcslen_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcslen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcslen_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcslen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wcslen_avx2_rtm)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcslen,\n\t\t\t\t     CPU_FEATURE_USABLE (SSE4_1),\n\t\t\t\t     __wcslen_sse4_1)\n\t      X86_IFUNC_IMPL_ADD_V1 (array, i, wcslen,\n\t\t\t\t     1,\n\t\t\t\t     __wcslen_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/wcsnlen.c.  */\n  IFUNC_IMPL (i, name, wcsnlen,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcsnlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsnlen_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcsnlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsnlen_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcsnlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsnlen_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcsnlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wcsnlen_avx2_rtm)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcsnlen,\n\t\t\t\t     CPU_FEATURE_USABLE (SSE4_1),\n\t\t\t\t     __wcsnlen_sse4_1)\n\t      X86_IFUNC_IMPL_ADD_V1 (array, i, wcsnlen,\n\t\t\t\t     1,\n\t\t\t\t     __wcsnlen_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wmemchr.c.  */\n  IFUNC_IMPL (i, name, wmemchr,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wmemchr_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wmemchr_evex512)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wmemchr_evex_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wmemchr_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wmemchr_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wmemchr,\n\t\t\t\t     1,\n\t\t\t\t     __wmemchr_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/wmemcmp.c.  */\n  IFUNC_IMPL (i, name, wmemcmp,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wmemcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (MOVBE)),\n\t\t\t\t     __wmemcmp_evex_movbe)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wmemcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (MOVBE)),\n\t\t\t\t     __wmemcmp_avx2_movbe)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wmemcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (MOVBE)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wmemcmp_avx2_movbe_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wmemcmp,\n\t\t\t\t     1,\n\t\t\t\t     __wmemcmp_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/wmemset.c.  */\n  IFUNC_IMPL (i, name, wmemset,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wmemset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wmemset_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wmemset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wmemset_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wmemset,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __wmemset_avx2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wmemset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wmemset_avx2_unaligned_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wmemset, 1,\n\t\t\t\t     __wmemset_sse2_unaligned))\n\n#ifdef SHARED\n  /* Support sysdeps/x86_64/multiarch/memcpy_chk.c.  */\n  IFUNC_IMPL (i, name, __memcpy_chk,\n\t      IFUNC_IMPL_ADD (array, i, __memcpy_chk, 1,\n\t\t\t      __memcpy_chk_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512F),\n\t\t\t\t     __memcpy_chk_avx512_no_vzeroupper)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memcpy_chk_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memcpy_chk_avx512_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memcpy_chk_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memcpy_chk_evex_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __memcpy_chk_avx_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __memcpy_chk_avx_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memcpy_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memcpy_chk_avx_unaligned_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memcpy_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memcpy_chk_avx_unaligned_erms_rtm)\n\t      /* By V3 we assume fast aligned copy.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (SSSE3),\n\t\t\t\t     __memcpy_chk_ssse3)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memcpy_chk, 1,\n\t\t\t\t     __memcpy_chk_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memcpy_chk, 1,\n\t\t\t\t     __memcpy_chk_sse2_unaligned_erms))\n#endif\n\n  /* Support sysdeps/x86_64/multiarch/memcpy.c.  */\n  IFUNC_IMPL (i, name, memcpy,\n\t      IFUNC_IMPL_ADD (array, i, memcpy, 1,\n\t\t\t      __memcpy_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512F),\n\t\t\t\t     __memcpy_avx512_no_vzeroupper)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memcpy_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memcpy_avx512_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memcpy_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memcpy_evex_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __memcpy_avx_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __memcpy_avx_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memcpy_avx_unaligned_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memcpy_avx_unaligned_erms_rtm)\n\t      /* By V3 we assume fast aligned copy.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (SSSE3),\n\t\t\t\t     __memcpy_ssse3)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memcpy, 1,\n\t\t\t\t     __memcpy_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memcpy, 1,\n\t\t\t\t     __memcpy_sse2_unaligned_erms))\n\n#ifdef SHARED\n  /* Support sysdeps/x86_64/multiarch/mempcpy_chk.c.  */\n  IFUNC_IMPL (i, name, __mempcpy_chk,\n\t      IFUNC_IMPL_ADD (array, i, __mempcpy_chk, 1,\n\t\t\t      __mempcpy_chk_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __mempcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512F),\n\t\t\t\t     __mempcpy_chk_avx512_no_vzeroupper)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __mempcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __mempcpy_chk_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __mempcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __mempcpy_chk_avx512_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __mempcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __mempcpy_chk_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __mempcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __mempcpy_chk_evex_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __mempcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __mempcpy_chk_avx_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __mempcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __mempcpy_chk_avx_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __mempcpy_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __mempcpy_chk_avx_unaligned_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __mempcpy_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __mempcpy_chk_avx_unaligned_erms_rtm)\n\t      /* By V3 we assume fast aligned copy.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __mempcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (SSSE3),\n\t\t\t\t     __mempcpy_chk_ssse3)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __mempcpy_chk, 1,\n\t\t\t\t     __mempcpy_chk_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __mempcpy_chk, 1,\n\t\t\t\t     __mempcpy_chk_sse2_unaligned_erms))\n#endif\n\n  /* Support sysdeps/x86_64/multiarch/mempcpy.c.  */\n  IFUNC_IMPL (i, name, mempcpy,\n\t      IFUNC_IMPL_ADD (array, i, mempcpy, 1,\n\t\t\t      __mempcpy_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, mempcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512F),\n\t\t\t\t     __mempcpy_avx512_no_vzeroupper)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, mempcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __mempcpy_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, mempcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __mempcpy_avx512_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, mempcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __mempcpy_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, mempcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __mempcpy_evex_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, mempcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __mempcpy_avx_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, mempcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __mempcpy_avx_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, mempcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __mempcpy_avx_unaligned_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, mempcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __mempcpy_avx_unaligned_erms_rtm)\n\t      /* By V3 we assume fast aligned copy.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, mempcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (SSSE3),\n\t\t\t\t     __mempcpy_ssse3)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, mempcpy, 1,\n\t\t\t\t     __mempcpy_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, mempcpy, 1,\n\t\t\t\t     __mempcpy_sse2_unaligned_erms))\n\n  /* Support sysdeps/x86_64/multiarch/strncmp.c.  */\n  IFUNC_IMPL (i, name, strncmp,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strncmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strncmp_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strncmp_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strncmp_avx2_rtm)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strncmp,\n\t\t\t\t     CPU_FEATURE_USABLE (SSE4_2),\n\t\t\t\t     __strncmp_sse42)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strncmp,\n\t\t\t\t     1,\n\t\t\t\t     __strncmp_sse2))\n\n#ifdef SHARED\n  /* Support sysdeps/x86_64/multiarch/wmemset_chk.c.  */\n  IFUNC_IMPL (i, name, __wmemset_chk,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __wmemset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wmemset_chk_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __wmemset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wmemset_chk_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __wmemset_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __wmemset_chk_avx2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __wmemset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wmemset_chk_avx2_unaligned_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __wmemset_chk, 1,\n\t\t\t\t     __wmemset_chk_sse2_unaligned))\n#endif\n\n  return 0;\n}",
    "insque(void *, void *)": "void\ninsque (void *elem, void *prev)\n{\n  if (prev == NULL)\n    {\n      ((struct qelem *) elem)->q_forw = NULL;\n      ((struct qelem *) elem)->q_back = NULL;\n    }\n  else\n    {\n      struct qelem *next = ((struct qelem *) prev)->q_forw;\n      ((struct qelem *) prev)->q_forw = (struct qelem *) elem;\n      if (next != NULL)\n\tnext->q_back = (struct qelem *) elem;\n      ((struct qelem *) elem)->q_forw = next;\n      ((struct qelem *) elem)->q_back = (struct qelem *) prev;\n    }\n}",
    "remque(void *)": "void\nremque (void *elem)\n{\n  struct qelem *next = ((struct qelem *) elem)->q_forw;\n  struct qelem *prev = ((struct qelem *) elem)->q_back;\n  if (next != NULL)\n    next->q_back = prev;\n  if (prev != NULL)\n    prev->q_forw = (struct qelem *) next;\n}",
    "lgetxattr(const char *, const char *, void *, int)": "ssize_t\nlgetxattr (const char *path, const char *name, void *value, size_t size)\n{\n  error_t err;\n  file_t port = __file_name_lookup (path, O_NOLINK, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = _hurd_xattr_get (port, name, value, &size);\n  __mach_port_deallocate (__mach_task_self (), port);\n  return err ? __hurd_fail (err) : size;\n}",
    "listxattr(const char *, char *, int)": "ssize_t\nlistxattr (const char *path, char *list, size_t size)\n{\n  error_t err;\n  file_t port = __file_name_lookup (path, 0, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = _hurd_xattr_list (port, list, &size);\n  __mach_port_deallocate (__mach_task_self (), port);\n  return err ? __hurd_fail (err) : size;\n}",
    "llistxattr(const char *, char *, int)": "ssize_t\nllistxattr (const char *path, char *list, size_t size)\n{\n  error_t err;\n  file_t port = __file_name_lookup (path, O_NOLINK, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = _hurd_xattr_list (port, list, &size);\n  __mach_port_deallocate (__mach_task_self (), port);\n  return err ? __hurd_fail (err) : size;\n}",
    "lremovexattr(const char *, const char *)": "int\nlremovexattr (const char *path, const char *name)\n{\n  error_t err;\n  file_t port = __file_name_lookup (path, O_NOLINK, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = _hurd_xattr_remove (port, name);\n  __mach_port_deallocate (__mach_task_self (), port);\n  return __hurd_fail (err);\n}",
    "lsearch(const void *, void *, int *, int, __compar_fn_t)": "void *\nlsearch (const void *key, void *base, size_t *nmemb, size_t size,\n\t __compar_fn_t compar)\n{\n  void *result;\n\n  /* Try to find it.  */\n  result = lfind (key, base, nmemb, size, compar);\n  if (result == NULL)\n    {\n      /* Not available.  Insert at the end.  */\n      result = memcpy (base + (*nmemb) * size, key, size);\n      ++(*nmemb);\n    }\n\n  return result;\n}",
    "lfind(const void *, const void *, int *, int, __compar_fn_t)": "void *\nlfind (const void *key, const void *base, size_t *nmemb, size_t size,\n       __compar_fn_t compar)\n{\n  const void *result = base;\n  size_t cnt = 0;\n\n  while (cnt < *nmemb && (*compar) (key, result) != 0)\n    {\n      result += size;\n      ++cnt;\n    }\n\n  return cnt < *nmemb ? (void *) result : NULL;\n}",
    "lsetxattr(const char *, const char *, const void *, int, int)": "int\nlsetxattr (const char *path, const char *name, const void *value, size_t size,\n\t   int flags)\n{\n  error_t err;\n  file_t port = __file_name_lookup (path, O_NOLINK, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = _hurd_xattr_set (port, name, value, size, flags);\n  __mach_port_deallocate (__mach_task_self (), port);\n  return err ? __hurd_fail (err) : size;\n}",
    "__madvise(void *, int, int)": "int\n__madvise (void *addr, size_t len, int advice)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mincore(void *, int, unsigned char *)": "int\nmincore (void *__start, size_t __len, unsigned char *__vec)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mkdtemp(char *)": "char *\nmkdtemp (char *template)\n{\n  if (__gen_tempname (template, 0, 0, __GT_DIR))\n    return NULL;\n  else\n    return template;\n}",
    "mkostemp(char *, int)": "int\nmkostemp (char *template, int flags)\n{\n  return __gen_tempname (template, 0, flags, __GT_FILE);\n}",
    "mkostemps(char *, int, int)": "int\nmkostemps (char *template, int suffixlen, int flags)\n{\n  if (suffixlen < 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __gen_tempname (template, suffixlen, flags, __GT_FILE);\n}",
    "mkstemp(char *)": "int\nmkstemp (char *template)\n{\n  return __gen_tempname (template, 0, 0, __GT_FILE);\n}",
    "mkstemps(char *, int)": "int\nmkstemps (char *template, int suffixlen)\n{\n  if (suffixlen < 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __gen_tempname (template, suffixlen, 0, __GT_FILE);\n}",
    "__mktemp(char *)": "char *\n__mktemp (char *template)\n{\n  if (__gen_tempname (template, 0, 0, __GT_NOCREATE) < 0)\n    /* We return the null string if we can't find a unique file name.  */\n    template[0] = '\\0';\n\n  return template;\n}",
    "mlock(const void *, int)": "int\nmlock (const void *addr, size_t len)\n{\n  mach_port_t host;\n  vm_address_t page;\n  error_t err;\n\n  err = __get_privileged_ports (&host, NULL);\n  if (err)\n    host = __mach_host_self();\n\n  page = trunc_page ((vm_address_t) addr);\n  len = round_page ((vm_address_t) addr + len) - page;\n\n  err = __vm_wire (host, __mach_task_self (), page, len, VM_PROT_READ);\n  if (host != __mach_host_self())\n    __mach_port_deallocate (__mach_task_self (), host);\n\n  return err ? __hurd_fail (err) : 0;\n}",
    "mlockall(int)": "int\nmlockall (int flags)\n{\n  mach_port_t host;\n  error_t err;\n\n  err = __get_privileged_ports (&host, NULL);\n  if (err)\n    return __hurd_fail (err);\n\n  err = __vm_wire_all (host, __mach_task_self (), flags);\n  __mach_port_deallocate (__mach_task_self (), host);\n  return err ? __hurd_fail (err) : 0;\n}",
    "__mmap(void *, int, int, int, int, off_t)": "void *\n__mmap (void *addr, size_t len, int prot, int flags, int fd, off_t offset)\n{\n  error_t err;\n  vm_prot_t vmprot, max_vmprot;\n  memory_object_t memobj;\n  vm_address_t mapaddr, mask;\n  boolean_t copy, anywhere;\n\n  mapaddr = (vm_address_t) addr;\n\n  /* ADDR and OFFSET must be page-aligned.  */\n  if ((mapaddr & (__vm_page_size - 1)) || (offset & (__vm_page_size - 1)))\n    return (void *) (long int) __hurd_fail (EINVAL);\n\n  if ((flags & MAP_EXCL) && ! (flags & MAP_FIXED))\n    return (void *) (long int) __hurd_fail (EINVAL);\n\n  vmprot = VM_PROT_NONE;\n  if (prot & PROT_READ)\n    vmprot |= VM_PROT_READ;\n  if (prot & PROT_WRITE)\n    vmprot |= VM_PROT_WRITE;\n  if (prot & PROT_EXEC)\n    vmprot |= VM_PROT_EXECUTE;\n\n  copy = ! (flags & MAP_SHARED);\n  anywhere = ! (flags & MAP_FIXED);\n\n#ifdef __LP64__\n  if ((addr == NULL) && (prot & PROT_EXEC)\n      && HAS_ARCH_FEATURE (Prefer_MAP_32BIT_EXEC))\n    flags |= MAP_32BIT;\n#endif\n  mask = (flags & MAP_32BIT) ? ~(vm_address_t) 0x7FFFFFFF : 0;\n\n  switch (flags & MAP_TYPE)\n    {\n    default:\n      return (void *) (long int) __hurd_fail (EINVAL);\n\n    case MAP_ANON:\n      memobj = MACH_PORT_NULL;\n      max_vmprot = VM_PROT_ALL;\n      break;\n\n    case MAP_FILE:\n    case 0:\t\t\t/* Allow, e.g., just MAP_SHARED.  */\n      {\n\tmach_port_t robj, wobj;\n\tif (err = HURD_DPORT_USE (fd, __io_map (port, &robj, &wobj)))\n\t  {\n\t    if (err == MIG_BAD_ID || err == EOPNOTSUPP || err == ENOSYS)\n\t      err = ENODEV;\t/* File descriptor doesn't support mmap.  */\n\t    return (void *) (long int) __hurd_dfail (fd, err);\n\t  }\n\tswitch (prot & (PROT_READ|PROT_WRITE))\n\t  {\n\t  /* Although it apparently doesn't make sense to map a file with\n\t     protection set to PROT_NONE, it is actually sometimes done.\n\t     In particular, that's how localedef reserves some space for\n\t     the locale archive file, the rationale being that some\n\t     implementations take into account whether the mapping is\n\t     anonymous or not when selecting addresses.  */\n\t  case PROT_NONE:\n\t  case PROT_READ:\n            max_vmprot = VM_PROT_READ|VM_PROT_EXECUTE;\n            if (wobj == robj)\n              max_vmprot |= VM_PROT_WRITE;\n\t    memobj = robj;\n\t    if (MACH_PORT_VALID (wobj))\n\t      __mach_port_deallocate (__mach_task_self (), wobj);\n\t    break;\n\t  case PROT_WRITE:\n            max_vmprot = VM_PROT_WRITE;\n            if (robj == wobj)\n              max_vmprot |= VM_PROT_READ|VM_PROT_EXECUTE;\n\t    memobj = wobj;\n\t    if (MACH_PORT_VALID (robj))\n\t      __mach_port_deallocate (__mach_task_self (), robj);\n\t    break;\n\t  case PROT_READ|PROT_WRITE:\n            max_vmprot = VM_PROT_ALL;\n\t    if (robj == wobj)\n\t      {\n\t\tmemobj = wobj;\n\t\t/* Remove extra reference.  */\n\t\t__mach_port_deallocate (__mach_task_self (), memobj);\n\t      }\n\t    else if (wobj == MACH_PORT_NULL /* Not writable by mapping.  */\n\t\t     && copy)\n\t      /* The file can only be mapped for reading.  Since we are\n\t\t making a private mapping, we will never try to write the\n\t\t object anyway, so we don't care.  */\n\t      memobj = robj;\n\t    else\n\t      {\n\t\t__mach_port_deallocate (__mach_task_self (), wobj);\n\t\treturn (void *) (long int) __hurd_fail (EACCES);\n\t      }\n\t    break;\n\t  default:\n\t    __builtin_unreachable ();\n\t  }\n\tbreak;\n\t/* XXX handle MAP_NOEXTEND */\n      }\n    }\n\n  /* XXX handle MAP_INHERIT */\n\n  if (copy)\n    max_vmprot = VM_PROT_ALL;\n\n  /* When ANYWHERE is true but the caller has provided a preferred address,\n     try mapping at that address with anywhere = 0 first.  If this fails,\n     we'll retry with anywhere = 1 below.  */\n  err = __vm_map (__mach_task_self (),\n\t\t  &mapaddr, (vm_size_t) len, mask,\n\t\t  anywhere && (mapaddr == 0),\n\t\t  memobj, (vm_offset_t) offset,\n\t\t  copy, vmprot, max_vmprot,\n\t\t  copy ? VM_INHERIT_COPY : VM_INHERIT_SHARE);\n\n  if (flags & MAP_FIXED)\n    {\n      if (err == KERN_NO_SPACE)\n\t{\n\t  if (flags & MAP_EXCL)\n\t    err = EEXIST;\n\t  else\n\t    {\n\t      /* The region is already allocated; deallocate it first.  */\n\t      /* XXX this is not atomic as it is in unix! */\n\t      err = __vm_deallocate (__mach_task_self (), mapaddr, len);\n\t      if (! err)\n\t\terr = __vm_map (__mach_task_self (),\n\t\t\t\t&mapaddr, (vm_size_t) len, mask,\n\t\t\t\t0, memobj, (vm_offset_t) offset,\n\t\t\t\tcopy, vmprot, max_vmprot,\n\t\t\t\tcopy ? VM_INHERIT_COPY : VM_INHERIT_SHARE);\n\t    }\n\t}\n    }\n  else\n    {\n      /* This mmap call is allowed to allocate anywhere,  */\n      if (mapaddr != 0 && (err == KERN_NO_SPACE || err == KERN_INVALID_ADDRESS))\n        /* ...but above, we tried allocating at the specific address,\n           and failed to.  Now try again, with anywhere = 1 this time.  */\n\terr = __vm_map (__mach_task_self (),\n\t\t\t&mapaddr, (vm_size_t) len, mask,\n\t\t\t1, memobj, (vm_offset_t) offset,\n\t\t\tcopy, vmprot, max_vmprot,\n\t\t\tcopy ? VM_INHERIT_COPY : VM_INHERIT_SHARE);\n    }\n\n  if (MACH_PORT_VALID (memobj))\n    __mach_port_deallocate (__mach_task_self (), memobj);\n\n  if (err == KERN_PROTECTION_FAILURE)\n    err = EACCES;\n\n  if (err)\n    return (void *) (long int) __hurd_fail (err);\n\n  return (void *) mapaddr;\n}",
    "getmntent(FILE *)": "struct mntent *\ngetmntent (FILE *stream)\n{\n  struct mntent_buffer *buffer = allocate_once (&mntent_buffer,\n\t\t\t\t\t\tallocate, deallocate, NULL);\n  if (buffer == NULL)\n    /* If no core is available we don't have a chance to run the\n       program successfully and so returning NULL is an acceptable\n       result.  */\n    return NULL;\n\n  return __getmntent_r (stream, &buffer->m,\n\t\t\tbuffer->buffer, sizeof (buffer->buffer));\n}",
    "__setmntent(const char *, const char *)": "FILE *\n__setmntent (const char *file, const char *mode)\n{\n  /* Extend the mode parameter with \"c\" to disable cancellation in the\n     I/O functions and \"e\" to set FD_CLOEXEC.  */\n  size_t modelen = strlen (mode);\n  char newmode[modelen + 3];\n  memcpy (mempcpy (newmode, mode, modelen), \"ce\", 3);\n  FILE *result = fopen (file, newmode);\n\n  if (result != NULL)\n    /* We do the locking ourselves.  */\n    __fsetlocking (result, FSETLOCKING_BYCALLER);\n\n  return result;\n}",
    "__mprotect(void *, int, int)": "int\n__mprotect (void *addr, size_t len, int prot)\n{\n  kern_return_t err;\n  vm_prot_t vmprot;\n\n  vmprot = VM_PROT_NONE;\n  if (prot & PROT_READ)\n    vmprot |= VM_PROT_READ;\n  if (prot & PROT_WRITE)\n    vmprot |= VM_PROT_WRITE;\n  if (prot & PROT_EXEC)\n    vmprot |= VM_PROT_EXECUTE;\n\n  if (err = __vm_protect (__mach_task_self (),\n\t\t\t  (vm_address_t) addr, (vm_size_t) len,\n\t\t\t  0, vmprot))\n    {\n      errno = err;\n      return -1;\n    }\n  return 0;\n}",
    "msync(void *, int, int)": "int\nmsync (void *addr, size_t length, int flags)\n{\n  boolean_t should_flush = flags & MS_INVALIDATE ? 1 : 0;\n  boolean_t should_iosync = flags & MS_ASYNC ? 0 : 1;\n\n  vm_address_t cur = (vm_address_t) addr;\n  vm_address_t target = cur + length;\n\n  vm_size_t len;\n  vm_prot_t prot;\n  vm_prot_t max_prot;\n  vm_inherit_t inherit;\n  boolean_t shared;\n  memory_object_name_t obj;\n  vm_offset_t offset;\n\n  kern_return_t err;\n  int cancel_oldtype;\n\n  while (cur < target)\n    {\n      vm_address_t begin = cur;\n\n      err = __vm_region (__mach_task_self (),\n\t\t\t &begin, &len, &prot, &max_prot, &inherit,\n\t\t\t &shared, &obj, &offset);\n\n      if (err != KERN_SUCCESS)\n\treturn __hurd_fail (err);\n\n      if (begin > cur)\n\t/* We were given an address before the first region,\n\t   or we found a hole.  */\n\tcur = begin;\n\n      if (cur >= target)\n\t/* We were given an ending address within a hole. */\n\tbreak;\n\n      if (MACH_PORT_VALID (obj))\n\t{\n\t  vm_size_t sync_len;\n\n\t  if (begin + len > target)\n\t    sync_len = target - begin;\n\t  else\n\t    sync_len = len;\n\n\t  cancel_oldtype = LIBC_CANCEL_ASYNC();\n\t  err = __vm_object_sync (obj, cur - begin + offset, sync_len,\n\t\t\t\t  should_flush, 1, should_iosync);\n\t  LIBC_CANCEL_RESET (cancel_oldtype);\n\t  __mach_port_deallocate (__mach_task_self (), obj);\n\n\t  if (err)\n\t    return __hurd_fail (err);\n\n\t}\n\n      cur = begin + len;\n    }\n\n  return 0;\n}",
    "munlock(const void *, int)": "int\nmunlock (const void *addr, size_t len)\n{\n  mach_port_t host;\n  vm_address_t page;\n  error_t err;\n\n  err = __get_privileged_ports (&host, NULL);\n  if (err)\n    host = __mach_host_self();\n\n  page = trunc_page ((vm_address_t) addr);\n  len = round_page ((vm_address_t) addr + len) - page;\n\n  err = __vm_wire (host, __mach_task_self (), page, len, VM_PROT_NONE);\n  if (host != __mach_host_self())\n    __mach_port_deallocate (__mach_task_self (), host);\n\n  return err ? __hurd_fail (err) : 0;\n}",
    "munlockall()": "int\nmunlockall (void)\n{\n  mach_port_t host;\n  error_t err;\n\n  err = __get_privileged_ports (&host, NULL);\n  if (err)\n    return __hurd_fail (err);\n\n  err = __vm_wire_all (host, __mach_task_self (), VM_WIRE_NONE);\n  __mach_port_deallocate (__mach_task_self (), host);\n  return err ? __hurd_fail (err) : 0;\n}",
    "__munmap(void *, int)": "int\n__munmap (void *addr, size_t len)\n{\n  kern_return_t err;\n\n  if (addr == 0)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  if (err = __vm_deallocate (__mach_task_self (),\n\t\t\t     (vm_address_t) addr, (vm_size_t) len))\n    {\n      errno = err;\n      return -1;\n    }\n  return 0;\n}",
    "preadv(int, const struct iovec *, int, off_t)": "ssize_t\npreadv (int fd, const struct iovec *vector, int count, off_t offset)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "preadv2(int, const struct iovec *, int, off_t, int)": "ssize_t\npreadv2 (int fd, const struct iovec *vector, int count, off_t offset,\n\t int flags)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "preadv64(int, const struct iovec *, int, int)": "ssize_t\npreadv64 (int fd, const struct iovec *vector, int count, off64_t offset)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "preadv64v2(int, const struct iovec *, int, int, int)": "ssize_t\npreadv64v2 (int fd, const struct iovec *vector, int count, off64_t offset,\n\t    int flags)\n{\n  if (flags != 0)\n    {\n      __set_errno (ENOTSUP);\n      return -1;\n    }\n\n  if (offset == -1)\n    return __readv (fd, vector, count);\n  else\n    return preadv64 (fd, vector, count, offset);\n}",
    "ptrace(enum __ptrace_request, ...)": "long int\nptrace (enum __ptrace_request request, ...)\n{\n  long int res, ret;\n  va_list ap;\n  pid_t pid;\n  void *addr, *data;\n\n  va_start (ap, request);\n  pid = va_arg (ap, pid_t);\n  addr = va_arg (ap, void *);\n  data = va_arg (ap, void *);\n  va_end (ap);\n\n  if (request > 0 && request < 4)\n    data = &ret;\n\n  res = INLINE_SYSCALL (ptrace, 4, request, pid, addr, data);\n  if (res >= 0 && request > 0 && request < 4)\n    {\n      __set_errno (0);\n      return ret;\n    }\n\n  return res;\n}",
    "pwritev(int, const struct iovec *, int, off_t)": "ssize_t\npwritev (int fd, const struct iovec *vector, int count, off_t offset)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "pwritev2(int, const struct iovec *, int, off_t, int)": "ssize_t\npwritev2 (int fd, const struct iovec *vector, int count, off_t offset,\n\t  int flags)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "pwritev64(int, const struct iovec *, int, int)": "ssize_t\npwritev64 (int fd, const struct iovec *vector, int count, off64_t offset)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "pwritev64v2(int, const struct iovec *, int, int, int)": "ssize_t\npwritev64v2 (int fd, const struct iovec *vector, int count, off64_t offset,\n\t     int flags)\n{\n  if (flags != 0)\n    {\n      __set_errno (ENOTSUP);\n      return -1;\n    }\n\n  if (offset == -1)\n    return __writev (fd, vector, count);\n  else\n    return pwritev64 (fd, vector, count, offset);\n}",
    "reboot(int)": "int\nreboot (int howto)\n{\n  return INLINE_SYSCALL (reboot, 3, (int) 0xfee1dead, 672274793, howto);\n}",
    "removexattr(const char *, const char *)": "int\nremovexattr (const char *path, const char *name)\n{\n  error_t err;\n  file_t port = __file_name_lookup (path, 0, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = _hurd_xattr_remove (port, name);\n  __mach_port_deallocate (__mach_task_self (), port);\n  return __hurd_fail (err);\n}",
    "__sbrk(intptr_t)": "void *\n__sbrk (intptr_t increment)\n{\n  void *result;\n\n  HURD_CRITICAL_BEGIN;\n  __mutex_lock (&_hurd_brk_lock);\n  result = (void *) _hurd_brk;\n  if (increment != 0 && _hurd_set_brk (_hurd_brk + increment) < 0)\n    result = (void *) -1;\n  __mutex_unlock (&_hurd_brk_lock);\n  HURD_CRITICAL_END;\n\n  return result;\n}",
    "__select(int, fd_set *, fd_set *, fd_set *, struct timeval *)": "int\n__select (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,\n\t  struct timeval *timeout)\n{\n  struct timespec ts, *to;\n\n  if (timeout)\n    {\n      to = &ts;\n      TIMEVAL_TO_TIMESPEC (timeout, to);\n    }\n  else\n    to = NULL;\n\n  return _hurd_select (nfds, NULL, readfds, writefds, exceptfds, to, NULL);\n}",
    "setdomainname(const char *, int)": "int\nsetdomainname (const char *name, size_t len)\n{\n  /* The NIS domain name is just the contents of the file /etc/nisdomain.  */\n  ssize_t n = _hurd_set_host_config (\"/etc/nisdomain\", name, len);\n  return n < 0 ? -1 : 0;\n}",
    "setegid(__gid_t)": "int\nsetegid (__gid_t gid)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "seteuid(__uid_t)": "int\nseteuid (__uid_t uid)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "sethostid(long)": "int\nsethostid (long int id)\n{\n  int fd;\n  ssize_t written;\n  int32_t id32 = id;\n\n  /* Test for appropriate rights to set host ID.  */\n  if (__libc_enable_secure)\n    {\n      __set_errno (EPERM);\n      return -1;\n    }\n\n  /* Make sure the ID is not too large.  Needed for bi-arch support.   */\n  if (id32 != id)\n    {\n      __set_errno (EOVERFLOW);\n      return -1;\n    }\n\n  /* Open file for writing.  Everybody is allowed to read this file.  */\n  fd = __open_nocancel (HOSTIDFILE, O_CREAT|O_WRONLY|O_TRUNC, 0644);\n  if (fd < 0)\n    return -1;\n\n  written = __write_nocancel (fd, &id32, sizeof (id32));\n\n  __close_nocancel_nostatus (fd);\n\n  return written != sizeof (id32) ? -1 : 0;\n}",
    "sethostname(const char *, int)": "int\nsethostname (const char *name, size_t len)\n{\n  /* The host name is just the contents of the file /etc/hostname.  */\n  ssize_t n = _hurd_set_host_config (\"/etc/hostname\", name, len);\n  return n < 0 ? -1 : 0;\n}",
    "setxattr(const char *, const char *, const void *, int, int)": "int\nsetxattr (const char *path, const char *name, const void *value, size_t size,\n\t  int flags)\n{\n  error_t err;\n  file_t port = __file_name_lookup (path, 0, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = _hurd_xattr_set (port, name, value, size, flags);\n  __mach_port_deallocate (__mach_task_self (), port);\n  return __hurd_fail (err);\n}",
    "stty(int, const struct sgttyb *)": "int\nstty (int fd, const struct sgttyb *params)\n{\n  return __ioctl (fd, TIOCSETP, (void *) params);\n}",
    "swapoff(const char *)": "int\nswapoff (const char *path)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "swapon(const char *, int)": "int\nswapon (const char *path, int flags)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "sync()": "void\nsync (void)\n{\n  /* This is not actually synchronous; we don't wait.  */\n  error_t err = __USEPORT (CRDIR, __file_syncfs (port, 0, 1));\n  if (err)\n    (void) __hurd_fail (err);\n}",
    "syncfs(int)": "int\nsyncfs (int fd)\n{\n  error_t err = HURD_DPORT_USE (fd, __file_syncfs (port, 1, 0));\n  if (err)\n    return __hurd_dfail (fd, err);\n  return 0;\n}",
    "syscall(long, ...)": "long int\nsyscall (long int number, ...)\n{\n  va_list args;\n\n  va_start (args, number);\n  long int a0 = va_arg (args, long int);\n  long int a1 = va_arg (args, long int);\n  long int a2 = va_arg (args, long int);\n  long int a3 = va_arg (args, long int);\n  long int a4 = va_arg (args, long int);\n  long int a5 = va_arg (args, long int);\n  va_end (args);\n\n  long int r = INTERNAL_SYSCALL_NCS_CALL (number, a0, a1, a2, a3, a4, a5);\n  if (__glibc_unlikely (INTERNAL_SYSCALL_ERROR_P (r)))\n    {\n      __set_errno (-r);\n      return -1;\n    }\n  return r;\n}",
    "openlog(const char *, int, int)": "void\nopenlog (const char *ident, int logstat, int logfac)\n{\n  /* Protect against multiple users and cancellation.  */\n  __libc_cleanup_push (cancel_handler, NULL);\n  __libc_lock_lock (syslog_lock);\n\n  openlog_internal (ident, logstat, logfac);\n\n  __libc_cleanup_pop (1);\n}",
    "closelog()": "void\ncloselog (void)\n{\n  /* Protect against multiple users and cancellation.  */\n  __libc_cleanup_push (cancel_handler, NULL);\n  __libc_lock_lock (syslog_lock);\n\n  closelog_internal ();\n  LogTag = NULL;\n  LogType = SOCK_DGRAM; /* this is the default */\n\n  /* Free the lock.  */\n  __libc_cleanup_pop (1);\n}",
    "setlogmask(int)": "int\nsetlogmask (int pmask)\n{\n  int omask;\n\n  /* Protect against multiple users.  */\n  __libc_lock_lock (syslog_lock);\n\n  omask = LogMask;\n  if (pmask != 0)\n    LogMask = pmask;\n\n  __libc_lock_unlock (syslog_lock);\n\n  return (omask);\n}",
    "truncate64(const char *, int)": "int\ntruncate64 (const char *path, off64_t length)\n{\n  if ((off_t) length != length)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  return __truncate (path, (off_t) length);\n}",
    "__tsearch(const void *, void **, __compar_fn_t)": "void *\n__tsearch (const void *key, void **vrootp, __compar_fn_t compar)\n{\n  node q, root;\n  node *parentp = NULL, *gparentp = NULL;\n  node *rootp = (node *) vrootp;\n  node *nextp;\n  int r = 0, p_r = 0, gp_r = 0; /* No they might not, Mr Compiler.  */\n\n#ifdef USE_MALLOC_LOW_BIT\n  static_assert (alignof (max_align_t) > 1, \"malloc must return aligned ptrs\");\n#endif\n\n  if (rootp == NULL)\n    return NULL;\n\n  /* This saves some additional tests below.  */\n  root = DEREFNODEPTR(rootp);\n  if (root != NULL)\n    SETBLACK(root);\n\n  CHECK_TREE (root);\n\n  nextp = rootp;\n  while (DEREFNODEPTR(nextp) != NULL)\n    {\n      root = DEREFNODEPTR(rootp);\n      r = (*compar) (key, root->key);\n      if (r == 0)\n\treturn root;\n\n      maybe_split_for_insert (rootp, parentp, gparentp, p_r, gp_r, 0);\n      /* If that did any rotations, parentp and gparentp are now garbage.\n\t That doesn't matter, because the values they contain are never\n\t used again in that case.  */\n\n      nextp = r < 0 ? LEFTPTR(root) : RIGHTPTR(root);\n      if (DEREFNODEPTR(nextp) == NULL)\n\tbreak;\n\n      gparentp = parentp;\n      parentp = rootp;\n      rootp = nextp;\n\n      gp_r = p_r;\n      p_r = r;\n    }\n\n  q = (struct node_t *) malloc (sizeof (struct node_t));\n  if (q != NULL)\n    {\n      /* Make sure the malloc implementation returns naturally aligned\n\t memory blocks when expected.  Or at least even pointers, so we\n\t can use the low bit as red/black flag.  Even though we have a\n\t static_assert to make sure alignof (max_align_t) > 1 there could\n\t be an interposed malloc implementation that might cause havoc by\n\t not obeying the malloc contract.  */\n#ifdef USE_MALLOC_LOW_BIT\n      assert (((uintptr_t) q & (uintptr_t) 0x1) == 0);\n#endif\n      SETNODEPTR(nextp,q);\t\t/* link new node to old */\n      q->key = key;\t\t\t/* initialize new node */\n      SETRED(q);\n      SETLEFT(q,NULL);\n      SETRIGHT(q,NULL);\n\n      if (nextp != rootp)\n\t/* There may be two red edges in a row now, which we must avoid by\n\t   rotating the tree.  */\n\tmaybe_split_for_insert (nextp, rootp, parentp, r, p_r, 1);\n    }\n\n  return q;\n}",
    "ttyslot()": "int\nttyslot (void)\n{\n\tstruct ttyent *ttyp;\n\tint slot;\n\tchar *p;\n\tint cnt;\n\tsize_t buflen = __sysconf (_SC_TTY_NAME_MAX) + 1;\n\tchar *name;\n\n\tif (buflen == 0)\n\t  /* This should be enough if no fixed value is given.  */\n\t  buflen = 32;\n\n\tname = __alloca (buflen);\n\n\t__setttyent();\n\tfor (cnt = 0; cnt < 3; ++cnt)\n\t\tif (__ttyname_r (cnt, name, buflen) == 0) {\n\t\t\tif ((p = strrchr (name, '/')))\n\t\t\t\t++p;\n\t\t\telse\n\t\t\t\tp = name;\n\t\t\tfor (slot = 1; (ttyp = __getttyent()); ++slot)\n\t\t\t\tif (!strcmp(ttyp->ty_name, p)) {\n\t\t\t\t\t__endttyent();\n\t\t\t\t\treturn(slot);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t__endttyent();\n\treturn(0);\n}",
    "ualarm(useconds_t, useconds_t)": "useconds_t\nualarm (useconds_t value, useconds_t interval)\n{\n  struct itimerval timer, otimer;\n\n  timer.it_value.tv_sec = 0;\n  timer.it_value.tv_usec = value;\n  timer.it_interval.tv_sec = 0;\n  timer.it_interval.tv_usec = interval;\n\n  if (__setitimer (ITIMER_REAL, &timer, &otimer) < 0)\n    return -1;\n\n  return (otimer.it_value.tv_sec * 1000000) + otimer.it_value.tv_usec;\n}",
    "usleep(useconds_t)": "int\nusleep (useconds_t useconds)\n{\n  struct timespec ts = { .tv_sec = (long int) (useconds / 1000000),\n\t\t\t .tv_nsec = (long int) (useconds % 1000000) * 1000ul };\n\n  /* Note the usleep() is a cancellation point.  But since we call\n     nanosleep() which itself is a cancellation point we do not have\n     to do anything here.  */\n  return __nanosleep (&ts, NULL);\n}",
    "vhangup()": "int\nvhangup (void)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__nptl_create_event()": "void\n__nptl_create_event (void)\n{\n}",
    "__lll_lock_wait_private(int *)": "void\n__lll_lock_wait_private (int *futex)\n{\n  if (atomic_load_relaxed (futex) == 2)\n    goto futex;\n\n  while (atomic_exchange_acquire (futex, 2) != 0)\n    {\n    futex:\n      LIBC_PROBE (lll_lock_wait_private, 1, futex);\n      futex_wait ((unsigned int *) futex, 2, LLL_PRIVATE); /* Wait if *futex == 2.  */\n    }\n}",
    "clock_getcpuclockid(pid_t, clockid_t *)": "int\nclock_getcpuclockid (pid_t pid, clockid_t *clock_id)\n{\n  /* We don't allow any process ID but our own.  */\n  if (pid != 0 && pid != getpid ())\n    return EPERM;\n\n#ifdef CLOCK_PROCESS_CPUTIME_ID\n  /* Store the number.  */\n  *clock_id = CLOCK_PROCESS_CPUTIME_ID;\n\n  return 0;\n#else\n  /* We don't have a timer for that.  */\n  return ENOENT;\n#endif\n}",
    "clock_gettime(clockid_t, struct timespec *)": "int\nclock_gettime (clockid_t clock_id, struct timespec *tp)\n{\n  int retval = -1;\n\n  switch (clock_id)\n    {\n    case CLOCK_PROCESS_CPUTIME_ID:\n      {\n\n\tstatic hp_timing_t freq;\n\thp_timing_t tsc;\n\n\t/* Get the current counter.  */\n\tHP_TIMING_NOW (tsc);\n\n\tif (freq == 0)\n\t  {\n\t    freq = get_clockfreq ();\n\t    if (freq == 0)\n\t      return EINVAL;\n\t  }\n\n\t/* Compute the seconds.  */\n\ttp->tv_sec = tsc / freq;\n\n\t/* And the nanoseconds.  This computation should be stable until\n\t   we get machines with about 16GHz frequency.  */\n\ttp->tv_nsec = ((tsc % freq) * UINT64_C (1000000000)) / freq;\n\n\tretval = 0;\n      }\n    break;\n\n    default:\n      errno = EINVAL;\n      break;\n    }\n\n  return retval;\n}",
    "pthread_attr_setsigmask_np(int *, const int *)": "int\npthread_attr_setsigmask_np (pthread_attr_t *attr, const sigset_t *sigmask)\n{\n  int ret = __pthread_attr_setsigmask_internal (attr, sigmask);\n  if (ret != 0)\n    return ret;\n\n  /* Filter out internal signals.  */\n  struct pthread_attr *iattr = (struct pthread_attr *) attr;\n  clear_internal_signals (&iattr->extension->sigmask);\n\n  return 0;\n}",
    "thrd_current()": "thrd_t\nthrd_current (void)\n{\n  if (GL (dl_pthread_threads))\n    return (thrd_t) __pthread_self ();\n\n  return (thrd_t) 0;\n}",
    "thrd_yield()": "void\nthrd_yield (void)\n{\n  (void) __swtch ();\n}",
    "fgetgrent(FILE *)": "struct group *\nfgetgrent (FILE *stream)\n{\n  static size_t buffer_size;\n  static struct group resbuf;\n  fpos_t pos;\n  struct group *result;\n  int save;\n\n  if (__builtin_expect (fgetpos (stream, &pos), 0) != 0)\n    return NULL;\n\n  /* Get lock.  */\n  __libc_lock_lock (lock);\n\n  /* Allocate buffer if not yet available.  */\n  if (buffer == NULL)\n    {\n      buffer_size = NSS_BUFLEN_GROUP;\n      buffer = malloc (buffer_size);\n    }\n\n  while (buffer != NULL\n\t && (__fgetgrent_r (stream, &resbuf, buffer, buffer_size, &result)\n\t     == ERANGE))\n    {\n      char *new_buf;\n      buffer_size += NSS_BUFLEN_GROUP;\n      new_buf = realloc (buffer, buffer_size);\n      if (__glibc_unlikely (new_buf == NULL))\n\t{\n\t  /* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */\n\t  save = errno;\n\t  free (buffer);\n\t  __set_errno (save);\n\t}\n      buffer = new_buf;\n\n      /* Reset the stream.  */\n      if (fsetpos (stream, &pos) != 0)\n\tbuffer = NULL;\n    }\n\n  if (buffer == NULL)\n    result = NULL;\n\n  /* Release lock.  Preserve error value.  */\n  save = errno;\n  __libc_lock_unlock (lock);\n  __set_errno (save);\n\n  return result;\n}",
    "fgetpwent(FILE *)": "struct passwd *\nfgetpwent (FILE *stream)\n{\n  static size_t buffer_size;\n  static struct passwd resbuf;\n  fpos_t pos;\n  struct passwd *result;\n  int save;\n\n  if (fgetpos (stream, &pos) != 0)\n    return NULL;\n\n  /* Get lock.  */\n  __libc_lock_lock (lock);\n\n  /* Allocate buffer if not yet available.  */\n  if (buffer == NULL)\n    {\n      buffer_size = NSS_BUFLEN_PASSWD;\n      buffer = malloc (buffer_size);\n    }\n\n  while (buffer != NULL\n\t && (__fgetpwent_r (stream, &resbuf, buffer, buffer_size, &result)\n\t     == ERANGE))\n    {\n      char *new_buf;\n      buffer_size += NSS_BUFLEN_PASSWD;\n      new_buf = realloc (buffer, buffer_size);\n      if (new_buf == NULL)\n\t{\n\t  /* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */\n\t  save = errno;\n\t  free (buffer);\n\t  __set_errno (save);\n\t}\n      buffer = new_buf;\n\n      /* Reset the stream.  */\n      if (fsetpos (stream, &pos) != 0)\n\tbuffer = NULL;\n    }\n\n  if (buffer == NULL)\n    result = NULL;\n\n  /* Release lock.  Preserve error value.  */\n  save = errno;\n  __libc_lock_unlock (lock);\n  __set_errno (save);\n\n  return result;\n}",
    "fgetsgent(FILE *)": "struct sgrp *\nfgetsgent (FILE *stream)\n{\n  static size_t buffer_size;\n  static struct sgrp resbuf;\n  fpos_t pos;\n  struct sgrp *result;\n  int save;\n\n  if (fgetpos (stream, &pos) != 0)\n    return NULL;\n\n  /* Get lock.  */\n  __libc_lock_lock (lock);\n\n  /* Allocate buffer if not yet available.  */\n  if (buffer == NULL)\n    {\n      buffer_size = BUFLEN_SPWD;\n      buffer = malloc (buffer_size);\n    }\n\n  while (buffer != NULL\n\t && (__fgetsgent_r (stream, &resbuf, buffer, buffer_size, &result)\n\t     == ERANGE))\n    {\n      char *new_buf;\n      buffer_size += BUFLEN_SPWD;\n      new_buf = realloc (buffer, buffer_size);\n      if (new_buf == NULL)\n\t{\n\t  /* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */\n\t  save = errno;\n\t  free (buffer);\n\t  __set_errno (save);\n\t}\n      buffer = new_buf;\n\n      /* Reset the stream.  */\n      if (fsetpos (stream, &pos) != 0)\n\tbuffer = NULL;\n    }\n\n  if (buffer == NULL)\n    result = NULL;\n\n  /* Release lock.  Preserve error value.  */\n  save = errno;\n  __libc_lock_unlock (lock);\n  __set_errno (save);\n\n  return result;\n}",
    "fgetspent(FILE *)": "struct spwd *\nfgetspent (FILE *stream)\n{\n  static size_t buffer_size;\n  static struct spwd resbuf;\n  fpos_t pos;\n  struct spwd *result;\n  int save;\n\n  if (fgetpos (stream, &pos) != 0)\n    return NULL;\n\n  /* Get lock.  */\n  __libc_lock_lock (lock);\n\n  /* Allocate buffer if not yet available.  */\n  if (buffer == NULL)\n    {\n      buffer_size = BUFLEN_SPWD;\n      buffer = malloc (buffer_size);\n    }\n\n  while (buffer != NULL\n\t && (__fgetspent_r (stream, &resbuf, buffer, buffer_size, &result)\n\t     == ERANGE))\n    {\n      char *new_buf;\n      buffer_size += BUFLEN_SPWD;\n      new_buf = realloc (buffer, buffer_size);\n      if (new_buf == NULL)\n\t{\n\t  /* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */\n\t  save = errno;\n\t  free (buffer);\n\t  __set_errno (save);\n\t}\n      buffer = new_buf;\n\n      /* Reset the stream.  */\n      if (fsetpos (stream, &pos) != 0)\n\tbuffer = NULL;\n    }\n\n  if (buffer == NULL)\n    result = NULL;\n\n  /* Release lock.  Preserve error value.  */\n  save = errno;\n  __libc_lock_unlock (lock);\n  __set_errno (save);\n\n  return result;\n}",
    "getaddrinfo(const char *, const char *, const struct addrinfo *, struct addrinfo **)": "int\ngetaddrinfo (const char *name, const char *service,\n\t     const struct addrinfo *hints, struct addrinfo **pai)\n{\n  int i = 0, last_i = 0;\n  int nresults = 0;\n  struct addrinfo *p = NULL;\n  struct gaih_service gaih_service, *pservice;\n  struct addrinfo local_hints;\n\n  if (name != NULL && name[0] == '*' && name[1] == 0)\n    name = NULL;\n\n  if (service != NULL && service[0] == '*' && service[1] == 0)\n    service = NULL;\n\n  if (name == NULL && service == NULL)\n    return EAI_NONAME;\n\n  if (hints == NULL)\n    hints = &default_hints;\n\n  if (hints->ai_flags\n      & ~(AI_PASSIVE|AI_CANONNAME|AI_NUMERICHOST|AI_ADDRCONFIG|AI_V4MAPPED\n\t  |AI_IDN|AI_CANONIDN|DEPRECATED_AI_IDN\n\t  |AI_NUMERICSERV|AI_ALL))\n    return EAI_BADFLAGS;\n\n  if ((hints->ai_flags & AI_CANONNAME) && name == NULL)\n    return EAI_BADFLAGS;\n\n  if (hints->ai_family != AF_UNSPEC && hints->ai_family != AF_INET\n      && hints->ai_family != AF_INET6)\n    return EAI_FAMILY;\n\n  struct in6addrinfo *in6ai = NULL;\n  size_t in6ailen = 0;\n  bool seen_ipv4 = false;\n  bool seen_ipv6 = false;\n  bool check_pf_called = false;\n\n  if (hints->ai_flags & AI_ADDRCONFIG)\n    {\n      /* We might need information about what interfaces are available.\n\t Also determine whether we have IPv4 or IPv6 interfaces or both.  We\n\t cannot cache the results since new interfaces could be added at\n\t any time.  */\n      __check_pf (&seen_ipv4, &seen_ipv6, &in6ai, &in6ailen);\n      check_pf_called = true;\n\n      /* Now make a decision on what we return, if anything.  */\n      if (hints->ai_family == PF_UNSPEC && (seen_ipv4 || seen_ipv6))\n\t{\n\t  /* If we haven't seen both IPv4 and IPv6 interfaces we can\n\t     narrow down the search.  */\n\t  if (seen_ipv4 != seen_ipv6)\n\t    {\n\t      local_hints = *hints;\n\t      local_hints.ai_family = seen_ipv4 ? PF_INET : PF_INET6;\n\t      hints = &local_hints;\n\t    }\n\t}\n      else if ((hints->ai_family == PF_INET && ! seen_ipv4)\n\t       || (hints->ai_family == PF_INET6 && ! seen_ipv6))\n\t{\n\t  /* We cannot possibly return a valid answer.  */\n\t  __free_in6ai (in6ai);\n\t  return EAI_NONAME;\n\t}\n    }\n\n  if (service && service[0])\n    {\n      char *c;\n      gaih_service.name = service;\n      gaih_service.num = strtoul (gaih_service.name, &c, 10);\n      if (*c != '\\0')\n\t{\n\t  if (hints->ai_flags & AI_NUMERICSERV)\n\t    {\n\t      __free_in6ai (in6ai);\n\t      return EAI_NONAME;\n\t    }\n\n\t  gaih_service.num = -1;\n\t}\n\n      pservice = &gaih_service;\n    }\n  else\n    pservice = NULL;\n\n  struct addrinfo **end = &p;\n  unsigned int naddrs = 0;\n  struct scratch_buffer tmpbuf;\n\n  scratch_buffer_init (&tmpbuf);\n  last_i = gaih_inet (name, pservice, hints, end, &naddrs, &tmpbuf);\n  scratch_buffer_free (&tmpbuf);\n\n  if (last_i != 0)\n    {\n      freeaddrinfo (p);\n      __free_in6ai (in6ai);\n\n      return -last_i;\n    }\n\n  while (*end)\n    {\n      end = &((*end)->ai_next);\n      ++nresults;\n    }\n\n  if (naddrs > 1)\n    {\n      /* Read the config file.  */\n      __libc_once_define (static, once);\n      __typeof (once) old_once = once;\n      __libc_once (once, gaiconf_init);\n      /* Sort results according to RFC 3484.  */\n      struct sort_result *results;\n      size_t *order;\n      struct addrinfo *q;\n      struct addrinfo *last = NULL;\n      char *canonname = NULL;\n      struct scratch_buffer buf;\n      scratch_buffer_init (&buf);\n\n      if (!scratch_buffer_set_array_size (&buf, nresults,\n\t\t\t\t\t  sizeof (*results) + sizeof (size_t)))\n\t{\n\t  __free_in6ai (in6ai);\n\t  return EAI_MEMORY;\n\t}\n      results = buf.data;\n\n      order = (size_t *) (results + nresults);\n\n      /* Now we definitely need the interface information.  */\n      if (! check_pf_called)\n\t__check_pf (&seen_ipv4, &seen_ipv6, &in6ai, &in6ailen);\n\n      /* If we have information about deprecated and temporary addresses\n\t sort the array now.  */\n      if (in6ai != NULL)\n\tqsort (in6ai, in6ailen, sizeof (*in6ai), in6aicmp);\n\n      int fd = -1;\n      int af = AF_UNSPEC;\n\n      for (i = 0, q = p; q != NULL; ++i, last = q, q = q->ai_next)\n\t{\n\t  results[i].dest_addr = q;\n\t  results[i].native = -1;\n\t  order[i] = i;\n\n\t  /* If we just looked up the address for a different\n\t     protocol, reuse the result.  */\n\t  if (last != NULL && last->ai_addrlen == q->ai_addrlen\n\t      && memcmp (last->ai_addr, q->ai_addr, q->ai_addrlen) == 0)\n\t    {\n\t      memcpy (&results[i].source_addr, &results[i - 1].source_addr,\n\t\t      results[i - 1].source_addr_len);\n\t      results[i].source_addr_len = results[i - 1].source_addr_len;\n\t      results[i].got_source_addr = results[i - 1].got_source_addr;\n\t      results[i].source_addr_flags = results[i - 1].source_addr_flags;\n\t      results[i].prefixlen = results[i - 1].prefixlen;\n\t      results[i].index = results[i - 1].index;\n\t    }\n\t  else\n\t    {\n\t      results[i].got_source_addr = false;\n\t      results[i].source_addr_flags = 0;\n\t      results[i].prefixlen = 0;\n\t      results[i].index = 0xffffffffu;\n\n\t      /* We overwrite the type with SOCK_DGRAM since we do not\n\t\t want connect() to connect to the other side.  If we\n\t\t cannot determine the source address remember this\n\t\t fact.  */\n\t      if (fd == -1 || (af == AF_INET && q->ai_family == AF_INET6))\n\t\t{\n\t\t  if (fd != -1)\n\t\t    __close_nocancel_nostatus (fd);\n\t\t  af = q->ai_family;\n\t\t  fd = __socket (af, SOCK_DGRAM | SOCK_CLOEXEC, IPPROTO_IP);\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Reset the connection.  */\n\t\t  struct sockaddr sa = { .sa_family = AF_UNSPEC };\n\t\t  __connect (fd, &sa, sizeof (sa));\n\t\t}\n\n\t      if (try_connect (&fd, &af, &results[i].source_addr, q->ai_addr,\n\t\t\t       q->ai_addrlen, q->ai_family))\n\t\t{\n\t\t  results[i].source_addr_len = sizeof (results[i].source_addr);\n\t\t  results[i].got_source_addr = true;\n\n\t\t  if (in6ai != NULL)\n\t\t    {\n\t\t      /* See whether the source address is on the list of\n\t\t\t deprecated or temporary addresses.  */\n\t\t      struct in6addrinfo tmp;\n\n\t\t      if (q->ai_family == AF_INET && af == AF_INET)\n\t\t\t{\n\t\t\t  struct sockaddr_in *sinp\n\t\t\t    = (struct sockaddr_in *) &results[i].source_addr;\n\t\t\t  tmp.addr[0] = 0;\n\t\t\t  tmp.addr[1] = 0;\n\t\t\t  tmp.addr[2] = htonl (0xffff);\n\t\t\t  /* Special case for lo interface, the source address\n\t\t\t     being possibly different than the interface\n\t\t\t     address. */\n\t\t\t  if ((ntohl(sinp->sin_addr.s_addr) & 0xff000000)\n\t\t\t      == 0x7f000000)\n\t\t\t    tmp.addr[3] = htonl(0x7f000001);\n\t\t\t  else\n\t\t\t    tmp.addr[3] = sinp->sin_addr.s_addr;\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  struct sockaddr_in6 *sin6p\n\t\t\t    = (struct sockaddr_in6 *) &results[i].source_addr;\n\t\t\t  memcpy (tmp.addr, &sin6p->sin6_addr, IN6ADDRSZ);\n\t\t\t}\n\n\t\t      struct in6addrinfo *found\n\t\t\t= bsearch (&tmp, in6ai, in6ailen, sizeof (*in6ai),\n\t\t\t\t   in6aicmp);\n\t\t      if (found != NULL)\n\t\t\t{\n\t\t\t  results[i].source_addr_flags = found->flags;\n\t\t\t  results[i].prefixlen = found->prefixlen;\n\t\t\t  results[i].index = found->index;\n\t\t\t}\n\t\t    }\n\n\t\t  if (q->ai_family == AF_INET && af == AF_INET6)\n\t\t    {\n\t\t      /* We have to convert the address.  The socket is\n\t\t\t IPv6 and the request is for IPv4.  */\n\t\t      struct sockaddr_in6 *sin6\n\t\t\t= (struct sockaddr_in6 *) &results[i].source_addr;\n\t\t      struct sockaddr_in *sin\n\t\t\t= (struct sockaddr_in *) &results[i].source_addr;\n\t\t      assert (IN6_IS_ADDR_V4MAPPED (sin6->sin6_addr.s6_addr32));\n\t\t      sin->sin_family = AF_INET;\n\t\t      /* We do not have to initialize sin_port since this\n\t\t\t fields has the same position and size in the IPv6\n\t\t\t structure.  */\n\t\t      assert (offsetof (struct sockaddr_in, sin_port)\n\t\t\t      == offsetof (struct sockaddr_in6, sin6_port));\n\t\t      assert (sizeof (sin->sin_port)\n\t\t\t      == sizeof (sin6->sin6_port));\n\t\t      memcpy (&sin->sin_addr,\n\t\t\t      &sin6->sin6_addr.s6_addr32[3], INADDRSZ);\n\t\t      results[i].source_addr_len = sizeof (struct sockaddr_in);\n\t\t    }\n\t\t}\n\t      else\n\t\t/* Just make sure that if we have to process the same\n\t\t   address again we do not copy any memory.  */\n\t\tresults[i].source_addr_len = 0;\n\t    }\n\n\t  /* Remember the canonical name.  */\n\t  if (q->ai_canonname != NULL)\n\t    {\n\t      assert (canonname == NULL);\n\t      canonname = q->ai_canonname;\n\t      q->ai_canonname = NULL;\n\t    }\n\t}\n\n      if (fd != -1)\n\t__close_nocancel_nostatus (fd);\n\n      /* We got all the source addresses we can get, now sort using\n\t the information.  */\n      struct sort_result_combo src\n\t= { .results = results, .nresults = nresults };\n      if (__glibc_unlikely (gaiconf_reload_flag_ever_set))\n\t{\n\t  __libc_lock_define_initialized (static, lock);\n\n\t  __libc_lock_lock (lock);\n\t  if (__libc_once_get (old_once) && gaiconf_reload_flag)\n\t    gaiconf_reload ();\n\t  __qsort_r (order, nresults, sizeof (order[0]), rfc3484_sort, &src);\n\t  __libc_lock_unlock (lock);\n\t}\n      else\n\t__qsort_r (order, nresults, sizeof (order[0]), rfc3484_sort, &src);\n\n      /* Queue the results up as they come out of sorting.  */\n      q = p = results[order[0]].dest_addr;\n      for (i = 1; i < nresults; ++i)\n\tq = q->ai_next = results[order[i]].dest_addr;\n      q->ai_next = NULL;\n\n      /* Fill in the canonical name into the new first entry.  */\n      p->ai_canonname = canonname;\n\n      scratch_buffer_free (&buf);\n    }\n\n  __free_in6ai (in6ai);\n\n  if (p)\n    {\n      *pai = p;\n      return 0;\n    }\n\n  return last_i ? -last_i : EAI_NONAME;\n}",
    "endaliasent()": "void\nENDFUNC_NAME (void)\n{\n  int save;\n\n  /* If the service has not been used before do not do anything.  */\n  if (startp != NULL)\n    {\n      __libc_lock_lock (lock);\n      __nss_endent (ENDFUNC_NAME_STRING, DB_LOOKUP_FCT, &nip, &startp,\n\t\t    &last_nip, NEED__RES);\n      save = errno;\n      __libc_lock_unlock (lock);\n      __set_errno (save);\n    }\n}",
    "endgrent()": "void\nENDFUNC_NAME (void)\n{\n  int save;\n\n  /* If the service has not been used before do not do anything.  */\n  if (startp != NULL)\n    {\n      __libc_lock_lock (lock);\n      __nss_endent (ENDFUNC_NAME_STRING, DB_LOOKUP_FCT, &nip, &startp,\n\t\t    &last_nip, NEED__RES);\n      save = errno;\n      __libc_lock_unlock (lock);\n      __set_errno (save);\n    }\n}",
    "endhostent()": "void\nENDFUNC_NAME (void)\n{\n  int save;\n\n  /* If the service has not been used before do not do anything.  */\n  if (startp != NULL)\n    {\n      __libc_lock_lock (lock);\n      __nss_endent (ENDFUNC_NAME_STRING, DB_LOOKUP_FCT, &nip, &startp,\n\t\t    &last_nip, NEED__RES);\n      save = errno;\n      __libc_lock_unlock (lock);\n      __set_errno (save);\n    }\n}",
    "getnameinfo(const struct sockaddr *, socklen_t, char *, socklen_t, char *, socklen_t, int)": "int\ngetnameinfo (const struct sockaddr *sa, socklen_t addrlen, char *host,\n\t     socklen_t hostlen, char *serv, socklen_t servlen,\n\t     int flags)\n{\n  if (flags & ~(NI_NUMERICHOST|NI_NUMERICSERV|NI_NOFQDN|NI_NAMEREQD|NI_DGRAM\n\t\t|NI_IDN|DEPRECATED_NI_IDN))\n    return EAI_BADFLAGS;\n\n  if (sa == NULL || addrlen < sizeof (sa_family_t))\n    return EAI_FAMILY;\n\n  if ((flags & NI_NAMEREQD) && host == NULL && serv == NULL)\n    return EAI_NONAME;\n\n  switch (sa->sa_family)\n    {\n    case AF_LOCAL:\n      if (addrlen < (socklen_t) offsetof (struct sockaddr_un, sun_path))\n\treturn EAI_FAMILY;\n      break;\n    case AF_INET:\n      if (addrlen < sizeof (struct sockaddr_in))\n\treturn EAI_FAMILY;\n      break;\n    case AF_INET6:\n      if (addrlen < sizeof (struct sockaddr_in6))\n\treturn EAI_FAMILY;\n      break;\n    default:\n      return EAI_FAMILY;\n    }\n\n  struct scratch_buffer tmpbuf;\n  scratch_buffer_init (&tmpbuf);\n\n  if (host != NULL && hostlen > 0)\n    {\n      int result = gni_host (&tmpbuf, sa, addrlen, host, hostlen, flags);\n      if (result != 0)\n\t{\n\t  scratch_buffer_free (&tmpbuf);\n\t  return result;\n\t}\n    }\n\n  if (serv && (servlen > 0))\n    {\n      int result = gni_serv (&tmpbuf, sa, addrlen, serv, servlen, flags);\n      if (result != 0)\n\t{\n\t  scratch_buffer_free (&tmpbuf);\n\t  return result;\n\t}\n    }\n\n  scratch_buffer_free (&tmpbuf);\n  return 0;\n}",
    "endnetent()": "void\nENDFUNC_NAME (void)\n{\n  int save;\n\n  /* If the service has not been used before do not do anything.  */\n  if (startp != NULL)\n    {\n      __libc_lock_lock (lock);\n      __nss_endent (ENDFUNC_NAME_STRING, DB_LOOKUP_FCT, &nip, &startp,\n\t\t    &last_nip, NEED__RES);\n      save = errno;\n      __libc_lock_unlock (lock);\n      __set_errno (save);\n    }\n}",
    "getnetgrent(char **, char **, char **)": "int\ngetnetgrent (char **hostp, char **userp, char **domainp)\n{\n  __libc_once_define (static, once);\n  __libc_once (once, allocate);\n\n  if (buffer == NULL)\n    {\n      __set_errno (ENOMEM);\n      return -1;\n    }\n\n  return __getnetgrent_r (hostp, userp, domainp, buffer, BUFSIZE);\n}",
    "__internal_setnetgrent(const char *, struct __netgrent *)": "int\n__internal_setnetgrent (const char *group, struct __netgrent *datap)\n{\n  /* Free list of all netgroup names from last run.  */\n  free_memory (datap);\n\n  return __internal_setnetgrent_reuse (group, datap, &errno);\n}",
    "setnetgrent(const char *)": "int\nsetnetgrent (const char *group)\n{\n  int result;\n\n  __libc_lock_lock (lock);\n\n  result = nscd_setnetgrent (group);\n  if (result < 0)\n    result = __internal_setnetgrent (group, &dataset);\n\n  __libc_lock_unlock (lock);\n\n  return result;\n}",
    "__internal_endnetgrent(struct __netgrent *)": "void\n__internal_endnetgrent (struct __netgrent *datap)\n{\n  endnetgrent_hook (datap);\n  /* Now free list of all netgroup names from last run.  */\n  free_memory (datap);\n}",
    "__internal_getnetgrent_r(char **, char **, char **, struct __netgrent *, char *, int, int *)": "int\n__internal_getnetgrent_r (char **hostp, char **userp, char **domainp,\n\t\t\t  struct __netgrent *datap,\n\t\t\t  char *buffer, size_t buflen, int *errnop)\n{\n  enum nss_status (*fct) (struct __netgrent *, char *, size_t, int *);\n\n  /* Initialize status to return if no more functions are found.  */\n  enum nss_status status = NSS_STATUS_NOTFOUND;\n\n  /* Run through available functions, starting with the same function last\n     run.  We will repeat each function as long as it succeeds, and then go\n     on to the next service action.  */\n  int no_more = datap->nip == NULL;\n  if (! no_more)\n    {\n#ifdef USE_NSCD\n      /* This bogus function pointer is a special marker left by\n\t __nscd_setnetgrent to tell us to use the data it left\n\t before considering any modules.  */\n      if (datap->nip == (nss_action_list) -1l)\n\tfct = nscd_getnetgrent;\n      else\n#endif\n\t{\n\t  fct = __nss_lookup_function (datap->nip, \"getnetgrent_r\");\n\t  no_more = fct == NULL;\n\t}\n\n      while (! no_more)\n\t{\n\t  status = DL_CALL_FCT (*fct, (datap, buffer, buflen, &errno));\n\n\t  if (status == NSS_STATUS_RETURN\n\t      /* The service returned a NOTFOUND, but there are more groups that\n\t\t we need to resolve before we give up.  */\n\t      || (status == NSS_STATUS_NOTFOUND && datap->needed_groups != NULL))\n\t    {\n\t      /* This was the last one for this group.  Look at next group\n\t\t if available.  */\n\t      int found = 0;\n\t      while (datap->needed_groups != NULL && ! found)\n\t\t{\n\t\t  struct name_list *tmp = datap->needed_groups;\n\t\t  datap->needed_groups = datap->needed_groups->next;\n\t\t  tmp->next = datap->known_groups;\n\t\t  datap->known_groups = tmp;\n\n\t\t  found = __internal_setnetgrent_reuse (datap->known_groups->name,\n\t\t\t\t\t\t\tdatap, errnop);\n\t\t}\n\n\t      if (found && datap->nip != NULL)\n\t\t{\n\t\t  fct = __nss_lookup_function (datap->nip, \"getnetgrent_r\");\n\t\t  if (fct != NULL)\n\t\t    continue;\n\t\t}\n\t    }\n\t  else if (status == NSS_STATUS_SUCCESS && datap->type == group_val)\n\t    {\n\t      /* The last entry was a name of another netgroup.  */\n\t      struct name_list *namep;\n\n\t      /* Ignore if we've seen the name before.  */\n\t      for (namep = datap->known_groups; namep != NULL;\n\t\t   namep = namep->next)\n\t\tif (strcmp (datap->val.group, namep->name) == 0)\n\t\t  break;\n\t      if (namep == NULL)\n\t\tfor (namep = datap->needed_groups; namep != NULL;\n\t\t     namep = namep->next)\n\t\t  if (strcmp (datap->val.group, namep->name) == 0)\n\t\t    break;\n\t      if (namep != NULL)\n\t\t/* Really ignore.  */\n\t\tcontinue;\n\n\t      size_t group_len = strlen (datap->val.group) + 1;\n\t      namep = (struct name_list *) malloc (sizeof (struct name_list)\n\t\t\t\t\t\t  + group_len);\n\t      if (namep == NULL)\n\t\t/* We are out of memory.  */\n\t\tstatus = NSS_STATUS_RETURN;\n\t      else\n\t\t{\n\t\t  namep->next = datap->needed_groups;\n\t\t  memcpy (namep->name, datap->val.group, group_len);\n\t\t  datap->needed_groups = namep;\n\t\t  /* And get the next entry.  */\n\t\t  continue;\n\t\t}\n\t    }\n\t  break;\n\t}\n    }\n\n  if (status == NSS_STATUS_SUCCESS)\n    {\n      *hostp = (char *) datap->val.triple.host;\n      *userp = (char *) datap->val.triple.user;\n      *domainp = (char *) datap->val.triple.domain;\n    }\n\n  return status == NSS_STATUS_SUCCESS ? 1 : 0;\n}",
    "endprotoent()": "void\nENDFUNC_NAME (void)\n{\n  int save;\n\n  /* If the service has not been used before do not do anything.  */\n  if (startp != NULL)\n    {\n      __libc_lock_lock (lock);\n      __nss_endent (ENDFUNC_NAME_STRING, DB_LOOKUP_FCT, &nip, &startp,\n\t\t    &last_nip, NEED__RES);\n      save = errno;\n      __libc_lock_unlock (lock);\n      __set_errno (save);\n    }\n}",
    "endpwent()": "void\nENDFUNC_NAME (void)\n{\n  int save;\n\n  /* If the service has not been used before do not do anything.  */\n  if (startp != NULL)\n    {\n      __libc_lock_lock (lock);\n      __nss_endent (ENDFUNC_NAME_STRING, DB_LOOKUP_FCT, &nip, &startp,\n\t\t    &last_nip, NEED__RES);\n      save = errno;\n      __libc_lock_unlock (lock);\n      __set_errno (save);\n    }\n}",
    "endrpcent()": "void\nENDFUNC_NAME (void)\n{\n  int save;\n\n  /* If the service has not been used before do not do anything.  */\n  if (startp != NULL)\n    {\n      __libc_lock_lock (lock);\n      __nss_endent (ENDFUNC_NAME_STRING, DB_LOOKUP_FCT, &nip, &startp,\n\t\t    &last_nip, NEED__RES);\n      save = errno;\n      __libc_lock_unlock (lock);\n      __set_errno (save);\n    }\n}",
    "endservent()": "void\nENDFUNC_NAME (void)\n{\n  int save;\n\n  /* If the service has not been used before do not do anything.  */\n  if (startp != NULL)\n    {\n      __libc_lock_lock (lock);\n      __nss_endent (ENDFUNC_NAME_STRING, DB_LOOKUP_FCT, &nip, &startp,\n\t\t    &last_nip, NEED__RES);\n      save = errno;\n      __libc_lock_unlock (lock);\n      __set_errno (save);\n    }\n}",
    "endsgent()": "void\nENDFUNC_NAME (void)\n{\n  int save;\n\n  /* If the service has not been used before do not do anything.  */\n  if (startp != NULL)\n    {\n      __libc_lock_lock (lock);\n      __nss_endent (ENDFUNC_NAME_STRING, DB_LOOKUP_FCT, &nip, &startp,\n\t\t    &last_nip, NEED__RES);\n      save = errno;\n      __libc_lock_unlock (lock);\n      __set_errno (save);\n    }\n}",
    "endspent()": "void\nENDFUNC_NAME (void)\n{\n  int save;\n\n  /* If the service has not been used before do not do anything.  */\n  if (startp != NULL)\n    {\n      __libc_lock_lock (lock);\n      __nss_endent (ENDFUNC_NAME_STRING, DB_LOOKUP_FCT, &nip, &startp,\n\t\t    &last_nip, NEED__RES);\n      save = errno;\n      __libc_lock_unlock (lock);\n      __set_errno (save);\n    }\n}",
    "__copy_grp(const struct group, const int, struct group *, char *, char **)": "int\n__copy_grp (const struct group srcgrp, const size_t buflen,\n\t    struct group *destgrp, char *destbuf, char **endptr)\n{\n  size_t i;\n  size_t c = 0;\n  size_t len;\n  size_t memcount;\n  char **members = NULL;\n\n  /* Copy the GID.  */\n  destgrp->gr_gid = srcgrp.gr_gid;\n\n  /* Copy the name.  */\n  len = strlen (srcgrp.gr_name) + 1;\n  BUFCHECK (len);\n  memcpy (&destbuf[c], srcgrp.gr_name, len);\n  destgrp->gr_name = &destbuf[c];\n  c += len;\n\n  /* Copy the password.  */\n  len = strlen (srcgrp.gr_passwd) + 1;\n  BUFCHECK (len);\n  memcpy (&destbuf[c], srcgrp.gr_passwd, len);\n  destgrp->gr_passwd = &destbuf[c];\n  c += len;\n\n  /* Count all of the members.  */\n  for (memcount = 0; srcgrp.gr_mem[memcount]; memcount++)\n    ;\n\n  /* Allocate a temporary holding area for the pointers to the member\n     contents, including space for a NULL-terminator.  */\n  members = malloc (sizeof (char *) * (memcount + 1));\n  if (members == NULL)\n    return ENOMEM;\n\n  /* Copy all of the group members to destbuf and add a pointer to each of\n     them into the 'members' array.  */\n  for (i = 0; srcgrp.gr_mem[i]; i++)\n    {\n      len = strlen (srcgrp.gr_mem[i]) + 1;\n      BUFCHECK (len);\n      memcpy (&destbuf[c], srcgrp.gr_mem[i], len);\n      members[i] = &destbuf[c];\n      c += len;\n    }\n  members[i] = NULL;\n\n  /* Align for pointers.  We can't simply align C because we need to\n     align destbuf[c].  */\n  if ((((uintptr_t)destbuf + c) & (__alignof__(char **) - 1)) != 0)\n    {\n      uintptr_t mis_align = ((uintptr_t)destbuf + c) & (__alignof__(char **) - 1);\n      c += __alignof__(char **) - mis_align;\n    }\n\n  /* Copy the pointers from the members array into the buffer and assign them\n     to the gr_mem member of destgrp.  */\n  destgrp->gr_mem = (char **) &destbuf[c];\n  len = sizeof (char *) * (memcount + 1);\n  BUFCHECK (len);\n  memcpy (&destbuf[c], members, len);\n  c += len;\n  free (members);\n  members = NULL;\n\n  /* Save the count of members at the end.  */\n  BUFCHECK (sizeof (size_t));\n  memcpy (&destbuf[c], &memcount, sizeof (size_t));\n  c += sizeof (size_t);\n\n  if (endptr)\n    *endptr = destbuf + c;\n  return 0;\n}",
    "getgrouplist(const char *, gid_t, gid_t *, int *)": "int\ngetgrouplist (const char *user, gid_t group, gid_t *groups, int *ngroups)\n{\n  long int size = MAX (1, *ngroups);\n\n  gid_t *newgroups = (gid_t *) malloc (size * sizeof (gid_t));\n  if (__glibc_unlikely (newgroups == NULL))\n    /* No more memory.  */\n    // XXX This is wrong.  The user provided memory, we have to use\n    // XXX it.  The internal functions must be called with the user\n    // XXX provided buffer and not try to increase the size if it is\n    // XXX too small.  For initgroups a flag could say: increase size.\n    return -1;\n\n  int total = internal_getgrouplist (user, group, &size, &newgroups, -1);\n\n  memcpy (groups, newgroups, MIN (*ngroups, total) * sizeof (gid_t));\n\n  free (newgroups);\n\n  int retval = total > *ngroups ? -1 : total;\n  *ngroups = total;\n\n  return retval;\n}",
    "__nss_configure_lookup(const char *, const char *)": "int\n__nss_configure_lookup (const char *dbname, const char *service_line)\n{\n  int db;\n  nss_action_list result;\n  struct nss_database_state *local;\n\n  /* Convert named database to index.  */\n  db = name_to_database_index (dbname);\n  if (db < 0)\n    /* Not our database (e.g., sudoers).  */\n    return -1;\n\n  /* Force any load/cache/read whatever to happen, so we can override\n     it.  */\n  __nss_database_get (db, &result);\n\n  local = nss_database_state_get ();\n\n  result = __nss_action_parse (service_line);\n  if (result == NULL)\n    return -1;\n\n  atomic_store_release (&local->data.reload_disabled, 1);\n  local->data.services[db] = result;\n\n#ifdef USE_NSCD\n  __nss_database_custom[db] = true;\n#endif\n\n  return 0;\n}",
    "__nss_database_get(enum nss_database, nss_action_list *)": "bool\n__nss_database_get (enum nss_database db, nss_action_list *actions)\n{\n  struct nss_database_state *local = nss_database_state_get ();\n  return nss_database_check_reload_and_get (local, actions, db);\n}",
    "__nss_files_data_open(struct nss_files_per_file_data **, enum nss_files_file, const char *, int *, int *)": "enum nss_status\n__nss_files_data_open (struct nss_files_per_file_data **pdata,\n                       enum nss_files_file file, const char *path,\n                       int *errnop, int *herrnop)\n{\n  enum nss_status status = __nss_files_data_get (pdata, file, errnop, herrnop);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n\n  /* Be prepared that the set*ent function was not called before.  */\n  if ((*pdata)->stream == NULL)\n    {\n      int saved_errno = errno;\n      status = __nss_files_data_internal_open (*pdata, path);\n      __set_errno (saved_errno);\n      if (status != NSS_STATUS_SUCCESS)\n        __nss_files_data_put (*pdata);\n    }\n\n  return status;\n}",
    "__nss_files_fopen(const char *)": "FILE *\n__nss_files_fopen (const char *path)\n{\n  FILE *fp = fopen (path, \"rce\");\n  if (fp == NULL)\n    return NULL;\n\n  /* The stream is not shared across threads.  */\n  __fsetlocking (fp, FSETLOCKING_BYCALLER);\n\n  /* This tells libio that the file is seekable, and that fp->_offset\n     is correct, ensuring that __ftello64 is efficient (bug 26257).  */\n  if (__fseeko64 (fp, 0, SEEK_SET) < 0)\n    {\n      /* nss_files requires seekable files, to deal with repeated\n         reads of the same line after reporting ERANGE.  */\n      fclose (fp);\n      __set_errno (ESPIPE);\n      return NULL;\n    }\n\n  return fp;\n}",
    "__nss_hash(const void *, int)": "uint32_t\n__nss_hash (const void *keyarg, size_t len)\n{\n  enum\n  {\n    HASH_CONST_P0 = 1,\t       /* (uint32_t)(65599 ^ 0).  */\n    HASH_CONST_P1 = 65599,     /* (uint32_t)(65599 ^ 1).  */\n    HASH_CONST_P2 = 8261505,   /* (uint32_t)(65599 ^ 2).  */\n    HASH_CONST_P3 = 780587199, /* (uint32_t)(65599 ^ 3).  */\n    HASH_CONST_P4 = 1139564289 /* (uint32_t)(65599 ^ 4).  */\n  };\n\n  const unsigned char *key;\n  uint32_t h;\n\n#define HASHC\th = *key++ + HASH_CONST_P1 * h\n\n  h = 0;\n  key = keyarg;\n  if (len > 0)\n    {\n      switch ((len & (4 - 1)))\n\t{\n\tcase 0:\n\t  /* h starts out as zero so no need to include the multiply. */\n\t  h = *key++;\n\t  /* FALLTHROUGH */\n\tcase 3:\n\t  HASHC;\n\t  /* FALLTHROUGH */\n\tcase 2:\n\t  HASHC;\n\t  /* FALLTHROUGH */\n\tcase 1:\n\t  HASHC;\n\t  /* FALLTHROUGH */\n\t}\n\n      uint32_t c0, c1, c2, c3;\n      for (--len; len >= 4; len -= 4)\n\t{\n\t  c0 = (unsigned char) *(key + 0);\n\t  c1 = (unsigned char) *(key + 1);\n\t  c2 = (unsigned char) *(key + 2);\n\t  c3 = (unsigned char) *(key + 3);\n\t  h = HASH_CONST_P4 * h + HASH_CONST_P3 * c0 + HASH_CONST_P2 * c1\n\t      + HASH_CONST_P1 * c2 + HASH_CONST_P0 * c3;\n\n\t  key += 4;\n\t}\n    }\n  return h;\n}",
    "__nss_parse_line_result(int *, int, int)": "int\n__nss_parse_line_result (FILE *fp, off64_t offset, int parse_line_result)\n{\n  assert (parse_line_result >= -1 && parse_line_result <= 1);\n\n  switch (__builtin_expect (parse_line_result, 1))\n    {\n    case 1:\n      /* Success.  */\n      return 0;\n    case 0:\n      /* Parse error.  */\n      __set_errno (EINVAL);\n      return EINVAL;\n    case -1:\n      /* Out of buffer space.  */\n      return __nss_readline_seek (fp, offset);\n\n      default:\n        __builtin_unreachable ();\n    }\n}",
    "__nss_readline(int *, char *, int, int *)": "int\n__nss_readline (FILE *fp, char *buf, size_t len, off64_t *poffset)\n{\n  /* We need space for at least one character, the line terminator,\n     and the NUL byte.  */\n  if (len < 3)\n    {\n      *poffset = -1;\n      __set_errno (ERANGE);\n      return ERANGE;\n    }\n\n  while (true)\n    {\n      /* Keep original offset for retries.  */\n      *poffset = __ftello64 (fp);\n\n      buf[len - 1] = '\\xff';        /* Marker to recognize truncation.  */\n      if (__fgets_unlocked (buf, len, fp) == NULL)\n        {\n          if (__feof_unlocked (fp))\n            {\n              __set_errno (ENOENT);\n              return ENOENT;\n            }\n          else\n            {\n              /* Any other error.  Do not return ERANGE in this case\n                 because the caller would retry.  */\n              if (errno == ERANGE)\n                __set_errno (EINVAL);\n              return errno;\n            }\n        }\n      else if (buf[len - 1] != '\\xff')\n        /* The buffer is too small.  Arrange for re-reading the same\n           line on the next call.  */\n        return __nss_readline_seek (fp, *poffset);\n\n      /* __fgets_unlocked succeeded.  */\n\n      /* Remove leading whitespace.  */\n      char *p = buf;\n      while (isspace (*p))\n        ++p;\n      if (*p == '\\0' || *p == '#')\n        /* Skip empty lines and comments.  */\n        continue;\n      if (p != buf)\n        memmove (buf, p, strlen (p));\n\n      /* Return line to the caller.  */\n      return 0;\n    }\n}",
    "putgrent(const struct group *, FILE *)": "int\nputgrent (const struct group *gr, FILE *stream)\n{\n  int retval;\n\n  if (__glibc_unlikely (gr == NULL) || __glibc_unlikely (stream == NULL)\n      || gr->gr_name == NULL || !__nss_valid_field (gr->gr_name)\n      || !__nss_valid_field (gr->gr_passwd)\n      || !__nss_valid_list_field (gr->gr_mem))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  flockfile (stream);\n\n  if (gr->gr_name[0] == '+' || gr->gr_name[0] == '-')\n    retval = fprintf (stream, \"%s:%s::\",\n\t\t      gr->gr_name, _S (gr->gr_passwd));\n  else\n    retval = fprintf (stream, \"%s:%s:%lu:\",\n\t\t      gr->gr_name, _S (gr->gr_passwd),\n\t\t      (unsigned long int) gr->gr_gid);\n  if (__builtin_expect (retval, 0) < 0)\n    {\n      funlockfile (stream);\n      return -1;\n    }\n\n  if (gr->gr_mem != NULL)\n    {\n      for (size_t i = 0; gr->gr_mem[i] != NULL; i++)\n\tif (fprintf (stream, i == 0 ? \"%s\" : \",%s\", gr->gr_mem[i]) < 0)\n\t  {\n\t    /* What else can we do?  */\n\t    funlockfile (stream);\n\t    return -1;\n\t  }\n    }\n\n  retval = fputc_unlocked ('\\n', stream);\n\n  funlockfile (stream);\n\n  return retval < 0 ? -1 : 0;\n}",
    "putpwent(const struct passwd *, FILE *)": "int\nputpwent (const struct passwd *p, FILE *stream)\n{\n  if (p == NULL || stream == NULL\n      || p->pw_name == NULL || !__nss_valid_field (p->pw_name)\n      || !__nss_valid_field (p->pw_passwd)\n      || !__nss_valid_field (p->pw_dir)\n      || !__nss_valid_field (p->pw_shell))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  int ret;\n  char *gecos_alloc;\n  const char *gecos = __nss_rewrite_field (p->pw_gecos, &gecos_alloc);\n\n  if (gecos == NULL)\n    return -1;\n\n  if (p->pw_name[0] == '+' || p->pw_name[0] == '-')\n      ret = fprintf (stream, \"%s:%s:::%s:%s:%s\\n\",\n\t\t     p->pw_name, _S (p->pw_passwd),\n\t\t     gecos, _S (p->pw_dir), _S (p->pw_shell));\n  else\n      ret = fprintf (stream, \"%s:%s:%lu:%lu:%s:%s:%s\\n\",\n\t\t     p->pw_name, _S (p->pw_passwd),\n\t\t     (unsigned long int) p->pw_uid,\n\t\t     (unsigned long int) p->pw_gid,\n\t\t     gecos, _S (p->pw_dir), _S (p->pw_shell));\n\n  free (gecos_alloc);\n  if (ret >= 0)\n    ret = 0;\n  return ret;\n}",
    "putsgent(const struct sgrp *, FILE *)": "int\nputsgent (const struct sgrp *g, FILE *stream)\n{\n  int errors = 0;\n\n  if (g->sg_namp == NULL || !__nss_valid_field (g->sg_namp)\n      || !__nss_valid_field (g->sg_passwd)\n      || !__nss_valid_list_field (g->sg_adm)\n      || !__nss_valid_list_field (g->sg_mem))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  _IO_flockfile (stream);\n\n  if (fprintf (stream, \"%s:%s:\", g->sg_namp, _S (g->sg_passwd)) < 0)\n    ++errors;\n\n  bool first = true;\n  char **sp = g->sg_adm;\n  if (sp != NULL)\n    while (*sp != NULL)\n      {\n\tif (fprintf (stream, \"%s%s\", first ? \"\" : \",\", *sp++) < 0)\n\t  {\n\t    ++errors;\n\t    break;\n\t  }\n\tfirst = false;\n      }\n  if (putc_unlocked (':', stream) == EOF)\n    ++errors;\n\n  first = true;\n  sp = g->sg_mem;\n  if (sp != NULL)\n    while (*sp != NULL)\n      {\n\tif (fprintf (stream, \"%s%s\", first ? \"\" : \",\", *sp++) < 0)\n\t  {\n\t    ++errors;\n\t    break;\n\t  }\n\tfirst = false;\n      }\n  if (putc_unlocked ('\\n', stream) == EOF)\n    ++errors;\n\n  _IO_funlockfile (stream);\n\n  return errors ? -1 : 0;\n}",
    "putspent(const struct spwd *, FILE *)": "int\nputspent (const struct spwd *p, FILE *stream)\n{\n  int errors = 0;\n\n  if (p->sp_namp == NULL || !__nss_valid_field (p->sp_namp)\n      || !__nss_valid_field (p->sp_pwdp))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  flockfile (stream);\n\n  if (fprintf (stream, \"%s:%s:\", p->sp_namp, _S (p->sp_pwdp)) < 0)\n    ++errors;\n\n  if ((p->sp_lstchg != (long int) -1\n       && fprintf (stream, \"%ld:\", p->sp_lstchg) < 0)\n      || (p->sp_lstchg == (long int) -1\n\t  && putc_unlocked (':', stream) == EOF))\n    ++errors;\n\n  if ((p->sp_min != (long int) -1\n       && fprintf (stream, \"%ld:\", p->sp_min) < 0)\n      || (p->sp_min == (long int) -1\n\t  && putc_unlocked (':', stream) == EOF))\n    ++errors;\n\n  if ((p->sp_max != (long int) -1\n       && fprintf (stream, \"%ld:\", p->sp_max) < 0)\n      || (p->sp_max == (long int) -1\n\t  && putc_unlocked (':', stream) == EOF))\n    ++errors;\n\n  if ((p->sp_warn != (long int) -1\n       && fprintf (stream, \"%ld:\", p->sp_warn) < 0)\n      || (p->sp_warn == (long int) -1\n\t  && putc_unlocked (':', stream) == EOF))\n    ++errors;\n\n  if ((p->sp_inact != (long int) -1\n       && fprintf (stream, \"%ld:\", p->sp_inact) < 0)\n      || (p->sp_inact == (long int) -1\n\t  && putc_unlocked (':', stream) == EOF))\n    ++errors;\n\n  if ((p->sp_expire != (long int) -1\n       && fprintf (stream, \"%ld:\", p->sp_expire) < 0)\n      || (p->sp_expire == (long int) -1\n\t  && putc_unlocked (':', stream) == EOF))\n    ++errors;\n\n  if (p->sp_flag != ~0ul\n      && fprintf (stream, \"%ld\", p->sp_flag) < 0)\n    ++errors;\n\n  if (putc_unlocked ('\\n', stream) == EOF)\n    ++errors;\n\n  funlockfile (stream);\n\n  return errors ? -1 : 0;\n}",
    "sgetsgent(const char *)": "struct sgrp *\nsgetsgent (const char *string)\n{\n  static char *buffer;\n  static size_t buffer_size;\n  static struct sgrp resbuf;\n  struct sgrp *result;\n  int save;\n\n  /* Get lock.  */\n  __libc_lock_lock (lock);\n\n  /* Allocate buffer if not yet available.  */\n  if (buffer == NULL)\n    {\n      buffer_size = BUFLEN_SPWD;\n      buffer = malloc (buffer_size);\n    }\n\n  while (buffer != NULL\n\t && __sgetsgent_r (string, &resbuf, buffer, buffer_size, &result) != 0\n\t && errno == ERANGE)\n    {\n      char *new_buf;\n      buffer_size += BUFLEN_SPWD;\n      new_buf = realloc (buffer, buffer_size);\n      if (new_buf == NULL)\n\t{\n\t  /* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */\n\t  save = errno;\n\t  free (buffer);\n\t  __set_errno (save);\n\t}\n      buffer = new_buf;\n    }\n\n  if (buffer == NULL)\n    result = NULL;\n\n  /* Release lock.  Preserve error value.  */\n  save = errno;\n  __libc_lock_unlock (lock);\n  __set_errno (save);\n\n  return result;\n}",
    "sgetspent(const char *)": "struct spwd *\nsgetspent (const char *string)\n{\n  static char *buffer;\n  static size_t buffer_size;\n  static struct spwd resbuf;\n  struct spwd *result;\n  int save;\n\n  /* Get lock.  */\n  __libc_lock_lock (lock);\n\n  /* Allocate buffer if not yet available.  */\n  if (buffer == NULL)\n    {\n      buffer_size = BUFLEN_SPWD;\n      buffer = malloc (buffer_size);\n    }\n\n  while (buffer != NULL\n\t && (__sgetspent_r (string, &resbuf, buffer, buffer_size, &result)\n\t     == ERANGE))\n    {\n      char *new_buf;\n      buffer_size += BUFLEN_SPWD;\n      new_buf = realloc (buffer, buffer_size);\n      if (new_buf == NULL)\n\t{\n\t  /* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */\n\t  save = errno;\n\t  free (buffer);\n\t  __set_errno (save);\n\t}\n      buffer = new_buf;\n    }\n\n  if (buffer == NULL)\n    result = NULL;\n\n  /* Release lock.  Preserve error value.  */\n  save = errno;\n  __libc_lock_unlock (lock);\n  __set_errno (save);\n\n  return result;\n}",
    "_nss_files_setaliasent()": "enum nss_status\n_nss_files_setaliasent (void)\n{\n  return __nss_files_data_setent (nss_file_aliasent, \"/etc/aliases\");\n}",
    "_nss_files_getaliasent_r(struct aliasent *, char *, int, int *)": "enum nss_status\n_nss_files_getaliasent_r (struct aliasent *result, char *buffer, size_t buflen,\n\t\t\t  int *errnop)\n{\n  /* Return next entry in host file.  */\n\n  struct nss_files_per_file_data *data;\n  enum nss_status status = __nss_files_data_open (&data, nss_file_aliasent,\n\t\t\t\t\t\t  \"/etc/aliases\", errnop, NULL);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n\n  result->alias_local = 1;\n\n  /* Read lines until we get a definite result.  */\n  do\n    status = get_next_alias (data->stream, NULL, result, buffer, buflen,\n\t\t\t     errnop);\n  while (status == NSS_STATUS_RETURN);\n\n  __nss_files_data_put (data);\n  return status;\n}",
    "_nss_files_parse_etherent(char *, void *, struct parser_data *, int, int *)": "LINE_PARSER\n(\"#\",\n /* Read the ethernet address: 6 x 8bit hexadecimal number.  */\n {\n   size_t cnt;\n\n   for (cnt = 0; cnt < 6; ++cnt)\n     {\n       unsigned int number;\n\n       if (cnt < 5)\n\t INT_FIELD (number, ISCOLON , 0, 16, (unsigned int))\n       else\n\t INT_FIELD (number, isspace, 1, 16, (unsigned int))\n\n       if (number > 0xff)\n\t return 0;\n       result->e_addr.ether_addr_octet[cnt] = number;\n     }\n };\n STRING_FIELD (result->e_name, isspace, 1);\n )",
    "_nss_files_setetherent(int)": "enum nss_status\nCONCAT(_nss_files_set,ENTNAME) (int stayopen)\n{\n  return __nss_files_data_setent (CONCAT (nss_file_, ENTNAME), DATAFILE);\n}",
    "_nss_files_getetherent_r(struct etherent *, char *, int, int *)": "enum nss_status\nCONCAT(_nss_files_get,ENTNAME_r) (struct STRUCTURE *result, char *buffer,\n\t\t\t\t  size_t buflen, int *errnop H_ERRNO_PROTO)\n{\n  /* Return next entry in host file.  */\n\n  struct nss_files_per_file_data *data;\n  enum nss_status status = __nss_files_data_open (&data,\n\t\t\t\t\t\t  CONCAT (nss_file_, ENTNAME),\n\t\t\t\t\t\t  DATAFILE,\n\t\t\t\t\t\t  errnop, H_ERRNO_ARG_OR_NULL);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n\n  status = internal_getent (data->stream, result, buffer, buflen, errnop\n\t\t\t    H_ERRNO_ARG EXTRA_ARGS_VALUE);\n\n  __nss_files_data_put (data);\n  return status;\n}",
    "_nss_files_setgrent(int)": "enum nss_status\nCONCAT(_nss_files_set,ENTNAME) (int stayopen)\n{\n  return __nss_files_data_setent (CONCAT (nss_file_, ENTNAME), DATAFILE);\n}",
    "_nss_files_getgrent_r(struct group *, char *, int, int *)": "enum nss_status\nCONCAT(_nss_files_get,ENTNAME_r) (struct STRUCTURE *result, char *buffer,\n\t\t\t\t  size_t buflen, int *errnop H_ERRNO_PROTO)\n{\n  /* Return next entry in host file.  */\n\n  struct nss_files_per_file_data *data;\n  enum nss_status status = __nss_files_data_open (&data,\n\t\t\t\t\t\t  CONCAT (nss_file_, ENTNAME),\n\t\t\t\t\t\t  DATAFILE,\n\t\t\t\t\t\t  errnop, H_ERRNO_ARG_OR_NULL);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n\n  status = internal_getent (data->stream, result, buffer, buflen, errnop\n\t\t\t    H_ERRNO_ARG EXTRA_ARGS_VALUE);\n\n  __nss_files_data_put (data);\n  return status;\n}",
    "_nss_files_sethostent(int)": "enum nss_status\nCONCAT(_nss_files_set,ENTNAME) (int stayopen)\n{\n  return __nss_files_data_setent (CONCAT (nss_file_, ENTNAME), DATAFILE);\n}",
    "_nss_files_gethostent_r(struct hostent *, char *, int, int *, int *)": "enum nss_status\nCONCAT(_nss_files_get,ENTNAME_r) (struct STRUCTURE *result, char *buffer,\n\t\t\t\t  size_t buflen, int *errnop H_ERRNO_PROTO)\n{\n  /* Return next entry in host file.  */\n\n  struct nss_files_per_file_data *data;\n  enum nss_status status = __nss_files_data_open (&data,\n\t\t\t\t\t\t  CONCAT (nss_file_, ENTNAME),\n\t\t\t\t\t\t  DATAFILE,\n\t\t\t\t\t\t  errnop, H_ERRNO_ARG_OR_NULL);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n\n  status = internal_getent (data->stream, result, buffer, buflen, errnop\n\t\t\t    H_ERRNO_ARG EXTRA_ARGS_VALUE);\n\n  __nss_files_data_put (data);\n  return status;\n}",
    "_nss_files_gethostbyname3_r(const char *, int, struct hostent *, char *, int, int *, int *, int32_t *, char **)": "enum nss_status\n_nss_files_gethostbyname3_r (const char *name, int af, struct hostent *result,\n\t\t\t     char *buffer, size_t buflen, int *errnop,\n\t\t\t     int *herrnop, int32_t *ttlp, char **canonp)\n{\n  FILE *stream = NULL;\n  uintptr_t pad = -(uintptr_t) buffer % __alignof__ (struct hostent_data);\n  buffer += pad;\n  buflen = buflen > pad ? buflen - pad : 0;\n\n  /* Open file.  */\n  enum nss_status status = internal_setent (&stream);\n\n  if (status == NSS_STATUS_SUCCESS)\n    {\n      while ((status = internal_getent (stream, result, buffer, buflen, errnop,\n\t\t\t\t\therrnop, af, 0))\n\t     == NSS_STATUS_SUCCESS)\n\t{\n\t  LOOKUP_NAME_CASE (h_name, h_aliases)\n\t}\n\n      if (status == NSS_STATUS_SUCCESS\n\t  && _res_hconf.flags & HCONF_FLAG_MULTI)\n\tstatus = gethostbyname3_multi\n\t  (stream, name, af, result, buffer, buflen, errnop, herrnop);\n\n      fclose (stream);\n    }\n\n  if (canonp && status == NSS_STATUS_SUCCESS)\n    *canonp = result->h_name;\n\n  return status;\n}",
    "_nss_files_initgroups_dyn(const char *, gid_t, long *, long *, gid_t **, long, int *)": "enum nss_status\n_nss_files_initgroups_dyn (const char *user, gid_t group, long int *start,\n\t\t\t   long int *size, gid_t **groupsp, long int limit,\n\t\t\t   int *errnop)\n{\n  FILE *stream = __nss_files_fopen (\"/etc/group\");\n  if (stream == NULL)\n    {\n      *errnop = errno;\n      return *errnop == ENOMEM ? NSS_STATUS_TRYAGAIN : NSS_STATUS_UNAVAIL;\n    }\n\n  char *line = NULL;\n  size_t linelen = 0;\n  enum nss_status status = NSS_STATUS_SUCCESS;\n  bool any = false;\n\n  struct scratch_buffer tmpbuf;\n  scratch_buffer_init (&tmpbuf);\n\n  gid_t *groups = *groupsp;\n\n  /* We have to iterate over the entire file.  */\n  while (1)\n    {\n      fpos_t pos;\n      fgetpos (stream, &pos);\n      ssize_t n = __getline (&line, &linelen, stream);\n      if (n < 0)\n\t{\n\t  if (! __feof_unlocked (stream))\n\t    status = ((*errnop = errno) == ENOMEM\n\t\t      ? NSS_STATUS_TRYAGAIN : NSS_STATUS_UNAVAIL);\n\t  break;\n\t}\n\n      struct group grp;\n      int res = _nss_files_parse_grent (line, &grp,\n\t\t\t\t\ttmpbuf.data, tmpbuf.length, errnop);\n      if (res == -1)\n\t{\n\t  if (!scratch_buffer_grow (&tmpbuf))\n\t    {\n\t      *errnop = ENOMEM;\n\t      status = NSS_STATUS_TRYAGAIN;\n\t      goto out;\n\t    }\n\t  /* Reread current line, the parser has clobbered it.  */\n\t  fsetpos (stream, &pos);\n\t  continue;\n\t}\n\n      if (res > 0 && grp.gr_gid != group)\n\tfor (char **m = grp.gr_mem; *m != NULL; ++m)\n\t  if (strcmp (*m, user) == 0)\n\t    {\n\t      /* Matches user.  Insert this group.  */\n\t      if (*start == *size)\n\t\t{\n\t\t  /* Need a bigger buffer.  */\n\t\t  if (limit > 0 && *size == limit)\n\t\t    /* We reached the maximum.  */\n\t\t    goto out;\n\n\t\t  long int newsize;\n\t\t  if (limit <= 0)\n\t\t    newsize = 2 * *size;\n\t\t  else\n\t\t    newsize = MIN (limit, 2 * *size);\n\n\t\t  gid_t *newgroups = realloc (groups,\n\t\t\t\t\t      newsize * sizeof (*groups));\n\t\t  if (newgroups == NULL)\n\t\t    {\n\t\t      *errnop = ENOMEM;\n\t\t      status = NSS_STATUS_TRYAGAIN;\n\t\t      goto out;\n\t\t    }\n\t\t  *groupsp = groups = newgroups;\n\t\t  *size = newsize;\n\t\t}\n\n\t      groups[*start] = grp.gr_gid;\n\t      *start += 1;\n\t      any = true;\n\n\t      break;\n\t    }\n    }\n\n out:\n  /* Free memory.  */\n  scratch_buffer_free (&tmpbuf);\n  free (line);\n\n  fclose (stream);\n\n  return status == NSS_STATUS_SUCCESS && !any ? NSS_STATUS_NOTFOUND : status;\n}",
    "_nss_netgroup_parseline(char **, struct __netgrent *, char *, int, int *)": "enum nss_status\n_nss_netgroup_parseline (char **cursor, struct __netgrent *result,\n\t\t\t char *buffer, size_t buflen, int *errnop)\n{\n  enum nss_status status;\n  const char *host, *user, *domain;\n  char *cp = *cursor;\n\n  /* Some sanity checks.  */\n  if (cp == NULL)\n    return NSS_STATUS_NOTFOUND;\n\n  /* First skip leading spaces.  */\n  while (isspace (*cp))\n    ++cp;\n\n  if (*cp != '(')\n    {\n      /* We have a list of other netgroups.  */\n      char *name = cp;\n\n      while (*cp != '\\0' && ! isspace (*cp))\n\t++cp;\n\n      if (name != cp)\n\t{\n\t  /* It is another netgroup name.  */\n\t  int last = *cp == '\\0';\n\n\t  result->type = group_val;\n\t  result->val.group = name;\n\t  *cp = '\\0';\n\t  if (! last)\n\t    ++cp;\n\t  *cursor = cp;\n\t  result->first = 0;\n\n\t  return NSS_STATUS_SUCCESS;\n\t}\n\n      return result->first ? NSS_STATUS_NOTFOUND : NSS_STATUS_RETURN;\n    }\n\n  /* Match host name.  */\n  host = ++cp;\n  while (*cp != ',')\n    if (*cp++ == '\\0')\n      return result->first ? NSS_STATUS_NOTFOUND : NSS_STATUS_RETURN;\n\n  /* Match user name.  */\n  user = ++cp;\n  while (*cp != ',')\n    if (*cp++ == '\\0')\n      return result->first ? NSS_STATUS_NOTFOUND : NSS_STATUS_RETURN;\n\n  /* Match domain name.  */\n  domain = ++cp;\n  while (*cp != ')')\n    if (*cp++ == '\\0')\n      return result->first ? NSS_STATUS_NOTFOUND : NSS_STATUS_RETURN;\n  ++cp;\n\n\n  /* When we got here we have found an entry.  Before we can copy it\n     to the private buffer we have to make sure it is big enough.  */\n  if (cp - host > buflen)\n    {\n      *errnop = ERANGE;\n      status = NSS_STATUS_TRYAGAIN;\n    }\n  else\n    {\n      memcpy (buffer, host, cp - host);\n      result->type = triple_val;\n\n      buffer[(user - host) - 1] = '\\0';\t/* Replace ',' with '\\0'.  */\n      result->val.triple.host = strip_whitespace (buffer);\n\n      buffer[(domain - host) - 1] = '\\0'; /* Replace ',' with '\\0'.  */\n      result->val.triple.user = strip_whitespace (buffer + (user - host));\n\n      buffer[(cp - host) - 1] = '\\0'; /* Replace ')' with '\\0'.  */\n      result->val.triple.domain = strip_whitespace (buffer + (domain - host));\n\n      status = NSS_STATUS_SUCCESS;\n\n      /* Remember where we stopped reading.  */\n      *cursor = cp;\n\n      result->first = 0;\n    }\n\n  return status;\n}",
    "_nss_files_parse_netent(char *, void *, struct parser_data *, int, int *)": "LINE_PARSER\n(\"#\",\n {\n   char *addr;\n   char *cp;\n   int n = 1;\n\n   STRING_FIELD (result->n_name, isspace, 1);\n\n   STRING_FIELD (addr, isspace, 1);\n   /* 'inet_network' does not add zeroes at the end if the network number\n      does not four byte values.  We add them ourselves if necessary.  */\n   cp = strchr (addr, '.');\n   if (cp != NULL)\n     {\n       ++n;\n       cp = strchr (cp + 1, '.');\n       if (cp != NULL)\n\t {\n\t   ++n;\n\t   cp = strchr (cp + 1, '.');\n\t   if (cp != NULL)\n\t     ++n;\n\t }\n     }\n   if (n < 4)\n     {\n       char *newp = (char *) alloca (strlen (addr) + (4 - n) * 2 + 1);\n       cp = stpcpy (newp, addr);\n       do\n\t {\n\t   *cp++ = '.';\n\t   *cp++ = '0';\n\t }\n       while (++n < 4);\n       *cp = '\\0';\n       addr = newp;\n     }\n   result->n_net = __inet_network (addr);\n   result->n_addrtype = AF_INET;\n\n })",
    "_nss_files_setnetent(int)": "enum nss_status\nCONCAT(_nss_files_set,ENTNAME) (int stayopen)\n{\n  return __nss_files_data_setent (CONCAT (nss_file_, ENTNAME), DATAFILE);\n}",
    "_nss_files_getnetent_r(struct netent *, char *, int, int *, int *)": "enum nss_status\nCONCAT(_nss_files_get,ENTNAME_r) (struct STRUCTURE *result, char *buffer,\n\t\t\t\t  size_t buflen, int *errnop H_ERRNO_PROTO)\n{\n  /* Return next entry in host file.  */\n\n  struct nss_files_per_file_data *data;\n  enum nss_status status = __nss_files_data_open (&data,\n\t\t\t\t\t\t  CONCAT (nss_file_, ENTNAME),\n\t\t\t\t\t\t  DATAFILE,\n\t\t\t\t\t\t  errnop, H_ERRNO_ARG_OR_NULL);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n\n  status = internal_getent (data->stream, result, buffer, buflen, errnop\n\t\t\t    H_ERRNO_ARG EXTRA_ARGS_VALUE);\n\n  __nss_files_data_put (data);\n  return status;\n}",
    "_nss_files_parse_protoent(char *, void *, struct parser_data *, int, int *)": "LINE_PARSER\n(\"#\",\n STRING_FIELD (result->p_name, isspace, 1);\n INT_FIELD (result->p_proto, isspace, 1, 10,);\n )",
    "_nss_files_setprotoent(int)": "enum nss_status\nCONCAT(_nss_files_set,ENTNAME) (int stayopen)\n{\n  return __nss_files_data_setent (CONCAT (nss_file_, ENTNAME), DATAFILE);\n}",
    "_nss_files_getprotoent_r(struct protoent *, char *, int, int *)": "enum nss_status\nCONCAT(_nss_files_get,ENTNAME_r) (struct STRUCTURE *result, char *buffer,\n\t\t\t\t  size_t buflen, int *errnop H_ERRNO_PROTO)\n{\n  /* Return next entry in host file.  */\n\n  struct nss_files_per_file_data *data;\n  enum nss_status status = __nss_files_data_open (&data,\n\t\t\t\t\t\t  CONCAT (nss_file_, ENTNAME),\n\t\t\t\t\t\t  DATAFILE,\n\t\t\t\t\t\t  errnop, H_ERRNO_ARG_OR_NULL);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n\n  status = internal_getent (data->stream, result, buffer, buflen, errnop\n\t\t\t    H_ERRNO_ARG EXTRA_ARGS_VALUE);\n\n  __nss_files_data_put (data);\n  return status;\n}",
    "_nss_files_setpwent(int)": "enum nss_status\nCONCAT(_nss_files_set,ENTNAME) (int stayopen)\n{\n  return __nss_files_data_setent (CONCAT (nss_file_, ENTNAME), DATAFILE);\n}",
    "_nss_files_getpwent_r(struct passwd *, char *, int, int *)": "enum nss_status\nCONCAT(_nss_files_get,ENTNAME_r) (struct STRUCTURE *result, char *buffer,\n\t\t\t\t  size_t buflen, int *errnop H_ERRNO_PROTO)\n{\n  /* Return next entry in host file.  */\n\n  struct nss_files_per_file_data *data;\n  enum nss_status status = __nss_files_data_open (&data,\n\t\t\t\t\t\t  CONCAT (nss_file_, ENTNAME),\n\t\t\t\t\t\t  DATAFILE,\n\t\t\t\t\t\t  errnop, H_ERRNO_ARG_OR_NULL);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n\n  status = internal_getent (data->stream, result, buffer, buflen, errnop\n\t\t\t    H_ERRNO_ARG EXTRA_ARGS_VALUE);\n\n  __nss_files_data_put (data);\n  return status;\n}",
    "_nss_files_parse_rpcent(char *, void *, struct parser_data *, int, int *)": "LINE_PARSER\n(\"#\",\n STRING_FIELD (result->r_name, isspace, 1);\n INT_FIELD (result->r_number, isspace, 1, 10,);\n )",
    "_nss_files_setrpcent(int)": "enum nss_status\nCONCAT(_nss_files_set,ENTNAME) (int stayopen)\n{\n  return __nss_files_data_setent (CONCAT (nss_file_, ENTNAME), DATAFILE);\n}",
    "_nss_files_getrpcent_r(struct rpcent *, char *, int, int *)": "enum nss_status\nCONCAT(_nss_files_get,ENTNAME_r) (struct STRUCTURE *result, char *buffer,\n\t\t\t\t  size_t buflen, int *errnop H_ERRNO_PROTO)\n{\n  /* Return next entry in host file.  */\n\n  struct nss_files_per_file_data *data;\n  enum nss_status status = __nss_files_data_open (&data,\n\t\t\t\t\t\t  CONCAT (nss_file_, ENTNAME),\n\t\t\t\t\t\t  DATAFILE,\n\t\t\t\t\t\t  errnop, H_ERRNO_ARG_OR_NULL);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n\n  status = internal_getent (data->stream, result, buffer, buflen, errnop\n\t\t\t    H_ERRNO_ARG EXTRA_ARGS_VALUE);\n\n  __nss_files_data_put (data);\n  return status;\n}",
    "_nss_files_parse_servent(char *, void *, struct parser_data *, int, int *)": "LINE_PARSER\n(\"#\",\n STRING_FIELD (result->s_name, isspace, 1);\n INT_FIELD (result->s_port, ISSLASH, 10, 0, htons);\n STRING_FIELD (result->s_proto, isspace, 1);\n )",
    "_nss_files_setservent(int)": "enum nss_status\nCONCAT(_nss_files_set,ENTNAME) (int stayopen)\n{\n  return __nss_files_data_setent (CONCAT (nss_file_, ENTNAME), DATAFILE);\n}",
    "_nss_files_getservent_r(struct servent *, char *, int, int *)": "enum nss_status\nCONCAT(_nss_files_get,ENTNAME_r) (struct STRUCTURE *result, char *buffer,\n\t\t\t\t  size_t buflen, int *errnop H_ERRNO_PROTO)\n{\n  /* Return next entry in host file.  */\n\n  struct nss_files_per_file_data *data;\n  enum nss_status status = __nss_files_data_open (&data,\n\t\t\t\t\t\t  CONCAT (nss_file_, ENTNAME),\n\t\t\t\t\t\t  DATAFILE,\n\t\t\t\t\t\t  errnop, H_ERRNO_ARG_OR_NULL);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n\n  status = internal_getent (data->stream, result, buffer, buflen, errnop\n\t\t\t    H_ERRNO_ARG EXTRA_ARGS_VALUE);\n\n  __nss_files_data_put (data);\n  return status;\n}",
    "_nss_files_setsgent(int)": "enum nss_status\nCONCAT(_nss_files_set,ENTNAME) (int stayopen)\n{\n  return __nss_files_data_setent (CONCAT (nss_file_, ENTNAME), DATAFILE);\n}",
    "_nss_files_getsgent_r(struct sgrp *, char *, int, int *)": "enum nss_status\nCONCAT(_nss_files_get,ENTNAME_r) (struct STRUCTURE *result, char *buffer,\n\t\t\t\t  size_t buflen, int *errnop H_ERRNO_PROTO)\n{\n  /* Return next entry in host file.  */\n\n  struct nss_files_per_file_data *data;\n  enum nss_status status = __nss_files_data_open (&data,\n\t\t\t\t\t\t  CONCAT (nss_file_, ENTNAME),\n\t\t\t\t\t\t  DATAFILE,\n\t\t\t\t\t\t  errnop, H_ERRNO_ARG_OR_NULL);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n\n  status = internal_getent (data->stream, result, buffer, buflen, errnop\n\t\t\t    H_ERRNO_ARG EXTRA_ARGS_VALUE);\n\n  __nss_files_data_put (data);\n  return status;\n}",
    "_nss_files_setspent(int)": "enum nss_status\nCONCAT(_nss_files_set,ENTNAME) (int stayopen)\n{\n  return __nss_files_data_setent (CONCAT (nss_file_, ENTNAME), DATAFILE);\n}",
    "_nss_files_getspent_r(struct spwd *, char *, int, int *)": "enum nss_status\nCONCAT(_nss_files_get,ENTNAME_r) (struct STRUCTURE *result, char *buffer,\n\t\t\t\t  size_t buflen, int *errnop H_ERRNO_PROTO)\n{\n  /* Return next entry in host file.  */\n\n  struct nss_files_per_file_data *data;\n  enum nss_status status = __nss_files_data_open (&data,\n\t\t\t\t\t\t  CONCAT (nss_file_, ENTNAME),\n\t\t\t\t\t\t  DATAFILE,\n\t\t\t\t\t\t  errnop, H_ERRNO_ARG_OR_NULL);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n\n  status = internal_getent (data->stream, result, buffer, buflen, errnop\n\t\t\t    H_ERRNO_ARG EXTRA_ARGS_VALUE);\n\n  __nss_files_data_put (data);\n  return status;\n}",
    "_Fork()": "pid_t\n_Fork (void)\n{\n  pid_t pid = arch_fork (&THREAD_SELF->tid);\n  if (pid == 0)\n    {\n      struct pthread *self = THREAD_SELF;\n\n      /* Initialize the robust mutex list setting in the kernel which has\n\t been reset during the fork.  We do not check for errors because if\n\t it fails here, it must have failed at process startup as well and\n\t nobody could have used robust mutexes.\n\t Before we do that, we have to clear the list of robust mutexes\n\t because we do not inherit ownership of mutexes from the parent.\n\t We do not have to set self->robust_head.futex_offset since we do\n\t inherit the correct value from the parent.  We do not need to clear\n\t the pending operation because it must have been zero when fork was\n\t called.  */\n#if __PTHREAD_MUTEX_HAVE_PREV\n      self->robust_prev = &self->robust_head;\n#endif\n      self->robust_head.list = &self->robust_head;\n      INTERNAL_SYSCALL_CALL (set_robust_list, &self->robust_head,\n\t\t\t     sizeof (struct robust_list_head));\n    }\n  return pid;\n}",
    "_exit(int)": "void\n_exit (int status)\n{\n  while (1)\n    {\n      INLINE_SYSCALL (exit_group, 1, status);\n\n#ifdef ABORT_INSTRUCTION\n      ABORT_INSTRUCTION;\n#endif\n    }\n}",
    "alarm(unsigned int)": "unsigned int\nalarm (unsigned int seconds)\n{\n  struct itimerval old, new;\n  unsigned int retval;\n\n  new.it_interval.tv_usec = 0;\n  new.it_interval.tv_sec = 0;\n  new.it_value.tv_usec = 0;\n  new.it_value.tv_sec = (long int) seconds;\n  if (__setitimer (ITIMER_REAL, &new, &old) < 0)\n    return 0;\n\n  retval = old.it_value.tv_sec;\n  /* Round to the nearest second, but never report zero seconds when\n     the alarm is still set.  */\n  if (old.it_value.tv_usec >= 500000\n      || (retval == 0 && old.it_value.tv_usec > 0))\n    ++retval;\n  return retval;\n}",
    "execl(const char *, const char *, ...)": "int\nexecl (const char *path, const char *arg, ...)\n{\n  ptrdiff_t argc;\n  va_list ap;\n  va_start (ap, arg);\n  for (argc = 1; va_arg (ap, const char *); argc++)\n    {\n      if (argc == INT_MAX)\n\t{\n\t  va_end (ap);\n\t  errno = E2BIG;\n\t  return -1;\n\t}\n    }\n  va_end (ap);\n\n  /* Avoid dynamic memory allocation due two main issues:\n     1. The function should be async-signal-safe and a running on a signal\n        handler with a fail outcome might lead to malloc bad state.\n     2. It might be used in a vfork/clone(VFORK) scenario where using\n        malloc also might lead to internal bad state.  */\n  ptrdiff_t i;\n  char *argv[argc + 1];\n  va_start (ap, arg);\n  argv[0] = (char *) arg;\n  for (i = 1; i <= argc; i++)\n    argv[i] = va_arg (ap, char *);\n  va_end (ap);\n\n  return __execve (path, argv, __environ);\n}",
    "execle(const char *, const char *, ...)": "int\nexecle (const char *path, const char *arg, ...)\n{\n  ptrdiff_t argc;\n  va_list ap;\n  va_start (ap, arg);\n  for (argc = 1; va_arg (ap, const char *); argc++)\n    {\n      if (argc == INT_MAX)\n\t{\n\t  va_end (ap);\n\t  errno = E2BIG;\n\t  return -1;\n\t}\n    }\n  va_end (ap);\n\n  /* Avoid dynamic memory allocation due two main issues:\n     1. The function should be async-signal-safe and a running on a signal\n        handler with a fail outcome might lead to malloc bad state.\n     2. It might be used in a vfork/clone(VFORK) scenario where using\n        malloc also might lead to internal bad state.  */\n  ptrdiff_t i;\n  char *argv[argc + 1];\n  char **envp;\n  va_start (ap, arg);\n  argv[0] = (char *) arg;\n  for (i = 1; i <= argc; i++)\n    argv[i] = va_arg (ap, char *);\n  envp = va_arg (ap, char **);\n  va_end (ap);\n\n  return __execve (path, argv, envp);\n}",
    "execlp(const char *, const char *, ...)": "int\nexeclp (const char *file, const char *arg, ...)\n{\n  ptrdiff_t argc;\n  va_list ap;\n  va_start (ap, arg);\n  for (argc = 1; va_arg (ap, const char *); argc++)\n    {\n      if (argc == INT_MAX)\n\t{\n\t  va_end (ap);\n\t  errno = E2BIG;\n\t  return -1;\n\t}\n    }\n  va_end (ap);\n\n  /* Although posix does not state execlp as an async-safe function\n     it can not use malloc to allocate the arguments since it might\n     be used in a vfork scenario and it may lead to malloc internal\n     bad state.  */\n  ptrdiff_t i;\n  char *argv[argc + 1];\n  va_start (ap, arg);\n  argv[0] = (char *) arg;\n  for (i = 1; i <= argc; i++)\n    argv[i] = va_arg (ap, char *);\n  va_end (ap);\n\n  return __execvpe (file, argv, __environ);\n}",
    "execv(const char *, char *const *)": "int\nexecv (const char *path, char *const argv[])\n{\n  return __execve (path, argv, __environ);\n}",
    "execvp(const char *, char *const *)": "int\nexecvp (const char *file, char *const argv[])\n{\n  return __execvpe (file, argv, __environ);\n}",
    "fexecve(int, char *const *, char *const *)": "int\nfexecve (int fd, char *const argv[], char *const envp[])\n{\n  if (fd < 0 || argv == NULL || envp == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n#ifdef __NR_execveat\n  /* Avoid implicit array coercion in syscall macros.  */\n  INLINE_SYSCALL (execveat, 5, fd, \"\", &argv[0], &envp[0], AT_EMPTY_PATH);\n# ifndef __ASSUME_EXECVEAT\n  if (errno != ENOSYS)\n    return -1;\n# endif\n#endif\n\n#ifndef __ASSUME_EXECVEAT\n  /* We use the /proc filesystem to get the information.  If it is not\n     mounted we fail.  We do not need the return value.  */\n  struct fd_to_filename filename;\n  __execve (__fd_to_filename (fd, &filename), argv, envp);\n\n  int save = errno;\n\n  /* We come here only if the 'execve' call fails.  Determine whether\n     /proc is mounted.  If not we return ENOSYS.  */\n  struct __stat64_t64 st;\n  if (__stat64_time64 (\"/proc/self/fd\", &st) != 0 && errno == ENOENT)\n    save = ENOSYS;\n\n  __set_errno (save);\n#endif\n\n  return -1;\n}",
    "fnmatch(const char *, const char *, int)": "int\nfnmatch (const char *pattern, const char *string, int flags)\n{\n  if (__glibc_unlikely (MB_CUR_MAX != 1))\n    {\n      size_t n;\n      struct scratch_buffer wpattern;\n      scratch_buffer_init (&wpattern);\n      struct scratch_buffer wstring;\n      scratch_buffer_init (&wstring);\n      int r;\n\n      /* Convert the strings into wide characters.  Any conversion issue\n         fallback to the ascii version.  */\n      r = fnmatch_convert_to_wide (pattern, &wpattern, &n);\n      if (r == 0)\n        {\n          r = fnmatch_convert_to_wide (string, &wstring, &n);\n          if (r == 0)\n            r = internal_fnwmatch (wpattern.data, wstring.data,\n                                   (wchar_t *) wstring.data + n,\n                                   flags & FNM_PERIOD, flags, NULL);\n        }\n\n      scratch_buffer_free (&wstring);\n      scratch_buffer_free (&wpattern);\n\n      if (r == -2 || r == 0)\n        return r;\n    }\n\n  return internal_fnmatch (pattern, string, string + strlen (string),\n                           flags & FNM_PERIOD, flags, NULL);\n}",
    "__libc_fork()": "pid_t\n__libc_fork (void)\n{\n  /* Determine if we are running multiple threads.  We skip some fork\n     handlers in the single-thread case, to make fork safer to use in\n     signal handlers.  Although POSIX has dropped async-signal-safe\n     requirement for fork (Austin Group tracker issue #62) this is\n     best effort to make is async-signal-safe at least for single-thread\n     case.  */\n  bool multiple_threads = !SINGLE_THREAD_P;\n  uint64_t lastrun;\n\n  lastrun = __run_prefork_handlers (multiple_threads);\n\n  struct nss_database_data nss_database_data;\n\n  /* If we are not running multiple threads, we do not have to\n     preserve lock state.  If fork runs from a signal handler, only\n     async-signal-safe functions can be used in the child.  These data\n     structures are only used by unsafe functions, so their state does\n     not matter if fork was called from a signal handler.  */\n  if (multiple_threads)\n    {\n      call_function_static_weak (__nss_database_fork_prepare_parent,\n\t\t\t\t &nss_database_data);\n\n      _IO_list_lock ();\n\n      /* Acquire malloc locks.  This needs to come last because fork\n\t handlers may use malloc, and the libio list lock has an\n\t indirect malloc dependency as well (via the getdelim\n\t function).  */\n      call_function_static_weak (__malloc_fork_lock_parent);\n    }\n\n  pid_t pid = _Fork ();\n\n  if (pid == 0)\n    {\n      fork_system_setup ();\n\n      /* Reset the lock state in the multi-threaded case.  */\n      if (multiple_threads)\n\t{\n\t  __libc_unwind_link_after_fork ();\n\n\t  fork_system_setup_after_fork ();\n\n\t  /* Release malloc locks.  */\n\t  call_function_static_weak (__malloc_fork_unlock_child);\n\n\t  /* Reset the file list.  These are recursive mutexes.  */\n\t  fresetlockfiles ();\n\n\t  /* Reset locks in the I/O code.  */\n\t  _IO_list_resetlock ();\n\n\t  call_function_static_weak (__nss_database_fork_subprocess,\n\t\t\t\t     &nss_database_data);\n\t}\n\n      /* Reset the lock the dynamic loader uses to protect its data.  */\n      __rtld_lock_initialize (GL(dl_load_lock));\n\n      /* Reset the lock protecting dynamic TLS related data.  */\n      __rtld_lock_initialize (GL(dl_load_tls_lock));\n\n      reclaim_stacks ();\n\n      /* Run the handlers registered for the child.  */\n      __run_postfork_handlers (atfork_run_child, multiple_threads, lastrun);\n    }\n  else\n    {\n      /* If _Fork failed, preserve its errno value.  */\n      int save_errno = errno;\n\n      /* Release acquired locks in the multi-threaded case.  */\n      if (multiple_threads)\n\t{\n\t  /* Release malloc locks, parent process variant.  */\n\t  call_function_static_weak (__malloc_fork_unlock_parent);\n\n\t  /* We execute this even if the 'fork' call failed.  */\n\t  _IO_list_unlock ();\n\t}\n\n      /* Run the handlers registered for the parent.  */\n      __run_postfork_handlers (atfork_run_parent, multiple_threads, lastrun);\n\n      if (pid < 0)\n\t__set_errno (save_errno);\n    }\n\n  return pid;\n}",
    "gai_strerror(int)": "const char *\ngai_strerror (int code)\n{\n  const char *result = \"Unknown error\";\n  for (size_t i = 0; i < sizeof (msgidx) / sizeof (msgidx[0]); ++i)\n    if (msgidx[i].code == code)\n      {\n\tresult = msgstr.str + msgidx[i].idx;\n\tbreak;\n      }\n\n  return _(result);\n}",
    "getopt(int, char *const *, const char *)": "GETOPT_ENTRY(getopt, 1)",
    "getopt_long(int, char *const *, const char *, const struct option *, int *)": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n\t     const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n\t\t\t   opt_index, 0, 0);\n}",
    "getopt_long_only(int, char *const *, const char *, const struct option *, int *)": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n\t\t  const char *options,\n\t\t  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n\t\t\t   opt_index, 1, 0);\n}",
    "__getpgid(pid_t)": "int\n__getpgid (pid_t pid)\n{\n  error_t err;\n  pid_t pgrp;\n\n  if (pid == 0)\n    {\n      /* Assume atomic word fetch and store, so don't lock _hurd_pid_lock.  */\n      pgrp = _hurd_pgrp;\n      err = 0;\n    }\n  else\n    err = __USEPORT (PROC, __proc_getpgrp (port, pid, &pgrp));\n\n  return err ? __hurd_fail (err) : pgrp;\n}",
    "getpgrp()": "pid_t\ngetpgrp (void)\n{\n  return __getpgid (0);\n}",
    "__getpid()": "pid_t\n__getpid (void)\n{\n  /* Assumes atomic word fetch and store, so doesn't lock _hurd_pid_lock.  */\n  return _hurd_pid;\n}",
    "getsid(pid_t)": "pid_t\ngetsid (pid_t pid)\n{\n  error_t err;\n  pid_t sid;\n\n  if (pid == 0)\n    pid = _hurd_pid;\n\n  err = __USEPORT (PROC, __proc_getsid (port, pid, &sid));\n  if (err)\n    return (pid_t) __hurd_fail (err);\n  return sid;\n}",
    "glob(const char *, int, int (*)(const char *, int), glob_t *)": "int\nGLOB_ATTRIBUTE\n__glob (const char *pattern, int flags, int (*errfunc) (const char *, int),\n        glob_t *pglob)\n{\n  const char *filename;\n  char *dirname = NULL;\n  size_t dirlen;\n  int status;\n  size_t oldcount;\n  int meta;\n  int dirname_modified;\n  int malloc_dirname = 0;\n  glob_t dirs;\n  int retval = 0;\n  size_t alloca_used = 0;\n\n  if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  /* POSIX requires all slashes to be matched.  This means that with\n     a trailing slash we must match only directories.  */\n  if (pattern[0] && pattern[strlen (pattern) - 1] == '/')\n    flags |= GLOB_ONLYDIR;\n\n  if (!(flags & GLOB_DOOFFS))\n    /* Have to do this so 'globfree' knows where to start freeing.  It\n       also makes all the code that uses gl_offs simpler. */\n    pglob->gl_offs = 0;\n\n  if (!(flags & GLOB_APPEND))\n    {\n      pglob->gl_pathc = 0;\n      if (!(flags & GLOB_DOOFFS))\n        pglob->gl_pathv = NULL;\n      else\n        {\n          size_t i;\n\n          if (pglob->gl_offs >= ~((size_t) 0) / sizeof (char *))\n            return GLOB_NOSPACE;\n\n          pglob->gl_pathv = (char **) malloc ((pglob->gl_offs + 1)\n                                              * sizeof (char *));\n          if (pglob->gl_pathv == NULL)\n            return GLOB_NOSPACE;\n\n          for (i = 0; i <= pglob->gl_offs; ++i)\n            pglob->gl_pathv[i] = NULL;\n        }\n    }\n\n  if (flags & GLOB_BRACE)\n    {\n      const char *begin;\n\n      if (flags & GLOB_NOESCAPE)\n        begin = strchr (pattern, '{');\n      else\n        {\n          begin = pattern;\n          while (1)\n            {\n              if (*begin == '\\0')\n                {\n                  begin = NULL;\n                  break;\n                }\n\n              if (*begin == '\\\\' && begin[1] != '\\0')\n                ++begin;\n              else if (*begin == '{')\n                break;\n\n              ++begin;\n            }\n        }\n\n      if (begin != NULL)\n        {\n          /* Allocate working buffer large enough for our work.  Note that\n             we have at least an opening and closing brace.  */\n          size_t firstc;\n          char *alt_start;\n          const char *p;\n          const char *next;\n          const char *rest;\n          size_t rest_len;\n          char *onealt;\n          size_t pattern_len = strlen (pattern) - 1;\n          int alloca_onealt = glob_use_alloca (alloca_used, pattern_len);\n          if (alloca_onealt)\n            onealt = alloca_account (pattern_len, alloca_used);\n          else\n            {\n              onealt = malloc (pattern_len);\n              if (onealt == NULL)\n                return GLOB_NOSPACE;\n            }\n\n          /* We know the prefix for all sub-patterns.  */\n          alt_start = mempcpy (onealt, pattern, begin - pattern);\n\n          /* Find the first sub-pattern and at the same time find the\n             rest after the closing brace.  */\n          next = next_brace_sub (begin + 1, flags);\n          if (next == NULL)\n            {\n              /* It is an invalid expression.  */\n            illegal_brace:\n              if (__glibc_unlikely (!alloca_onealt))\n                free (onealt);\n              flags &= ~GLOB_BRACE;\n              goto no_brace;\n            }\n\n          /* Now find the end of the whole brace expression.  */\n          rest = next;\n          while (*rest != '}')\n            {\n              rest = next_brace_sub (rest + 1, flags);\n              if (rest == NULL)\n                /* It is an illegal expression.  */\n                goto illegal_brace;\n            }\n          /* Please note that we now can be sure the brace expression\n             is well-formed.  */\n          rest_len = strlen (++rest) + 1;\n\n          /* We have a brace expression.  BEGIN points to the opening {,\n             NEXT points past the terminator of the first element, and END\n             points past the final }.  We will accumulate result names from\n             recursive runs for each brace alternative in the buffer using\n             GLOB_APPEND.  */\n          firstc = pglob->gl_pathc;\n\n          p = begin + 1;\n          while (1)\n            {\n              int result;\n\n              /* Construct the new glob expression.  */\n              mempcpy (mempcpy (alt_start, p, next - p), rest, rest_len);\n\n              result = __glob (onealt,\n                               ((flags & ~(GLOB_NOCHECK | GLOB_NOMAGIC))\n                                | GLOB_APPEND),\n                               errfunc, pglob);\n\n              /* If we got an error, return it.  */\n              if (result && result != GLOB_NOMATCH)\n                {\n                  if (__glibc_unlikely (!alloca_onealt))\n                    free (onealt);\n                  if (!(flags & GLOB_APPEND))\n                    {\n                      globfree (pglob);\n                      pglob->gl_pathc = 0;\n                    }\n                  return result;\n                }\n\n              if (*next == '}')\n                /* We saw the last entry.  */\n                break;\n\n              p = next + 1;\n              next = next_brace_sub (p, flags);\n              assert (next != NULL);\n            }\n\n          if (__glibc_unlikely (!alloca_onealt))\n            free (onealt);\n\n          if (pglob->gl_pathc != firstc)\n            /* We found some entries.  */\n            return 0;\n          else if (!(flags & (GLOB_NOCHECK|GLOB_NOMAGIC)))\n            return GLOB_NOMATCH;\n        }\n    }\n\n no_brace:\n  oldcount = pglob->gl_pathc + pglob->gl_offs;\n\n  /* Find the filename.  */\n  filename = strrchr (pattern, '/');\n\n#if defined __MSDOS__ || defined WINDOWS32\n  /* The case of \"d:pattern\".  Since ':' is not allowed in\n     file names, we can safely assume that wherever it\n     happens in pattern, it signals the filename part.  This\n     is so we could some day support patterns like \"[a-z]:foo\".  */\n  if (filename == NULL)\n    filename = strchr (pattern, ':');\n#endif /* __MSDOS__ || WINDOWS32 */\n\n  dirname_modified = 0;\n  if (filename == NULL)\n    {\n      /* This can mean two things: a simple name or \"~name\".  The latter\n         case is nothing but a notation for a directory.  */\n      if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && pattern[0] == '~')\n        {\n          dirname = (char *) pattern;\n          dirlen = strlen (pattern);\n\n          /* Set FILENAME to NULL as a special flag.  This is ugly but\n             other solutions would require much more code.  We test for\n             this special case below.  */\n          filename = NULL;\n        }\n      else\n        {\n          if (__glibc_unlikely (pattern[0] == '\\0'))\n            {\n              dirs.gl_pathv = NULL;\n              goto no_matches;\n            }\n\n          filename = pattern;\n          dirname = (char *) \".\";\n          dirlen = 0;\n        }\n    }\n  else if (filename == pattern\n           || (filename == pattern + 1 && pattern[0] == '\\\\'\n               && (flags & GLOB_NOESCAPE) == 0))\n    {\n      /* \"/pattern\" or \"\\\\/pattern\".  */\n      dirname = (char *) \"/\";\n      dirlen = 1;\n      ++filename;\n    }\n  else\n    {\n      char *newp;\n      dirlen = filename - pattern;\n#if defined __MSDOS__ || defined WINDOWS32\n      if (*filename == ':'\n          || (filename > pattern + 1 && filename[-1] == ':'))\n        {\n          char *drive_spec;\n\n          ++dirlen;\n          drive_spec = __alloca (dirlen + 1);\n          *((char *) mempcpy (drive_spec, pattern, dirlen)) = '\\0';\n          /* For now, disallow wildcards in the drive spec, to\n             prevent infinite recursion in glob.  */\n          if (__glob_pattern_p (drive_spec, !(flags & GLOB_NOESCAPE)))\n            return GLOB_NOMATCH;\n          /* If this is \"d:pattern\", we need to copy ':' to DIRNAME\n             as well.  If it's \"d:/pattern\", don't remove the slash\n             from \"d:/\", since \"d:\" and \"d:/\" are not the same.*/\n        }\n#endif\n\n      if (glob_use_alloca (alloca_used, dirlen + 1))\n        newp = alloca_account (dirlen + 1, alloca_used);\n      else\n        {\n          newp = malloc (dirlen + 1);\n          if (newp == NULL)\n            return GLOB_NOSPACE;\n          malloc_dirname = 1;\n        }\n      *((char *) mempcpy (newp, pattern, dirlen)) = '\\0';\n      dirname = newp;\n      ++filename;\n\n#if defined __MSDOS__ || defined WINDOWS32\n      bool drive_root = (dirlen > 1\n                         && (dirname[dirlen - 1] == ':'\n                             || (dirlen > 2 && dirname[dirlen - 2] == ':'\n                                 && dirname[dirlen - 1] == '/')));\n#else\n      bool drive_root = false;\n#endif\n\n      if (filename[0] == '\\0' && dirlen > 1 && !drive_root)\n        /* \"pattern/\".  Expand \"pattern\", appending slashes.  */\n        {\n          int orig_flags = flags;\n          if (!(flags & GLOB_NOESCAPE) && dirname[dirlen - 1] == '\\\\')\n            {\n              /* \"pattern\\\\/\".  Remove the final backslash if it hasn't\n                 been quoted.  */\n              char *p = (char *) &dirname[dirlen - 1];\n\n              while (p > dirname && p[-1] == '\\\\') --p;\n              if ((&dirname[dirlen] - p) & 1)\n                {\n                  *(char *) &dirname[--dirlen] = '\\0';\n                  flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n                }\n            }\n          int val = __glob (dirname, flags | GLOB_MARK, errfunc, pglob);\n          if (val == 0)\n            pglob->gl_flags = ((pglob->gl_flags & ~GLOB_MARK)\n                               | (flags & GLOB_MARK));\n          else if (val == GLOB_NOMATCH && flags != orig_flags)\n            {\n              /* Make sure globfree (&dirs); is a nop.  */\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              oldcount = pglob->gl_pathc + pglob->gl_offs;\n              goto no_matches;\n            }\n          retval = val;\n          goto out;\n        }\n    }\n\n  if ((flags & (GLOB_TILDE|GLOB_TILDE_CHECK)) && dirname[0] == '~')\n    {\n      if (dirname[1] == '\\0' || dirname[1] == '/'\n          || (!(flags & GLOB_NOESCAPE) && dirname[1] == '\\\\'\n              && (dirname[2] == '\\0' || dirname[2] == '/')))\n        {\n          /* Look up home directory.  */\n          char *home_dir = getenv (\"HOME\");\n          int malloc_home_dir = 0;\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n#ifdef WINDOWS32\n              /* Windows NT defines HOMEDRIVE and HOMEPATH.  But give\n                 preference to HOME, because the user can change HOME.  */\n              const char *home_drive = getenv (\"HOMEDRIVE\");\n              const char *home_path = getenv (\"HOMEPATH\");\n\n              if (home_drive != NULL && home_path != NULL)\n                {\n                  size_t home_drive_len = strlen (home_drive);\n                  size_t home_path_len = strlen (home_path);\n                  char *mem = alloca (home_drive_len + home_path_len + 1);\n\n                  memcpy (mem, home_drive, home_drive_len);\n                  memcpy (mem + home_drive_len, home_path, home_path_len + 1);\n                  home_dir = mem;\n                }\n              else\n                home_dir = \"c:/users/default\"; /* poor default */\n#else\n              int err;\n              struct passwd *p;\n              struct passwd pwbuf;\n              struct scratch_buffer s;\n              scratch_buffer_init (&s);\n              while (true)\n                {\n                  p = NULL;\n                  err = __getlogin_r (s.data, s.length);\n                  if (err == 0)\n                    {\n# if defined HAVE_GETPWNAM_R || defined _LIBC\n                      size_t ssize = strlen (s.data) + 1;\n                      char *sdata = s.data;\n                      err = getpwnam_r (sdata, &pwbuf, sdata + ssize,\n                                        s.length - ssize, &p);\n# else\n                      p = getpwnam (s.data);\n                      if (p == NULL)\n                        err = errno;\n# endif\n                    }\n                  if (err != ERANGE)\n                    break;\n                  if (!scratch_buffer_grow (&s))\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n              if (err == 0)\n                {\n                  home_dir = strdup (p->pw_dir);\n                  malloc_home_dir = 1;\n                }\n              scratch_buffer_free (&s);\n              if (err == 0 && home_dir == NULL)\n                {\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n#endif /* WINDOWS32 */\n            }\n          if (home_dir == NULL || home_dir[0] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n              if (flags & GLOB_TILDE_CHECK)\n                {\n                  retval = GLOB_NOMATCH;\n                  goto out;\n                }\n              else\n                {\n                  home_dir = (char *) \"~\"; /* No luck.  */\n                  malloc_home_dir = 0;\n                }\n            }\n          /* Now construct the full directory.  */\n          if (dirname[1] == '\\0')\n            {\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n\n              dirname = home_dir;\n              dirlen = strlen (dirname);\n              malloc_dirname = malloc_home_dir;\n            }\n          else\n            {\n              char *newp;\n              size_t home_len = strlen (home_dir);\n              int use_alloca = glob_use_alloca (alloca_used, home_len + dirlen);\n              if (use_alloca)\n                newp = alloca_account (home_len + dirlen, alloca_used);\n              else\n                {\n                  newp = malloc (home_len + dirlen);\n                  if (newp == NULL)\n                    {\n                      if (__glibc_unlikely (malloc_home_dir))\n                        free (home_dir);\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                }\n\n              mempcpy (mempcpy (newp, home_dir, home_len),\n                       &dirname[1], dirlen);\n\n              if (__glibc_unlikely (malloc_dirname))\n                free (dirname);\n\n              dirname = newp;\n              dirlen += home_len - 1;\n              malloc_dirname = !use_alloca;\n\n              if (__glibc_unlikely (malloc_home_dir))\n                free (home_dir);\n            }\n          dirname_modified = 1;\n        }\n      else\n        {\n#ifndef WINDOWS32\n          /* Recognize ~user as a shorthand for the specified user's home\n             directory.  */\n          char *end_name = strchr (dirname, '/');\n          char *user_name;\n          int malloc_user_name = 0;\n          char *unescape = NULL;\n\n          if (!(flags & GLOB_NOESCAPE))\n            {\n              if (end_name == NULL)\n                {\n                  unescape = strchr (dirname, '\\\\');\n                  if (unescape)\n                    end_name = strchr (unescape, '\\0');\n                }\n              else\n                unescape = memchr (dirname, '\\\\', end_name - dirname);\n            }\n          if (end_name == NULL)\n            user_name = dirname + 1;\n          else\n            {\n              char *newp;\n              if (glob_use_alloca (alloca_used, end_name - dirname))\n                newp = alloca_account (end_name - dirname, alloca_used);\n              else\n                {\n                  newp = malloc (end_name - dirname);\n                  if (newp == NULL)\n                    {\n                      retval = GLOB_NOSPACE;\n                      goto out;\n                    }\n                  malloc_user_name = 1;\n                }\n              if (unescape != NULL)\n                {\n                  char *p = mempcpy (newp, dirname + 1,\n                                     unescape - dirname - 1);\n                  char *q = unescape;\n                  while (q != end_name)\n                    {\n                      if (*q == '\\\\')\n                        {\n                          if (q + 1 == end_name)\n                            {\n                              /* \"~fo\\\\o\\\\\" unescape to user_name \"foo\\\\\",\n                                 but \"~fo\\\\o\\\\/\" unescape to user_name\n                                 \"foo\".  */\n                              if (filename == NULL)\n                                *p++ = '\\\\';\n                              break;\n                            }\n                          ++q;\n                        }\n                      *p++ = *q++;\n                    }\n                  *p = '\\0';\n                }\n              else\n                *((char *) mempcpy (newp, dirname + 1, end_name - dirname - 1))\n                  = '\\0';\n              user_name = newp;\n            }\n\n          /* Look up specific user's home directory.  */\n          {\n            struct passwd *p;\n            struct scratch_buffer pwtmpbuf;\n            scratch_buffer_init (&pwtmpbuf);\n\n#  if defined HAVE_GETPWNAM_R || defined _LIBC\n            struct passwd pwbuf;\n\n            while (getpwnam_r (user_name, &pwbuf,\n                               pwtmpbuf.data, pwtmpbuf.length, &p)\n                   == ERANGE)\n              {\n                if (!scratch_buffer_grow (&pwtmpbuf))\n                  {\n                    retval = GLOB_NOSPACE;\n                    goto out;\n                  }\n              }\n#  else\n            p = getpwnam (user_name);\n#  endif\n\n            if (__glibc_unlikely (malloc_user_name))\n              free (user_name);\n\n            /* If we found a home directory use this.  */\n            if (p != NULL)\n              {\n                size_t home_len = strlen (p->pw_dir);\n                size_t rest_len = end_name == NULL ? 0 : strlen (end_name);\n                /* dirname contains end_name; we can't free it now.  */\n                char *prev_dirname =\n                  (__glibc_unlikely (malloc_dirname) ? dirname : NULL);\n                char *d;\n\n                malloc_dirname = 0;\n\n                if (glob_use_alloca (alloca_used, home_len + rest_len + 1))\n                  dirname = alloca_account (home_len + rest_len + 1,\n                                            alloca_used);\n                else\n                  {\n                    dirname = malloc (home_len + rest_len + 1);\n                    if (dirname == NULL)\n                      {\n                        free (prev_dirname);\n                        scratch_buffer_free (&pwtmpbuf);\n                        retval = GLOB_NOSPACE;\n                        goto out;\n                      }\n                    malloc_dirname = 1;\n                  }\n                d = mempcpy (dirname, p->pw_dir, home_len);\n                if (end_name != NULL)\n                  d = mempcpy (d, end_name, rest_len);\n                *d = '\\0';\n\n                free (prev_dirname);\n\n                dirlen = home_len + rest_len;\n                dirname_modified = 1;\n              }\n            else\n              {\n                if (flags & GLOB_TILDE_CHECK)\n                  {\n                    /* We have to regard it as an error if we cannot find the\n                       home directory.  */\n                    retval = GLOB_NOMATCH;\n                    goto out;\n                  }\n              }\n            scratch_buffer_free (&pwtmpbuf);\n          }\n#else /* WINDOWS32 */\n          /* On native Windows, access to a user's home directory\n             (via GetUserProfileDirectory) or to a user's environment\n             variables (via ExpandEnvironmentStringsForUser) requires\n             the credentials of the user.  Therefore we cannot support\n             the ~user syntax on this platform.\n             Handling ~user specially (and treat it like plain ~) if\n             user is getenv (\"USERNAME\") would not be a good idea,\n             since it would make people think that ~user is supported\n             in general.  */\n          if (flags & GLOB_TILDE_CHECK)\n            {\n              retval = GLOB_NOMATCH;\n              goto out;\n            }\n#endif /* WINDOWS32 */\n        }\n    }\n\n  /* Now test whether we looked for \"~\" or \"~NAME\".  In this case we\n     can give the answer now.  */\n  if (filename == NULL)\n    {\n      size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n      char **new_gl_pathv;\n\n      if (newcount > SIZE_MAX / sizeof (char *) - 2)\n        {\n        nospace:\n          free (pglob->gl_pathv);\n          pglob->gl_pathv = NULL;\n          pglob->gl_pathc = 0;\n          retval = GLOB_NOSPACE;\n          goto out;\n        }\n\n      new_gl_pathv = realloc (pglob->gl_pathv,\n                              (newcount + 2) * sizeof (char *));\n      if (new_gl_pathv == NULL)\n        goto nospace;\n      pglob->gl_pathv = new_gl_pathv;\n\n      if (flags & GLOB_MARK && is_dir (dirname, flags, pglob))\n        {\n          char *p;\n          pglob->gl_pathv[newcount] = malloc (dirlen + 2);\n          if (pglob->gl_pathv[newcount] == NULL)\n            goto nospace;\n          p = mempcpy (pglob->gl_pathv[newcount], dirname, dirlen);\n          p[0] = '/';\n          p[1] = '\\0';\n          if (__glibc_unlikely (malloc_dirname))\n            free (dirname);\n        }\n      else\n        {\n          if (__glibc_unlikely (malloc_dirname))\n            pglob->gl_pathv[newcount] = dirname;\n          else\n            {\n              pglob->gl_pathv[newcount] = strdup (dirname);\n              if (pglob->gl_pathv[newcount] == NULL)\n                goto nospace;\n            }\n        }\n      pglob->gl_pathv[++newcount] = NULL;\n      ++pglob->gl_pathc;\n      pglob->gl_flags = flags;\n\n      return 0;\n    }\n\n  meta = __glob_pattern_type (dirname, !(flags & GLOB_NOESCAPE));\n  /* meta is 1 if correct glob pattern containing metacharacters.\n     If meta has bit (1 << 2) set, it means there was an unterminated\n     [ which we handle the same, using fnmatch.  Broken unterminated\n     pattern bracket expressions ought to be rare enough that it is\n     not worth special casing them, fnmatch will do the right thing.  */\n  if (meta & (GLOBPAT_SPECIAL | GLOBPAT_BRACKET))\n    {\n      /* The directory name contains metacharacters, so we\n         have to glob for the directory, and then glob for\n         the pattern in each directory found.  */\n      size_t i;\n\n      if (!(flags & GLOB_NOESCAPE) && dirlen > 0 && dirname[dirlen - 1] == '\\\\')\n        {\n          /* \"foo\\\\/bar\".  Remove the final backslash from dirname\n             if it has not been quoted.  */\n          char *p = (char *) &dirname[dirlen - 1];\n\n          while (p > dirname && p[-1] == '\\\\') --p;\n          if ((&dirname[dirlen] - p) & 1)\n            *(char *) &dirname[--dirlen] = '\\0';\n        }\n\n      if (__glibc_unlikely ((flags & GLOB_ALTDIRFUNC) != 0))\n        {\n          /* Use the alternative access functions also in the recursive\n             call.  */\n          dirs.gl_opendir = pglob->gl_opendir;\n          dirs.gl_readdir = pglob->gl_readdir;\n          dirs.gl_closedir = pglob->gl_closedir;\n          dirs.gl_stat = pglob->gl_stat;\n          dirs.gl_lstat = pglob->gl_lstat;\n        }\n\n      status = __glob (dirname,\n                       ((flags & (GLOB_ERR | GLOB_NOESCAPE | GLOB_ALTDIRFUNC))\n                        | GLOB_NOSORT | GLOB_ONLYDIR),\n                       errfunc, &dirs);\n      if (status != 0)\n        {\n          if ((flags & GLOB_NOCHECK) == 0 || status != GLOB_NOMATCH)\n            {\n              retval = status;\n              goto out;\n            }\n          goto no_matches;\n        }\n\n      /* We have successfully globbed the preceding directory name.\n         For each name we found, call glob_in_dir on it and FILENAME,\n         appending the results to PGLOB.  */\n      for (i = 0; i < dirs.gl_pathc; ++i)\n        {\n          size_t old_pathc;\n\n          old_pathc = pglob->gl_pathc;\n          status = glob_in_dir (filename, dirs.gl_pathv[i],\n                                ((flags | GLOB_APPEND)\n                                 & ~(GLOB_NOCHECK | GLOB_NOMAGIC)),\n                                errfunc, pglob, alloca_used);\n          if (status == GLOB_NOMATCH)\n            /* No matches in this directory.  Try the next.  */\n            continue;\n\n          if (status != 0)\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = status;\n              goto out;\n            }\n\n          /* Stick the directory on the front of each name.  */\n          if (prefix_array (dirs.gl_pathv[i],\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (&dirs);\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n\n      flags |= GLOB_MAGCHAR;\n\n      /* We have ignored the GLOB_NOCHECK flag in the 'glob_in_dir' calls.\n         But if we have not found any matching entry and the GLOB_NOCHECK\n         flag was set we must return the input pattern itself.  */\n      if (pglob->gl_pathc + pglob->gl_offs == oldcount)\n        {\n        no_matches:\n          /* No matches.  */\n          if (flags & GLOB_NOCHECK)\n            {\n              size_t newcount = pglob->gl_pathc + pglob->gl_offs;\n              char **new_gl_pathv;\n\n              if (newcount > SIZE_MAX / sizeof (char *) - 2)\n                {\n                nospace2:\n                  globfree (&dirs);\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n\n              new_gl_pathv = realloc (pglob->gl_pathv,\n                                      (newcount + 2) * sizeof (char *));\n              if (new_gl_pathv == NULL)\n                goto nospace2;\n              pglob->gl_pathv = new_gl_pathv;\n\n              pglob->gl_pathv[newcount] = strdup (pattern);\n              if (pglob->gl_pathv[newcount] == NULL)\n                {\n                  globfree (&dirs);\n                  globfree (pglob);\n                  pglob->gl_pathc = 0;\n                  retval = GLOB_NOSPACE;\n                  goto out;\n                }\n\n              ++pglob->gl_pathc;\n              ++newcount;\n\n              pglob->gl_pathv[newcount] = NULL;\n              pglob->gl_flags = flags;\n            }\n          else\n            {\n              globfree (&dirs);\n              retval = GLOB_NOMATCH;\n              goto out;\n            }\n        }\n\n      globfree (&dirs);\n    }\n  else\n    {\n      size_t old_pathc = pglob->gl_pathc;\n      int orig_flags = flags;\n\n      if (meta & GLOBPAT_BACKSLASH)\n        {\n          char *p = strchr (dirname, '\\\\'), *q;\n          /* We need to unescape the dirname string.  It is certainly\n             allocated by alloca, as otherwise filename would be NULL\n             or dirname wouldn't contain backslashes.  */\n          q = p;\n          do\n            {\n              if (*p == '\\\\')\n                {\n                  *q = *++p;\n                  --dirlen;\n                }\n              else\n                *q = *p;\n              ++q;\n            }\n          while (*p++ != '\\0');\n          dirname_modified = 1;\n        }\n      if (dirname_modified)\n        flags &= ~(GLOB_NOCHECK | GLOB_NOMAGIC);\n      status = glob_in_dir (filename, dirname, flags, errfunc, pglob,\n                            alloca_used);\n      if (status != 0)\n        {\n          if (status == GLOB_NOMATCH && flags != orig_flags\n              && pglob->gl_pathc + pglob->gl_offs == oldcount)\n            {\n              /* Make sure globfree (&dirs); is a nop.  */\n              dirs.gl_pathv = NULL;\n              flags = orig_flags;\n              goto no_matches;\n            }\n          retval = status;\n          goto out;\n        }\n\n      if (dirlen > 0)\n        {\n          /* Stick the directory on the front of each name.  */\n          if (prefix_array (dirname,\n                            &pglob->gl_pathv[old_pathc + pglob->gl_offs],\n                            pglob->gl_pathc - old_pathc))\n            {\n              globfree (pglob);\n              pglob->gl_pathc = 0;\n              retval = GLOB_NOSPACE;\n              goto out;\n            }\n        }\n    }\n\n  if (flags & GLOB_MARK)\n    {\n      /* Append slashes to directory names.  */\n      size_t i;\n\n      for (i = oldcount; i < pglob->gl_pathc + pglob->gl_offs; ++i)\n        if (is_dir (pglob->gl_pathv[i], flags, pglob))\n          {\n            size_t len = strlen (pglob->gl_pathv[i]) + 2;\n            char *new = realloc (pglob->gl_pathv[i], len);\n            if (new == NULL)\n              {\n                globfree (pglob);\n                pglob->gl_pathc = 0;\n                retval = GLOB_NOSPACE;\n                goto out;\n              }\n            strcpy (&new[len - 2], \"/\");\n            pglob->gl_pathv[i] = new;\n          }\n    }\n\n  if (!(flags & GLOB_NOSORT))\n    {\n      /* Sort the vector.  */\n      qsort (&pglob->gl_pathv[oldcount],\n             pglob->gl_pathc + pglob->gl_offs - oldcount,\n             sizeof (char *), collated_compare);\n    }\n\n out:\n  if (__glibc_unlikely (malloc_dirname))\n    free (dirname);\n\n  return retval;\n}",
    "globfree(glob_t *)": "void\nglobfree (glob_t *pglob)\n{\n  if (pglob->gl_pathv != NULL)\n    {\n      size_t i;\n      for (i = 0; i < pglob->gl_pathc; ++i)\n        free (pglob->gl_pathv[pglob->gl_offs + i]);\n      free (pglob->gl_pathv);\n      pglob->gl_pathv = NULL;\n    }\n}",
    "globfree64(int *)": "void\nglobfree64 (glob64_t *pglob)\n{\n}",
    "__nanosleep(const struct timespec *, struct timespec *)": "int\n__nanosleep (const struct timespec *requested_time,\n\t     struct timespec *remaining)\n{\n  int ret = __clock_nanosleep (CLOCK_REALTIME, 0, requested_time, remaining);\n  if (ret != 0)\n    {\n      __set_errno (ret);\n      return -1;\n    }\n  return 0;\n}",
    "pause()": "int\npause (void)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "posix_madvise(void *, int, int)": "int\nposix_madvise (void *addr, size_t len, int advice)\n{\n  /* We have one problem: the kernel's MADV_DONTNEED does not\n     correspond to POSIX's POSIX_MADV_DONTNEED.  The former simply\n     discards changes made to the memory without writing it back to\n     disk, if this would be necessary.  The POSIX behavior does not\n     allow this.  There is no functionality mapping the POSIX behavior\n     so far so we ignore that advice for now.  */\n  if (advice == POSIX_MADV_DONTNEED)\n    return 0;\n\n  int result = INTERNAL_SYSCALL_CALL (madvise, addr, len, advice);\n  return INTERNAL_SYSCALL_ERRNO (result);\n}",
    "__libc_pread(int, void *, int, off_t)": "ssize_t\n__libc_pread (int fd, void *buf, size_t nbyte, off_t offset)\n{\n  /* Since we must not change the file pointer preserve the value so that\n     we can restore it later.  */\n  int save_errno;\n  ssize_t result;\n  off_t old_offset = __libc_lseek (fd, 0, SEEK_CUR);\n  if (old_offset == (off_t) -1)\n    return -1;\n\n  /* Set to wanted position.  */\n  if (__libc_lseek (fd, offset, SEEK_SET) == (off_t) -1)\n    return -1;\n\n  /* Write out the data.  */\n  result = __libc_read (fd, buf, nbyte);\n\n  /* Now we have to restore the position.  If this fails we have to\n     return this as an error.  But if the writing also failed we\n     return this error.  */\n  save_errno = errno;\n  if (__libc_lseek (fd, old_offset, SEEK_SET) == (off_t) -1)\n    {\n      if (result == -1)\n\t__set_errno (save_errno);\n      return -1;\n    }\n  __set_errno (save_errno);\n\n  return result;\n}",
    "__libc_pwrite(int, const void *, int, off_t)": "ssize_t\n__libc_pwrite (int fd, const void *buf, size_t nbyte, off_t offset)\n{\n  /* Since we must not change the file pointer preserve the value so that\n     we can restore it later.  */\n  int save_errno;\n  ssize_t result;\n  off_t old_offset = __libc_lseek (fd, 0, SEEK_CUR);\n  if (old_offset == (off_t) -1)\n    return -1;\n\n  /* Set to wanted position.  */\n  if (__libc_lseek (fd, offset, SEEK_SET) == (off_t) -1)\n    return -1;\n\n  /* Write out the data.  */\n  result = __libc_write (fd, buf, nbyte);\n\n  /* Now we have to restore the position.  If this fails we have to\n     return this as an error.  But if the writing also failed we\n     return this error.  */\n  save_errno = errno;\n  if (__libc_lseek (fd, old_offset, SEEK_SET) == (off_t) -1)\n    {\n      if (result == -1)\n\t__set_errno (save_errno);\n      return -1;\n    }\n  __set_errno (save_errno);\n\n  return result;\n}",
    "re_compile_pattern(const char *, int, struct re_pattern_buffer *)": "const char *\nre_compile_pattern (const char *pattern, size_t length,\n\t\t    struct re_pattern_buffer *bufp)\n{\n  reg_errcode_t ret;\n\n  /* And GNU code determines whether or not to get register information\n     by passing null for the REGS argument to re_match, etc., not by\n     setting no_sub, unless RE_NO_SUB is set.  */\n  bufp->no_sub = !!(re_syntax_options & RE_NO_SUB);\n\n  /* Match anchors at newline.  */\n  bufp->newline_anchor = 1;\n\n  ret = re_compile_internal (bufp, pattern, length, re_syntax_options);\n\n  if (!ret)\n    return NULL;\n  return gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);\n}",
    "re_set_syntax(int)": "reg_syntax_t\nre_set_syntax (reg_syntax_t syntax)\n{\n  reg_syntax_t ret = re_syntax_options;\n\n  re_syntax_options = syntax;\n  return ret;\n}",
    "regcomp(int *restrict, const char *restrict, int)": "int\nregcomp (regex_t *__restrict preg, const char *__restrict pattern, int cflags)\n{\n  reg_errcode_t ret;\n  reg_syntax_t syntax = ((cflags & REG_EXTENDED) ? RE_SYNTAX_POSIX_EXTENDED\n\t\t\t : RE_SYNTAX_POSIX_BASIC);\n\n  preg->buffer = NULL;\n  preg->allocated = 0;\n  preg->used = 0;\n\n  /* Try to allocate space for the fastmap.  */\n  preg->fastmap = re_malloc (char, SBC_MAX);\n  if (__glibc_unlikely (preg->fastmap == NULL))\n    return REG_ESPACE;\n\n  syntax |= (cflags & REG_ICASE) ? RE_ICASE : 0;\n\n  /* If REG_NEWLINE is set, newlines are treated differently.  */\n  if (cflags & REG_NEWLINE)\n    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */\n      syntax &= ~RE_DOT_NEWLINE;\n      syntax |= RE_HAT_LISTS_NOT_NEWLINE;\n      /* It also changes the matching behavior.  */\n      preg->newline_anchor = 1;\n    }\n  else\n    preg->newline_anchor = 0;\n  preg->no_sub = !!(cflags & REG_NOSUB);\n  preg->translate = NULL;\n\n  ret = re_compile_internal (preg, pattern, strlen (pattern), syntax);\n\n  /* POSIX doesn't distinguish between an unmatched open-group and an\n     unmatched close-group: both are REG_EPAREN.  */\n  if (ret == REG_ERPAREN)\n    ret = REG_EPAREN;\n\n  /* We have already checked preg->fastmap != NULL.  */\n  if (__glibc_likely (ret == REG_NOERROR))\n    /* Compute the fastmap now, since regexec cannot modify the pattern\n       buffer.  This function never fails in this implementation.  */\n    (void) re_compile_fastmap (preg);\n  else\n    {\n      /* Some error occurred while compiling the expression.  */\n      re_free (preg->fastmap);\n      preg->fastmap = NULL;\n    }\n\n  return (int) ret;\n}",
    "regcomp(regex_t *restrict, const char *restrict, int)": "int\nregcomp (regex_t *__restrict preg, const char *__restrict pattern, int cflags)\n{\n  reg_errcode_t ret;\n  reg_syntax_t syntax = ((cflags & REG_EXTENDED) ? RE_SYNTAX_POSIX_EXTENDED\n\t\t\t : RE_SYNTAX_POSIX_BASIC);\n\n  preg->buffer = NULL;\n  preg->allocated = 0;\n  preg->used = 0;\n\n  /* Try to allocate space for the fastmap.  */\n  preg->fastmap = re_malloc (char, SBC_MAX);\n  if (__glibc_unlikely (preg->fastmap == NULL))\n    return REG_ESPACE;\n\n  syntax |= (cflags & REG_ICASE) ? RE_ICASE : 0;\n\n  /* If REG_NEWLINE is set, newlines are treated differently.  */\n  if (cflags & REG_NEWLINE)\n    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */\n      syntax &= ~RE_DOT_NEWLINE;\n      syntax |= RE_HAT_LISTS_NOT_NEWLINE;\n      /* It also changes the matching behavior.  */\n      preg->newline_anchor = 1;\n    }\n  else\n    preg->newline_anchor = 0;\n  preg->no_sub = !!(cflags & REG_NOSUB);\n  preg->translate = NULL;\n\n  ret = re_compile_internal (preg, pattern, strlen (pattern), syntax);\n\n  /* POSIX doesn't distinguish between an unmatched open-group and an\n     unmatched close-group: both are REG_EPAREN.  */\n  if (ret == REG_ERPAREN)\n    ret = REG_EPAREN;\n\n  /* We have already checked preg->fastmap != NULL.  */\n  if (__glibc_likely (ret == REG_NOERROR))\n    /* Compute the fastmap now, since regexec cannot modify the pattern\n       buffer.  This function never fails in this implementation.  */\n    (void) re_compile_fastmap (preg);\n  else\n    {\n      /* Some error occurred while compiling the expression.  */\n      re_free (preg->fastmap);\n      preg->fastmap = NULL;\n    }\n\n  return (int) ret;\n}",
    "regexec(const regex_t *restrict, const char *restrict, int, regmatch_t *, int)": "int\nregexec (const regex_t *__restrict preg, const char *__restrict string,\n\t size_t nmatch, regmatch_t pmatch[_REGEX_NELTS (nmatch)], int eflags)\n{\n  reg_errcode_t err;\n  Idx start, length;\n  re_dfa_t *dfa = preg->buffer;\n\n  if (eflags & ~(REG_NOTBOL | REG_NOTEOL | REG_STARTEND))\n    return REG_BADPAT;\n\n  if (eflags & REG_STARTEND)\n    {\n      start = pmatch[0].rm_so;\n      length = pmatch[0].rm_eo;\n    }\n  else\n    {\n      start = 0;\n      length = strlen (string);\n    }\n\n  lock_lock (dfa->lock);\n  if (preg->no_sub)\n    err = re_search_internal (preg, string, length, start, length,\n\t\t\t      length, 0, NULL, eflags);\n  else\n    err = re_search_internal (preg, string, length, start, length,\n\t\t\t      length, nmatch, pmatch, eflags);\n  lock_unlock (dfa->lock);\n  return err != REG_NOERROR;\n}",
    "re_match(struct re_pattern_buffer *, const char *, Idx, Idx, struct re_registers *)": "regoff_t\nre_match (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t  Idx start, struct re_registers *regs)\n{\n  return re_search_stub (bufp, string, length, start, 0, length, regs, true);\n}",
    "re_search(struct re_pattern_buffer *, const char *, Idx, Idx, regoff_t, struct re_registers *)": "regoff_t\nre_search (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t   Idx start, regoff_t range, struct re_registers *regs)\n{\n  return re_search_stub (bufp, string, length, start, range, length, regs,\n\t\t\t false);\n}",
    "re_match_2(struct re_pattern_buffer *, const char *, Idx, const char *, Idx, Idx, struct re_registers *, Idx)": "regoff_t\nre_match_2 (struct re_pattern_buffer *bufp, const char *string1, Idx length1,\n\t    const char *string2, Idx length2, Idx start,\n\t    struct re_registers *regs, Idx stop)\n{\n  return re_search_2_stub (bufp, string1, length1, string2, length2,\n\t\t\t   start, 0, regs, stop, true);\n}",
    "re_search_2(struct re_pattern_buffer *, const char *, Idx, const char *, Idx, Idx, regoff_t, struct re_registers *, Idx)": "regoff_t\nre_search_2 (struct re_pattern_buffer *bufp, const char *string1, Idx length1,\n\t     const char *string2, Idx length2, Idx start, regoff_t range,\n\t     struct re_registers *regs, Idx stop)\n{\n  return re_search_2_stub (bufp, string1, length1, string2, length2,\n\t\t\t   start, range, regs, stop, false);\n}",
    "re_set_registers(struct re_pattern_buffer *, struct re_registers *, __re_size_t, regoff_t *, regoff_t *)": "void\nre_set_registers (struct re_pattern_buffer *bufp, struct re_registers *regs,\n\t\t  __re_size_t num_regs, regoff_t *starts, regoff_t *ends)\n{\n  if (num_regs)\n    {\n      bufp->regs_allocated = REGS_REALLOCATE;\n      regs->num_regs = num_regs;\n      regs->start = starts;\n      regs->end = ends;\n    }\n  else\n    {\n      bufp->regs_allocated = REGS_UNALLOCATED;\n      regs->num_regs = 0;\n      regs->start = regs->end = NULL;\n    }\n}",
    "regexec(const int *restrict, const char *restrict, int, int *, int)": "int\nregexec (const regex_t *__restrict preg, const char *__restrict string,\n\t size_t nmatch, regmatch_t pmatch[_REGEX_NELTS (nmatch)], int eflags)\n{\n  reg_errcode_t err;\n  Idx start, length;\n  re_dfa_t *dfa = preg->buffer;\n\n  if (eflags & ~(REG_NOTBOL | REG_NOTEOL | REG_STARTEND))\n    return REG_BADPAT;\n\n  if (eflags & REG_STARTEND)\n    {\n      start = pmatch[0].rm_so;\n      length = pmatch[0].rm_eo;\n    }\n  else\n    {\n      start = 0;\n      length = strlen (string);\n    }\n\n  lock_lock (dfa->lock);\n  if (preg->no_sub)\n    err = re_search_internal (preg, string, length, start, length,\n\t\t\t      length, 0, NULL, eflags);\n  else\n    err = re_search_internal (preg, string, length, start, length,\n\t\t\t      length, nmatch, pmatch, eflags);\n  lock_unlock (dfa->lock);\n  return err != REG_NOERROR;\n}",
    "re_match(struct re_pattern_buffer *, const char *, int, int, struct re_registers *)": "regoff_t\nre_match (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t  Idx start, struct re_registers *regs)\n{\n  return re_search_stub (bufp, string, length, start, 0, length, regs, true);\n}",
    "re_search(struct re_pattern_buffer *, const char *, int, int, int, struct re_registers *)": "regoff_t\nre_search (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t   Idx start, regoff_t range, struct re_registers *regs)\n{\n  return re_search_stub (bufp, string, length, start, range, length, regs,\n\t\t\t false);\n}",
    "re_match_2(struct re_pattern_buffer *, const char *, int, const char *, int, int, struct re_registers *, int)": "regoff_t\nre_match_2 (struct re_pattern_buffer *bufp, const char *string1, Idx length1,\n\t    const char *string2, Idx length2, Idx start,\n\t    struct re_registers *regs, Idx stop)\n{\n  return re_search_2_stub (bufp, string1, length1, string2, length2,\n\t\t\t   start, 0, regs, stop, true);\n}",
    "re_search_2(struct re_pattern_buffer *, const char *, int, const char *, int, int, int, struct re_registers *, int)": "regoff_t\nre_search_2 (struct re_pattern_buffer *bufp, const char *string1, Idx length1,\n\t     const char *string2, Idx length2, Idx start, regoff_t range,\n\t     struct re_registers *regs, Idx stop)\n{\n  return re_search_2_stub (bufp, string1, length1, string2, length2,\n\t\t\t   start, range, regs, stop, false);\n}",
    "re_set_registers(struct re_pattern_buffer *, struct re_registers *, int, int *, int *)": "void\nre_set_registers (struct re_pattern_buffer *bufp, struct re_registers *regs,\n\t\t  __re_size_t num_regs, regoff_t *starts, regoff_t *ends)\n{\n  if (num_regs)\n    {\n      bufp->regs_allocated = REGS_REALLOCATE;\n      regs->num_regs = num_regs;\n      regs->start = starts;\n      regs->end = ends;\n    }\n  else\n    {\n      bufp->regs_allocated = REGS_UNALLOCATED;\n      regs->num_regs = 0;\n      regs->start = regs->end = NULL;\n    }\n}",
    "__register_atfork(void (*)(void), void (*)(void), void (*)(void), void *)": "int\n__register_atfork (void (*prepare) (void), void (*parent) (void),\n\t\t   void (*child) (void), void *dso_handle)\n{\n  lll_lock (atfork_lock, LLL_PRIVATE);\n\n  if (fork_handler_counter == 0)\n    fork_handler_list_init (&fork_handlers);\n\n  struct fork_handler *newp = fork_handler_list_emplace (&fork_handlers);\n  if (newp != NULL)\n    {\n      newp->prepare_handler = prepare;\n      newp->parent_handler = parent;\n      newp->child_handler = child;\n      newp->dso_handle = dso_handle;\n\n      /* IDs assigned to handlers start at 1 and increment with handler\n         registration.  Un-registering a handlers discards the corresponding\n         ID.  It is not reused in future registrations.  */\n      if (INT_ADD_OVERFLOW (fork_handler_counter, 1))\n        __libc_fatal (\"fork handler counter overflow\");\n      newp->id = ++fork_handler_counter;\n    }\n\n  /* Release the lock.  */\n  lll_unlock (atfork_lock, LLL_PRIVATE);\n\n  return newp == NULL ? ENOMEM : 0;\n}",
    "__sched_cpualloc(int)": "cpu_set_t *\n__sched_cpualloc (size_t count)\n{\n  return malloc (CPU_ALLOC_SIZE (count));\n}",
    "__sched_cpucount(int, const cpu_set_t *)": "int\n__sched_cpucount (size_t setsize, const cpu_set_t *setp)\n{\n  int s = 0;\n  for (int i = 0; i < setsize / sizeof (__cpu_mask); i++)\n    s += countbits (setp->__bits[i]);\n  return s;\n}",
    "__sched_cpufree(cpu_set_t *)": "void\n__sched_cpufree (cpu_set_t *set)\n{\n  free (set);\n}",
    "sched_getaffinity(pid_t, int, cpu_set_t *)": "int\nsched_getaffinity (pid_t pid, size_t cpusetsize, cpu_set_t *cpuset)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__sched_getparam(pid_t, struct sched_param *)": "int\n__sched_getparam (pid_t pid, struct sched_param *param)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__sched_getscheduler(pid_t)": "int\n__sched_getscheduler (pid_t pid)\n{\n  return SCHED_OTHER;\n}",
    "__sched_get_priority_max(int)": "int\n__sched_get_priority_max (int algorithm)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__sched_get_priority_min(int)": "int\n__sched_get_priority_min (int algorithm)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "sched_setaffinity(pid_t, int, const cpu_set_t *)": "int\nsched_setaffinity (pid_t pid, size_t cpusetsize, const cpu_set_t *cpuset)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__sched_setscheduler(pid_t, int, const struct sched_param *)": "int\n__sched_setscheduler (pid_t pid, int policy, const struct sched_param *param)\n{\n  switch (policy)\n    {\n    case SCHED_OTHER:\n      if (param->sched_priority != 0)\n\treturn __hurd_fail (EINVAL);\n      break;\n\n    case SCHED_FIFO:\n    case SCHED_RR:\n      return __hurd_fail (ENOTSUP);\n\n    default:\n      return EINVAL;\n    }\n  return 0;\n}",
    "__sched_yield()": "int\n__sched_yield (void)\n{\n  (void) __swtch ();\n  return 0;\n}",
    "setgroups(int, const gid_t *)": "int\nsetgroups (size_t n, const gid_t *groups)\n{\n#ifdef __NR_setgroups32\n  return INLINE_SETXID_SYSCALL (setgroups32, 2, n, groups);\n#else\n  return INLINE_SETXID_SYSCALL (setgroups, 2, n, groups);\n#endif\n}",
    "__setpgid(int, int)": "int\n__setpgid (int pid, int pgid)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "setpgrp()": "int\nsetpgrp (void)\n{\n  return __setpgid (0, 0);\n}",
    "__shm_get_name(struct shmdir_name *, const char *, int)": "int\n__shm_get_name (struct shmdir_name *result, const char *name, bool sem_prefix)\n{\n  struct alloc_buffer buffer;\n  size_t namelen;\n\n  buffer = alloc_buffer_create (result->name, sizeof (result->name));\n  alloc_buffer_copy_bytes (&buffer, SHMDIR, strlen (SHMDIR));\n\n#if defined (SHM_ANON) && defined (O_TMPFILE)\n  if (name == SHM_ANON)\n    {\n      /* For SHM_ANON, we want shm_open () to pass O_TMPFILE to open (),\n         with SHMDIR itself as the path.  So, leave it at that.  */\n      alloc_buffer_add_byte (&buffer, 0);\n      if (alloc_buffer_has_failed (&buffer))\n        return -1;\n      return 0;\n    }\n#endif\n\n  while (name[0] == '/')\n    ++name;\n  namelen = strlen (name);\n\n  if (sem_prefix)\n    alloc_buffer_copy_bytes (&buffer, \"sem.\", strlen (\"sem.\"));\n  alloc_buffer_copy_bytes (&buffer, name, namelen + 1);\n  if (namelen == 0 || memchr (name, '/', namelen) != NULL)\n    return EINVAL;\n  if (alloc_buffer_has_failed (&buffer))\n    {\n      if (namelen > NAME_MAX)\n        return ENAMETOOLONG;\n      return EINVAL;\n    }\n  return 0;\n}",
    "posix_spawn_file_actions_addchdir_np(posix_spawn_file_actions_t *, const char *)": "int\nposix_spawn_file_actions_addchdir_np (posix_spawn_file_actions_t *file_actions,\n                                      const char *path)\n{\n  struct __spawn_action *rec;\n\n  char *path_copy = __strdup (path);\n  if (path_copy == NULL)\n    return ENOMEM;\n\n  /* Allocate more memory if needed.  */\n  if (file_actions->__used == file_actions->__allocated\n      && __posix_spawn_file_actions_realloc (file_actions) != 0)\n    {\n      /* This can only mean we ran out of memory.  */\n      free (path_copy);\n      return ENOMEM;\n    }\n\n  /* Add the new value.  */\n  rec = &file_actions->__actions[file_actions->__used];\n  rec->tag = spawn_do_chdir;\n  rec->action.chdir_action.path = path_copy;\n\n  /* Account for the new entry.  */\n  ++file_actions->__used;\n\n  return 0;\n}",
    "posix_spawn_file_actions_addfchdir_np(posix_spawn_file_actions_t *, int)": "int\nposix_spawn_file_actions_addfchdir_np (posix_spawn_file_actions_t *actions,\n                                       int fd)\n{\n  struct __spawn_action *rec;\n\n  /* Allocate more memory if needed.  */\n  if (actions->__used == actions->__allocated\n      && __posix_spawn_file_actions_realloc (actions) != 0)\n    /* This can only mean we ran out of memory.  */\n    return ENOMEM;\n\n  /* Add the new value.  */\n  rec = &actions->__actions[actions->__used];\n  rec->tag = spawn_do_fchdir;\n  rec->action.fchdir_action.fd = fd;\n\n  /* Account for the new entry.  */\n  ++actions->__used;\n\n  return 0;\n}",
    "posix_spawnattr_getsigdefault(const posix_spawnattr_t *, sigset_t *)": "int\nposix_spawnattr_getsigdefault (const posix_spawnattr_t *attr,\n\t\t\t       sigset_t *sigdefault)\n{\n  /* Copy the sigset_t data to the user buffer.  */\n  memcpy (sigdefault, &attr->__sd, sizeof (sigset_t));\n\n  return 0;\n}",
    "posix_spawnattr_getflags(const posix_spawnattr_t *, short *)": "int\nposix_spawnattr_getflags (const posix_spawnattr_t *attr, short int *flags)\n{\n  /* Copy the flag word.  */\n  *flags = attr->__flags;\n\n  return 0;\n}",
    "posix_spawnattr_getpgroup(const posix_spawnattr_t *, pid_t *)": "int\nposix_spawnattr_getpgroup (const posix_spawnattr_t *attr, pid_t *pgroup)\n{\n  /* Copy the process group ID.  */\n  *pgroup = attr->__pgrp;\n\n  return 0;\n}",
    "posix_spawnattr_getschedparam(const posix_spawnattr_t *, struct sched_param *)": "int\nposix_spawnattr_getschedparam (const posix_spawnattr_t *attr,\n\t\t\t       struct sched_param *schedparam)\n{\n  /* Copy the scheduling parameters.  */\n  memcpy (schedparam, &attr->__sp, sizeof (attr->__sp));\n\n  return 0;\n}",
    "posix_spawnattr_getschedpolicy(const posix_spawnattr_t *, int *)": "int\nposix_spawnattr_getschedpolicy (const posix_spawnattr_t *attr,\n\t\t\t\tint *schedpolicy)\n{\n  /* Copy the scheduling policy.  */\n  *schedpolicy = attr->__policy;\n\n  return 0;\n}",
    "posix_spawnattr_getsigmask(const posix_spawnattr_t *, sigset_t *)": "int\nposix_spawnattr_getsigmask (const posix_spawnattr_t *attr,\n\t\t\t    sigset_t *sigmask)\n{\n  /* Copy the sigset_t data to the user buffer.  */\n  memcpy (sigmask, &attr->__ss, sizeof (sigset_t));\n\n  return 0;\n}",
    "posix_spawnattr_setpgroup(posix_spawnattr_t *, pid_t)": "int\nposix_spawnattr_setpgroup (posix_spawnattr_t *attr, pid_t pgroup)\n{\n  /* Store the process group ID.  */\n  attr->__pgrp = pgroup;\n\n  return 0;\n}",
    "posix_spawnattr_setschedparam(posix_spawnattr_t *, const struct sched_param *)": "int\nposix_spawnattr_setschedparam (posix_spawnattr_t *attr,\n\t\t\t       const struct sched_param *schedparam)\n{\n  /* Store the scheduling parameters.  */\n  attr->__sp = *schedparam;\n\n  return 0;\n}",
    "posix_spawnattr_setschedpolicy(posix_spawnattr_t *, int)": "int\nposix_spawnattr_setschedpolicy (posix_spawnattr_t *attr, int schedpolicy)\n{\n  if (schedpolicy != SCHED_OTHER && schedpolicy != SCHED_FIFO\n      && schedpolicy != SCHED_RR)\n    return EINVAL;\n\n  /* Store the policy.  */\n  attr->__policy = schedpolicy;\n\n  return 0;\n}",
    "__sysconf(int)": "long int\n__sysconf (int name)\n{\n  if (name >= _SC_LEVEL1_ICACHE_SIZE && name <= _SC_LEVEL4_CACHE_LINESIZE)\n    return __cache_sysconf (name);\n\n  return linux_sysconf (name);\n}",
    "__vfork()": "__pid_t\n__vfork (void)\n{\n  return __fork ();\n}",
    "__wait(int *)": "__pid_t\n__wait (int *stat_loc)\n{\n  return __waitpid (WAIT_ANY, stat_loc, 0);\n}",
    "__waitpid(pid_t, int *, int)": "pid_t\n__waitpid (pid_t pid, int *stat_loc, int options)\n{\n  return __wait4 (pid, stat_loc, options, NULL);\n}",
    "wordfree(wordexp_t *)": "void\nwordfree (wordexp_t *pwordexp)\n{\n\n  /* wordexp can set pwordexp to NULL */\n  if (pwordexp && pwordexp->we_wordv)\n    {\n      char **wordv = pwordexp->we_wordv;\n\n      for (wordv += pwordexp->we_offs; *wordv; ++wordv)\n\tfree (*wordv);\n\n      free (pwordexp->we_wordv);\n      pwordexp->we_wordv = NULL;\n    }\n}",
    "herror(const char *)": "void\nherror(const char *s) {\n\tstruct iovec iov[4], *v = iov;\n\n\tif (s != NULL && *s != '\\0') {\n\t\tv->iov_base = (/*noconst*/ char *)s;\n\t\tv->iov_len = strlen(s);\n\t\tv++;\n\t\tv->iov_base = (char *) \": \";\n\t\tv->iov_len = 2;\n\t\tv++;\n\t}\n\tv->iov_base = (char *)hstrerror(h_errno);\n\tv->iov_len = strlen(v->iov_base);\n\tv++;\n\tv->iov_base = (char *) \"\\n\";\n\tv->iov_len = 1;\n\t__writev_nocancel_nostatus(STDERR_FILENO, iov, (v - iov) + 1);\n}",
    "hstrerror(int)": "const char *\nhstrerror(int err) {\n\tif (err < 0)\n\t\treturn _(\"Resolver internal error\");\n\telse if (err < h_nerr)\n\t\treturn _(h_errlist[err]);\n\treturn _(\"Unknown resolver error\");\n}",
    "__inet_aton_exact(const char *, struct in_addr *)": "int\n__inet_aton_exact (const char *cp, struct in_addr *addr)\n{\n  struct in_addr val;\n  const char *endp;\n  /* Check that inet_aton_end parsed the entire string.  */\n  if (inet_aton_end (cp, &val, &endp) != 0 && *endp == 0)\n    {\n      *addr = val;\n      return 1;\n    }\n  else\n    return 0;\n}",
    "inet_ntop(int, const void *, char *, socklen_t)": "const char *\ninet_ntop (int af, const void *src, char *dst, socklen_t size)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn (inet_ntop4(src, dst, size));\n\tcase AF_INET6:\n\t\treturn (inet_ntop6(src, dst, size));\n\tdefault:\n\t\t__set_errno (EAFNOSUPPORT);\n\t\treturn (NULL);\n\t}\n\t/* NOTREACHED */\n}",
    "__inet_pton_length(int, const char *, int, void *)": "int\n__inet_pton_length (int af, const char *src, size_t srclen, void *dst)\n{\n  switch (af)\n    {\n    case AF_INET:\n      return inet_pton4 (src, src + srclen, dst);\n    case AF_INET6:\n      return inet_pton6 (src, src + srclen, dst);\n    default:\n      __set_errno (EAFNOSUPPORT);\n      return -1;\n    }\n}",
    "__libc_ns_makecanon(const char *, char *, int)": "int\n__libc_ns_makecanon (const char *src, char *dst, size_t dstsize)\n{\n  size_t n = strlen (src);\n\n  if (n + sizeof \".\" > dstsize) /* sizeof == 2.  */\n    {\n      __set_errno (EMSGSIZE);\n      return -1;\n    }\n  strcpy (dst, src);\n  while (n >= 1U && dst[n - 1] == '.')   /* Ends in \".\".  */\n    if (n >= 2U && dst[n - 2] == '\\\\' && /* Ends in \"\\.\".  */\n        (n < 3U || dst[n - 3] != '\\\\'))  /* But not \"\\\\.\".  */\n      break;\n    else\n      dst[--n] = '\\0';\n  dst[n++] = '.';\n  dst[n] = '\\0';\n  return 0;\n}",
    "__libc_ns_samename(const char *, const char *)": "int\n__libc_ns_samename (const char *a, const char *b)\n{\n  char ta[NS_MAXDNAME], tb[NS_MAXDNAME];\n\n  if (__libc_ns_makecanon (a, ta, sizeof ta) < 0 ||\n      __libc_ns_makecanon (b, tb, sizeof tb) < 0)\n    return -1;\n  if (__strcasecmp (ta, tb) == 0)\n    return 1;\n  else\n    return 0;\n}",
    "inet_nsap_addr(const char *, u_char *, int)": "u_int\ninet_nsap_addr(const char *ascii, u_char *binary, int maxlen) {\n\tu_char c, nib;\n\tu_int len = 0;\n\n\twhile ((c = *ascii++) != '\\0' && len < (u_int)maxlen) {\n\t\tif (c == '.' || c == '+' || c == '/')\n\t\t\tcontinue;\n\t\tif (!isascii(c))\n\t\t\treturn (0);\n\t\tc = toupper(c);\n\t\tif (isxdigit(c)) {\n\t\t\tnib = xtob(c);\n\t\t\tc = *ascii++;\n\t\t\tif (c != '\\0') {\n\t\t\t\tc = toupper(c);\n\t\t\t\tif (isxdigit(c)) {\n\t\t\t\t\t*binary++ = (nib << 4) | xtob(c);\n\t\t\t\t\tlen++;\n\t\t\t\t} else\n\t\t\t\t\treturn (0);\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn (0);\n\t\t}\n\t\telse\n\t\t\treturn (0);\n\t}\n\treturn (len);\n}",
    "inet_nsap_ntoa(int, const u_char *, char *)": "char *\ninet_nsap_ntoa(int binlen, const u_char *binary, char *ascii) {\n\tint nib;\n\tint i;\n\tstatic char tmpbuf[255*2 + 128];\n\tchar *start;\n\n\tif (ascii)\n\t\tstart = ascii;\n\telse {\n\t\tascii = tmpbuf;\n\t\tstart = tmpbuf;\n\t}\n\n\tif (binlen > 255)\n\t\tbinlen = 255;\n\n\tfor (i = 0; i < binlen; i++) {\n\t\tnib = *binary >> 4;\n\t\t*ascii++ = nib + (nib < 10 ? '0' : '7');\n\t\tnib = *binary++ & 0x0f;\n\t\t*ascii++ = nib + (nib < 10 ? '0' : '7');\n\t\tif (((i % 2) == 0 && (i + 1) < binlen))\n\t\t\t*ascii++ = '.';\n\t}\n\t*ascii = '\\0';\n\treturn (start);\n}",
    "__res_iclose(res_state, int)": "void\n__res_iclose (res_state statp, bool free_addr)\n{\n  if (statp->_vcsock >= 0)\n    {\n      __close_nocancel_nostatus (statp->_vcsock);\n      statp->_vcsock = -1;\n      statp->_flags &= ~(RES_F_VC | RES_F_CONN);\n    }\n  for (int ns = 0; ns < statp->nscount; ns++)\n    if (statp->_u._ext.nsaddrs[ns] != NULL)\n      {\n        if (statp->_u._ext.nssocks[ns] != -1)\n          {\n            __close_nocancel_nostatus (statp->_u._ext.nssocks[ns]);\n            statp->_u._ext.nssocks[ns] = -1;\n          }\n        if (free_addr)\n          {\n            free (statp->_u._ext.nsaddrs[ns]);\n            statp->_u._ext.nsaddrs[ns] = NULL;\n          }\n      }\n  if (free_addr)\n    __resolv_conf_detach (statp);\n}",
    "__res_state()": "struct __res_state *\n__res_state (void)\n{\n  return __resp;\n}",
    "__res_context_hostalias(struct resolv_context *, const char *, char *, int)": "const char *\n__res_context_hostalias (struct resolv_context *ctx,\n                         const char *name, char *dst, size_t siz)\n{\n  char *file, *cp1, *cp2;\n  char buf[BUFSIZ];\n  FILE *fp;\n\n  if (ctx->resp->options & RES_NOALIASES)\n    return NULL;\n  file = getenv (\"HOSTALIASES\");\n  if (file == NULL || (fp = fopen (file, \"rce\")) == NULL)\n    return NULL;\n  buf[sizeof (buf) - 1] = '\\0';\n  while (__fgets_unlocked (buf, sizeof (buf), fp))\n    {\n      for (cp1 = buf; *cp1 && !isspace (*cp1); ++cp1)\n        ;\n      if (!*cp1)\n        break;\n      *cp1 = '\\0';\n      if (__libc_ns_samename (buf, name) == 1)\n        {\n          while (isspace (*++cp1))\n            ;\n          if (!*cp1)\n            break;\n          for (cp2 = cp1 + 1; *cp2 && !isspace (*cp2); ++cp2)\n            ;\n          *cp2 = '\\0';\n          strncpy (dst, cp1, siz - 1);\n          dst[siz - 1] = '\\0';\n          fclose (fp);\n          return dst;\n        }\n    }\n  fclose (fp);\n  return NULL;\n}",
    "__res_context_mkquery(struct resolv_context *, int, const char *, int, int, const unsigned char *, unsigned char *, int)": "int\n__res_context_mkquery (struct resolv_context *ctx, int op, const char *dname,\n                       int class, int type, const unsigned char *data,\n                       unsigned char *buf, int buflen)\n{\n  UHEADER *hp;\n  unsigned char *cp;\n  int n;\n  unsigned char *dnptrs[20], **dpp, **lastdnptr;\n\n  if (class < 0 || class > 65535 || type < 0 || type > 65535)\n    return -1;\n\n  /* Initialize header fields.  */\n  if ((buf == NULL) || (buflen < HFIXEDSZ))\n    return -1;\n  memset (buf, 0, HFIXEDSZ);\n  hp = (UHEADER *) buf;\n  /* We randomize the IDs every time.  The old code just incremented\n     by one after the initial randomization which still predictable if\n     the application does multiple requests.  */\n  hp->id = random_bits ();\n  hp->opcode = op;\n  if (ctx->resp->options & RES_TRUSTAD)\n    hp->ad = 1;\n  hp->rd = (ctx->resp->options & RES_RECURSE) != 0;\n  hp->rcode = NOERROR;\n  cp = buf + HFIXEDSZ;\n  buflen -= HFIXEDSZ;\n  dpp = dnptrs;\n  *dpp++ = buf;\n  *dpp++ = NULL;\n  lastdnptr = dnptrs + sizeof dnptrs / sizeof dnptrs[0];\n\n  /* Perform opcode specific processing.  */\n  switch (op)\n    {\n    case NS_NOTIFY_OP:\n      if ((buflen -= QFIXEDSZ + (data == NULL ? 0 : RRFIXEDSZ)) < 0)\n        return -1;\n      goto compose;\n\n    case QUERY:\n      if ((buflen -= QFIXEDSZ) < 0)\n        return -1;\n    compose:\n      n = __ns_name_compress (dname, cp, buflen,\n                              (const unsigned char **) dnptrs,\n                              (const unsigned char **) lastdnptr);\n      if (n < 0)\n        return -1;\n      cp += n;\n      buflen -= n;\n      NS_PUT16 (type, cp);\n      NS_PUT16 (class, cp);\n      hp->qdcount = htons (1);\n      if (op == QUERY || data == NULL)\n        break;\n\n      /* Make an additional record for completion domain.  */\n      n = __ns_name_compress ((char *)data, cp, buflen,\n                              (const unsigned char **) dnptrs,\n                              (const unsigned char **) lastdnptr);\n      if (__glibc_unlikely (n < 0))\n        return -1;\n      cp += n;\n      buflen -= n;\n      NS_PUT16 (T_NULL, cp);\n      NS_PUT16 (class, cp);\n      NS_PUT32 (0, cp);\n      NS_PUT16 (0, cp);\n      hp->arcount = htons (1);\n      break;\n\n    default:\n      return -1;\n    }\n  return cp - buf;\n}",
    "__res_nopt(struct resolv_context *, int, unsigned char *, int, int)": "int\n__res_nopt (struct resolv_context *ctx,\n            int n0, unsigned char *buf, int buflen, int anslen)\n{\n  uint16_t flags = 0;\n  UHEADER *hp = (UHEADER *) buf;\n  unsigned char *cp = buf + n0;\n  unsigned char *ep = buf + buflen;\n\n  if ((ep - cp) < 1 + RRFIXEDSZ)\n    return -1;\n\n  /* Add the root label.  */\n  *cp++ = 0;\n\n  NS_PUT16 (T_OPT, cp);         /* Record type.  */\n\n  /* Lowering the advertised buffer size based on the actual\n     answer buffer size is desirable because the server will\n     minimize the reply to fit into the UDP packet (and A\n     non-minimal response might not fit the buffer).\n\n     The RESOLV_EDNS_BUFFER_SIZE limit could still result in TCP\n     fallback and a non-minimal response which has to be\n     hard-truncated in the stub resolver, but this is price to\n     pay for avoiding fragmentation.  (This issue does not\n     affect the nss_dns functions because they use the stub\n     resolver in such a way that it allocates a properly sized\n     response buffer.)  */\n  {\n    uint16_t buffer_size;\n    if (anslen < 512)\n      buffer_size = 512;\n    else if (anslen > RESOLV_EDNS_BUFFER_SIZE)\n      buffer_size = RESOLV_EDNS_BUFFER_SIZE;\n    else\n      buffer_size = anslen;\n    NS_PUT16 (buffer_size, cp);\n  }\n\n  *cp++ = NOERROR;              /* Extended RCODE.  */\n  *cp++ = 0;                    /* EDNS version.  */\n\n  if (ctx->resp->options & RES_USE_DNSSEC)\n    flags |= NS_OPT_DNSSEC_OK;\n\n  NS_PUT16 (flags, cp);\n  NS_PUT16 (0, cp);       /* RDATA length (no options are preent).  */\n  hp->arcount = htons (ntohs (hp->arcount) + 1);\n\n  return cp - buf;\n}",
    "__libc_res_nameinquery(const char *, int, int, const unsigned char *, const unsigned char *)": "int\n__libc_res_nameinquery (const char *name, int type, int class,\n                        const unsigned char *buf, const unsigned char *eom)\n{\n  const unsigned char *cp = buf + HFIXEDSZ;\n  int qdcount = ntohs (((UHEADER *) buf)->qdcount);\n\n  while (qdcount-- > 0)\n    {\n      char tname[MAXDNAME+1];\n      int n, ttype, tclass;\n\n      n = __libc_dn_expand (buf, eom, cp, tname, sizeof tname);\n      if (n < 0)\n        return -1;\n      cp += n;\n      if (cp + 2 * INT16SZ > eom)\n        return -1;\n      NS_GET16 (ttype, cp);\n      NS_GET16 (tclass, cp);\n      if (ttype == type && tclass == class\n          && __libc_ns_samename (tname, name) == 1)\n        return 1;\n    }\n  return 0;\n}",
    "__libc_res_queriesmatch(const unsigned char *, const unsigned char *, const unsigned char *, const unsigned char *)": "int\n__libc_res_queriesmatch (const unsigned char *buf1, const unsigned char *eom1,\n                         const unsigned char *buf2, const unsigned char *eom2)\n{\n  if (eom1 - buf1 < HFIXEDSZ || eom2 - buf2 < HFIXEDSZ)\n    return -1;\n\n  /* Only header section present in replies to dynamic update\n     packets.  */\n  if ((((UHEADER *) buf1)->opcode == ns_o_update) &&\n      (((UHEADER *) buf2)->opcode == ns_o_update))\n    return 1;\n\n  /* Note that we initially do not convert QDCOUNT to the host byte\n     order.  We can compare it with the second buffer's QDCOUNT\n     value without doing this.  */\n  int qdcount = ((UHEADER *) buf1)->qdcount;\n  if (qdcount != ((UHEADER *) buf2)->qdcount)\n    return 0;\n\n  qdcount = htons (qdcount);\n  const unsigned char *cp = buf1 + HFIXEDSZ;\n\n  while (qdcount-- > 0)\n    {\n      char tname[MAXDNAME+1];\n      int n, ttype, tclass;\n\n      n = __libc_dn_expand (buf1, eom1, cp, tname, sizeof tname);\n      if (n < 0)\n        return -1;\n      cp += n;\n      if (eom1 - cp < 4)\n        return -1;\n      NS_GET16 (ttype, cp);\n      NS_GET16 (tclass, cp);\n      if (!__libc_res_nameinquery (tname, ttype, tclass, buf2, eom2))\n        return 0;\n    }\n  return 1;\n}",
    "__res_context_query(struct resolv_context *, const char *, int, int, unsigned char *, int, unsigned char **, unsigned char **, int *, int *, int *)": "int\n__res_context_query (struct resolv_context *ctx, const char *name,\n\t\t     int class, int type,\n\t\t     unsigned char *answer, int anslen,\n\t\t     unsigned char **answerp, unsigned char **answerp2,\n\t\t     int *nanswerp2, int *resplen2, int *answerp2_malloced)\n{\n\tstruct __res_state *statp = ctx->resp;\n\tUHEADER *hp = (UHEADER *) answer;\n\tUHEADER *hp2;\n\tint n;\n\tbool retried = false;\n\n\t/* It requires 2 times QUERYSIZE for type == T_QUERY_A_AND_AAAA.  */\n\tstruct scratch_buffer buf;\n\tscratch_buffer_init (&buf);\n\t_Static_assert (2 * QUERYSIZE <= sizeof (buf.__space.__c),\n\t\t\t\"scratch_buffer too small\");\n\tu_char *query1 = buf.data;\n\tint nquery1 = -1;\n\tu_char *query2 = NULL;\n\tint nquery2 = 0;\n\n again:\n\thp->rcode = NOERROR;\t/* default */\n\n\tif (type == T_QUERY_A_AND_AAAA)\n\t  {\n\t    n = __res_context_mkquery (ctx, QUERY, name, class, T_A, NULL,\n\t\t\t\t       query1, buf.length);\n\t    if (n > 0)\n\t      {\n\t\tif ((statp->options & (RES_USE_EDNS0|RES_USE_DNSSEC)) != 0)\n\t\t  {\n\t\t    /* Use RESOLV_EDNS_BUFFER_SIZE because the receive\n\t\t       buffer can be reallocated.  */\n\t\t    n = __res_nopt (ctx, n, query1, buf.length,\n\t\t\t\t    RESOLV_EDNS_BUFFER_SIZE);\n\t\t    if (n < 0)\n\t\t      goto unspec_nomem;\n\t\t  }\n\n\t\tnquery1 = n;\n\t\tquery2 = buf.data + n;\n\t\tn = __res_context_mkquery (ctx, QUERY, name, class, T_AAAA,\n\t\t\t\t\t   NULL, query2, buf.length - n);\n\t\tif (n > 0\n\t\t    && (statp->options & (RES_USE_EDNS0|RES_USE_DNSSEC)) != 0)\n\t\t  /* Use RESOLV_EDNS_BUFFER_SIZE because the receive\n\t\t     buffer can be reallocated.  */\n\t\t  n = __res_nopt (ctx, n, query2, buf.length,\n\t\t\t\t  RESOLV_EDNS_BUFFER_SIZE);\n\t\tnquery2 = n;\n\t      }\n\n\t  unspec_nomem:;\n\t  }\n\telse\n\t  {\n\t    n = __res_context_mkquery (ctx, QUERY, name, class, type, NULL,\n\t\t\t\t       query1, buf.length);\n\n\t    if (n > 0\n\t\t&& (statp->options & (RES_USE_EDNS0|RES_USE_DNSSEC)) != 0)\n\t      {\n\t\t/* Use RESOLV_EDNS_BUFFER_SIZE if the receive buffer\n\t\t   can be reallocated.  */\n\t\tsize_t advertise;\n\t\tif (answerp == NULL)\n\t\t  advertise = anslen;\n\t\telse\n\t\t  advertise = RESOLV_EDNS_BUFFER_SIZE;\n\t\tn = __res_nopt (ctx, n, query1, buf.length, advertise);\n\t      }\n\n\t    nquery1 = n;\n\t  }\n\n\tif (__glibc_unlikely (n <= 0) && !retried) {\n\t\t/* Retry just in case res_nmkquery failed because of too\n\t\t   short buffer.  Shouldn't happen.  */\n\t\tif (scratch_buffer_set_array_size (&buf,\n\t\t\t\t\t\t   (type == T_QUERY_A_AND_AAAA)\n\t\t\t\t\t\t   ? 2 : 1,\n\t\t\t\t\t\t   MAXPACKET)) {\n\t\t\tquery1 = buf.data;\n\t\t\tretried = true;\n\t\t\tgoto again;\n\t\t}\n\t}\n\tif (__glibc_unlikely (n <= 0))       {\n\t\tRES_SET_H_ERRNO(statp, NO_RECOVERY);\n\t\tscratch_buffer_free (&buf);\n\t\treturn (n);\n\t}\n\n\t/* Suppress AAAA lookups if required.  __res_handle_no_aaaa\n\t   checks RES_NOAAAA first, so avoids parsing the\n\t   just-generated query packet in most cases.  nss_dns avoids\n\t   using T_QUERY_A_AND_AAAA in RES_NOAAAA mode, so there is no\n\t   need to handle it here.  */\n\tif (type == T_AAAA && __res_handle_no_aaaa (ctx, query1, nquery1,\n\t\t\t\t\t\t    answer, anslen, &n))\n\t  /* There must be no second query for AAAA queries.  The code\n\t     below is still needed to translate NODATA responses.  */\n\t  assert (query2 == NULL);\n\telse\n\t  {\n\t    assert (answerp == NULL || (void *) *answerp == (void *) answer);\n\t    n = __res_context_send (ctx, query1, nquery1, query2, nquery2,\n\t\t\t\t    answer, anslen,\n\t\t\t\t    answerp, answerp2, nanswerp2, resplen2,\n\t\t\t\t    answerp2_malloced);\n\t  }\n\n\tscratch_buffer_free (&buf);\n\tif (n < 0) {\n\t\tRES_SET_H_ERRNO(statp, TRY_AGAIN);\n\t\treturn (n);\n\t}\n\n\tif (answerp != NULL)\n\t  /* __res_context_send might have reallocated the buffer.  */\n\t  hp = (UHEADER *) *answerp;\n\n\t/* We simplify the following tests by assigning HP to HP2 or\n\t   vice versa.  It is easy to verify that this is the same as\n\t   ignoring all tests of HP or HP2.  */\n\tif (answerp2 == NULL || *resplen2 < (int) sizeof (HEADER))\n\t  {\n\t    hp2 = hp;\n\t  }\n\telse\n\t  {\n\t    hp2 = (UHEADER *) *answerp2;\n\t    if (n < (int) sizeof (HEADER))\n\t      {\n\t        hp = hp2;\n\t      }\n\t  }\n\n\t/* Make sure both hp and hp2 are defined */\n\tassert((hp != NULL) && (hp2 != NULL));\n\n\tif ((hp->rcode != NOERROR || ntohs(hp->ancount) == 0)\n\t    && (hp2->rcode != NOERROR || ntohs(hp2->ancount) == 0)) {\n\t\tswitch (hp->rcode == NOERROR ? hp2->rcode : hp->rcode) {\n\t\tcase NXDOMAIN:\n\t\t\tif ((hp->rcode == NOERROR && ntohs (hp->ancount) != 0)\n\t\t\t    || (hp2->rcode == NOERROR\n\t\t\t\t&& ntohs (hp2->ancount) != 0))\n\t\t\t\tgoto success;\n\t\t\tRES_SET_H_ERRNO(statp, HOST_NOT_FOUND);\n\t\t\tbreak;\n\t\tcase SERVFAIL:\n\t\t\tRES_SET_H_ERRNO(statp, TRY_AGAIN);\n\t\t\tbreak;\n\t\tcase NOERROR:\n\t\t\tif (ntohs (hp->ancount) != 0\n\t\t\t    || ntohs (hp2->ancount) != 0)\n\t\t\t\tgoto success;\n\t\t\tRES_SET_H_ERRNO(statp, NO_DATA);\n\t\t\tbreak;\n\t\tcase FORMERR:\n\t\tcase NOTIMP:\n\t\t\t/* Servers must not reply to AAAA queries with\n\t\t\t   NOTIMP etc but some of them do.  */\n\t\t\tif ((hp->rcode == NOERROR && ntohs (hp->ancount) != 0)\n\t\t\t    || (hp2->rcode == NOERROR\n\t\t\t\t&& ntohs (hp2->ancount) != 0))\n\t\t\t\tgoto success;\n\t\t\t/* FALLTHROUGH */\n\t\tcase REFUSED:\n\t\tdefault:\n\t\t\tRES_SET_H_ERRNO(statp, NO_RECOVERY);\n\t\t\tbreak;\n\t\t}\n\t\treturn (-1);\n\t}\n success:\n\treturn (n);\n}",
    "__res_context_search(struct resolv_context *, const char *, int, int, unsigned char *, int, unsigned char **, unsigned char **, int *, int *, int *)": "int\n__res_context_search (struct resolv_context *ctx,\n\t\t      const char *name, int class, int type,\n\t\t      unsigned char *answer, int anslen,\n\t\t      unsigned char **answerp, unsigned char **answerp2,\n\t\t      int *nanswerp2, int *resplen2, int *answerp2_malloced)\n{\n\tstruct __res_state *statp = ctx->resp;\n\tconst char *cp;\n\tUHEADER *hp = (UHEADER *) answer;\n\tchar tmp[NS_MAXDNAME];\n\tu_int dots;\n\tint trailing_dot, ret, saved_herrno;\n\tint got_nodata = 0, got_servfail = 0, root_on_list = 0;\n\tint tried_as_is = 0;\n\tint searched = 0;\n\n\t__set_errno (0);\n\tRES_SET_H_ERRNO(statp, HOST_NOT_FOUND);  /* True if we never query. */\n\n\tdots = 0;\n\tfor (cp = name; *cp != '\\0'; cp++)\n\t\tdots += (*cp == '.');\n\ttrailing_dot = 0;\n\tif (cp > name && *--cp == '.')\n\t\ttrailing_dot++;\n\n\t/* If there aren't any dots, it could be a user-level alias. */\n\tif (!dots && (cp = __res_context_hostalias\n\t\t      (ctx, name, tmp, sizeof tmp))!= NULL)\n\t  return __res_context_query (ctx, cp, class, type, answer,\n\t\t\t\t      anslen, answerp, answerp2,\n\t\t\t\t      nanswerp2, resplen2, answerp2_malloced);\n\n\t/*\n\t * If there are enough dots in the name, let's just give it a\n\t * try 'as is'. The threshold can be set with the \"ndots\" option.\n\t * Also, query 'as is', if there is a trailing dot in the name.\n\t */\n\tsaved_herrno = -1;\n\tif (dots >= statp->ndots || trailing_dot) {\n\t\tret = __res_context_querydomain (ctx, name, NULL, class, type,\n\t\t\t\t\t\t answer, anslen, answerp,\n\t\t\t\t\t\t answerp2, nanswerp2, resplen2,\n\t\t\t\t\t\t answerp2_malloced);\n\t\tif (ret > 0 || trailing_dot\n\t\t    /* If the second response is valid then we use that.  */\n\t\t    || (ret == 0 && resplen2 != NULL && *resplen2 > 0))\n\t\t\treturn (ret);\n\t\tsaved_herrno = h_errno;\n\t\ttried_as_is++;\n\t\tif (answerp && *answerp != answer) {\n\t\t\tanswer = *answerp;\n\t\t\tanslen = MAXPACKET;\n\t\t}\n\t\tif (answerp2 && *answerp2_malloced)\n\t\t  {\n\t\t    free (*answerp2);\n\t\t    *answerp2 = NULL;\n\t\t    *nanswerp2 = 0;\n\t\t    *answerp2_malloced = 0;\n\t\t  }\n\t}\n\n\t/*\n\t * We do at least one level of search if\n\t *\t- there is no dot and RES_DEFNAME is set, or\n\t *\t- there is at least one dot, there is no trailing dot,\n\t *\t  and RES_DNSRCH is set.\n\t */\n\tif ((!dots && (statp->options & RES_DEFNAMES) != 0) ||\n\t    (dots && !trailing_dot && (statp->options & RES_DNSRCH) != 0)) {\n\t\tint done = 0;\n\n\t\tfor (size_t domain_index = 0; !done; ++domain_index) {\n\t\t\tconst char *dname = __resolv_context_search_list\n\t\t\t  (ctx, domain_index);\n\t\t\tif (dname == NULL)\n\t\t\t  break;\n\t\t\tsearched = 1;\n\n\t\t\t/* __res_context_querydoman concatenates name\n\t\t\t   with dname with a \".\" in between.  If we\n\t\t\t   pass it in dname the \".\" we got from the\n\t\t\t   configured default search path, we'll end\n\t\t\t   up with \"name..\", which won't resolve.\n\t\t\t   OTOH, passing it \"\" will result in \"name.\",\n\t\t\t   which has the intended effect for both\n\t\t\t   possible representations of the root\n\t\t\t   domain.  */\n\t\t\tif (dname[0] == '.')\n\t\t\t\tdname++;\n\t\t\tif (dname[0] == '\\0')\n\t\t\t\troot_on_list++;\n\n\t\t\tret = __res_context_querydomain\n\t\t\t  (ctx, name, dname, class, type,\n\t\t\t   answer, anslen, answerp, answerp2, nanswerp2,\n\t\t\t   resplen2, answerp2_malloced);\n\t\t\tif (ret > 0 || (ret == 0 && resplen2 != NULL\n\t\t\t\t\t&& *resplen2 > 0))\n\t\t\t\treturn (ret);\n\n\t\t\tif (answerp && *answerp != answer) {\n\t\t\t\tanswer = *answerp;\n\t\t\t\tanslen = MAXPACKET;\n\t\t\t}\n\t\t\tif (answerp2 && *answerp2_malloced)\n\t\t\t  {\n\t\t\t    free (*answerp2);\n\t\t\t    *answerp2 = NULL;\n\t\t\t    *nanswerp2 = 0;\n\t\t\t    *answerp2_malloced = 0;\n\t\t\t  }\n\n\t\t\t/*\n\t\t\t * If no server present, give up.\n\t\t\t * If name isn't found in this domain,\n\t\t\t * keep trying higher domains in the search list\n\t\t\t * (if that's enabled).\n\t\t\t * On a NO_DATA error, keep trying, otherwise\n\t\t\t * a wildcard entry of another type could keep us\n\t\t\t * from finding this entry higher in the domain.\n\t\t\t * If we get some other error (negative answer or\n\t\t\t * server failure), then stop searching up,\n\t\t\t * but try the input name below in case it's\n\t\t\t * fully-qualified.\n\t\t\t */\n\t\t\tif (errno == ECONNREFUSED) {\n\t\t\t\tRES_SET_H_ERRNO(statp, TRY_AGAIN);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\tswitch (statp->res_h_errno) {\n\t\t\tcase NO_DATA:\n\t\t\t\tgot_nodata++;\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase HOST_NOT_FOUND:\n\t\t\t\t/* keep trying */\n\t\t\t\tbreak;\n\t\t\tcase TRY_AGAIN:\n\t\t\t\tif (hp->rcode == SERVFAIL) {\n\t\t\t\t\t/* try next search element, if any */\n\t\t\t\t\tgot_servfail++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\t/* anything else implies that we're done */\n\t\t\t\tdone++;\n\t\t\t}\n\n\t\t\t/* if we got here for some reason other than DNSRCH,\n\t\t\t * we only wanted one iteration of the loop, so stop.\n\t\t\t */\n\t\t\tif ((statp->options & RES_DNSRCH) == 0)\n\t\t\t\tdone++;\n\t\t}\n\t}\n\n\t/*\n\t * If the query has not already been tried as is then try it\n\t * unless RES_NOTLDQUERY is set and there were no dots.\n\t */\n\tif ((dots || !searched || (statp->options & RES_NOTLDQUERY) == 0)\n\t    && !(tried_as_is || root_on_list)) {\n\t\tret = __res_context_querydomain\n\t\t  (ctx, name, NULL, class, type,\n\t\t   answer, anslen, answerp, answerp2, nanswerp2,\n\t\t   resplen2, answerp2_malloced);\n\t\tif (ret > 0 || (ret == 0 && resplen2 != NULL\n\t\t\t\t&& *resplen2 > 0))\n\t\t\treturn (ret);\n\t}\n\n\t/* if we got here, we didn't satisfy the search.\n\t * if we did an initial full query, return that query's H_ERRNO\n\t * (note that we wouldn't be here if that query had succeeded).\n\t * else if we ever got a nodata, send that back as the reason.\n\t * else send back meaningless H_ERRNO, that being the one from\n\t * the last DNSRCH we did.\n\t */\n\tif (answerp2 && *answerp2_malloced)\n\t  {\n\t    free (*answerp2);\n\t    *answerp2 = NULL;\n\t    *nanswerp2 = 0;\n\t    *answerp2_malloced = 0;\n\t  }\n\tif (saved_herrno != -1)\n\t\tRES_SET_H_ERRNO(statp, saved_herrno);\n\telse if (got_nodata)\n\t\tRES_SET_H_ERRNO(statp, NO_DATA);\n\telse if (got_servfail)\n\t\tRES_SET_H_ERRNO(statp, TRY_AGAIN);\n\treturn (-1);\n}",
    "__res_randomid()": "unsigned int\nres_randomid (void) {\n  return 0xffff & random_bits ();\n}",
    "__res_context_send(struct resolv_context *, const unsigned char *, int, const unsigned char *, int, unsigned char *, int, unsigned char **, unsigned char **, int *, int *, int *)": "int\n__res_context_send (struct resolv_context *ctx,\n\t\t    const unsigned char *buf, int buflen,\n\t\t    const unsigned char *buf2, int buflen2,\n\t\t    unsigned char *ans, int anssiz,\n\t\t    unsigned char **ansp, unsigned char **ansp2,\n\t\t    int *nansp2, int *resplen2, int *ansp2_malloced)\n{\n\tstruct __res_state *statp = ctx->resp;\n\tint gotsomewhere, terrno, try, v_circuit, resplen;\n\t/* On some architectures send_vc is inlined and the compiler might emit\n\t   a warning indicating 'resplen' may be used uninitialized.  Note that\n\t   the warning belongs to resplen in send_vc which is used as return\n\t   value!  There the maybe-uninitialized warning is already ignored as\n\t   it is a false-positive - see comment in send_vc.\n\t   Here the variable n is set to the return value of send_vc.\n\t   See below.  */\n\tDIAG_PUSH_NEEDS_COMMENT;\n\tDIAG_IGNORE_NEEDS_COMMENT (9, \"-Wmaybe-uninitialized\");\n\tint n;\n\tDIAG_POP_NEEDS_COMMENT;\n\n\tif (statp->nscount == 0) {\n\t\t__set_errno (ESRCH);\n\t\treturn (-1);\n\t}\n\n\tif (anssiz < (buf2 == NULL ? 1 : 2) * HFIXEDSZ) {\n\t\t__set_errno (EINVAL);\n\t\treturn (-1);\n\t}\n\n\tv_circuit = ((statp->options & RES_USEVC)\n\t\t     || buflen > PACKETSZ\n\t\t     || buflen2 > PACKETSZ);\n\tgotsomewhere = 0;\n\tterrno = ETIMEDOUT;\n\n\t/*\n\t * If the ns_addr_list in the resolver context has changed, then\n\t * invalidate our cached copy and the associated timing data.\n\t */\n\tif (EXT(statp).nscount != 0) {\n\t\tint needclose = 0;\n\n\t\tif (EXT(statp).nscount != statp->nscount)\n\t\t\tneedclose++;\n\t\telse\n\t\t\tfor (unsigned int ns = 0; ns < statp->nscount; ns++) {\n\t\t\t\tif (statp->nsaddr_list[ns].sin_family != 0\n\t\t\t\t    && !sock_eq((struct sockaddr_in6 *)\n\t\t\t\t\t\t&statp->nsaddr_list[ns],\n\t\t\t\t\t\tEXT(statp).nsaddrs[ns]))\n\t\t\t\t{\n\t\t\t\t\tneedclose++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tif (needclose) {\n\t\t\t__res_iclose(statp, false);\n\t\t\tEXT(statp).nscount = 0;\n\t\t}\n\t}\n\n\t/*\n\t * Maybe initialize our private copy of the ns_addr_list.\n\t */\n\tif (EXT(statp).nscount == 0) {\n\t\tfor (unsigned int ns = 0; ns < statp->nscount; ns++) {\n\t\t\tEXT(statp).nssocks[ns] = -1;\n\t\t\tif (statp->nsaddr_list[ns].sin_family == 0)\n\t\t\t\tcontinue;\n\t\t\tif (EXT(statp).nsaddrs[ns] == NULL)\n\t\t\t\tEXT(statp).nsaddrs[ns] =\n\t\t\t\t    malloc(sizeof (struct sockaddr_in6));\n\t\t\tif (EXT(statp).nsaddrs[ns] != NULL)\n\t\t\t\tmemset (mempcpy(EXT(statp).nsaddrs[ns],\n\t\t\t\t\t\t&statp->nsaddr_list[ns],\n\t\t\t\t\t\tsizeof (struct sockaddr_in)),\n\t\t\t\t\t'\\0',\n\t\t\t\t\tsizeof (struct sockaddr_in6)\n\t\t\t\t\t- sizeof (struct sockaddr_in));\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tEXT(statp).nscount = statp->nscount;\n\t}\n\n\t/* Name server index offset.  Used to implement\n\t   RES_ROTATE.  */\n\tunsigned int ns_offset = nameserver_offset (statp);\n\n\t/*\n\t * Send request, RETRY times, or until successful.\n\t */\n\tfor (try = 0; try < statp->retry; try++) {\n\t    for (unsigned ns_shift = 0; ns_shift < statp->nscount; ns_shift++)\n\t    {\n\t\t/* The actual name server index.  This implements\n\t\t   RES_ROTATE.  */\n\t\tunsigned int ns = ns_shift + ns_offset;\n\t\tif (ns >= statp->nscount)\n\t\t\tns -= statp->nscount;\n\n\t    same_ns:\n\t\tif (__glibc_unlikely (v_circuit))       {\n\t\t\t/* Use VC; at most one attempt per server. */\n\t\t\ttry = statp->retry;\n\t\t\tn = send_vc(statp, buf, buflen, buf2, buflen2,\n\t\t\t\t    &ans, &anssiz, &terrno,\n\t\t\t\t    ns, ansp, ansp2, nansp2, resplen2,\n\t\t\t\t    ansp2_malloced);\n\t\t\tif (n < 0)\n\t\t\t\treturn (-1);\n\t\t\t/* See comment at the declaration of n.  */\n\t\t\tDIAG_PUSH_NEEDS_COMMENT;\n\t\t\tDIAG_IGNORE_NEEDS_COMMENT (9, \"-Wmaybe-uninitialized\");\n\t\t\tif (n == 0 && (buf2 == NULL || *resplen2 == 0))\n\t\t\t\tgoto next_ns;\n\t\t\tDIAG_POP_NEEDS_COMMENT;\n\t\t} else {\n\t\t\t/* Use datagrams. */\n\t\t\tn = send_dg(statp, buf, buflen, buf2, buflen2,\n\t\t\t\t    &ans, &anssiz, &terrno,\n\t\t\t\t    ns, &v_circuit, &gotsomewhere, ansp,\n\t\t\t\t    ansp2, nansp2, resplen2, ansp2_malloced);\n\t\t\tif (n < 0)\n\t\t\t\treturn (-1);\n\t\t\tif (n == 0 && (buf2 == NULL || *resplen2 == 0))\n\t\t\t\tgoto next_ns;\n\t\t\tif (v_circuit)\n\t\t\t  // XXX Check whether both requests failed or\n\t\t\t  // XXX whether one has been answered successfully\n\t\t\t\tgoto same_ns;\n\t\t}\n\n\t\tresplen = n;\n\n\t\t/* See comment at the declaration of n.  Note: resplen = n;  */\n\t\tDIAG_PUSH_NEEDS_COMMENT;\n\t\tDIAG_IGNORE_NEEDS_COMMENT (9, \"-Wmaybe-uninitialized\");\n\t\t/* Mask the AD bit in both responses unless it is\n\t\t   marked trusted.  */\n\t\tif (resplen > HFIXEDSZ)\n\t\t  {\n\t\t    if (ansp != NULL)\n\t\t      mask_ad_bit (ctx, *ansp);\n\t\t    else\n\t\t      mask_ad_bit (ctx, ans);\n\t\t  }\n\t\tDIAG_POP_NEEDS_COMMENT;\n\t\tif (resplen2 != NULL && *resplen2 > HFIXEDSZ)\n\t\t  mask_ad_bit (ctx, *ansp2);\n\n\t\t/*\n\t\t * If we have temporarily opened a virtual circuit,\n\t\t * or if we haven't been asked to keep a socket open,\n\t\t * close the socket.\n\t\t */\n\t\tif ((v_circuit && (statp->options & RES_USEVC) == 0) ||\n\t\t    (statp->options & RES_STAYOPEN) == 0) {\n\t\t\t__res_iclose(statp, false);\n\t\t}\n\t\treturn (resplen);\n next_ns: ;\n\t   } /*foreach ns*/\n\t} /*foreach retry*/\n\t__res_iclose(statp, false);\n\tif (!v_circuit) {\n\t\tif (!gotsomewhere)\n\t\t\t__set_errno (ECONNREFUSED);\t/* no nameservers found */\n\t\telse\n\t\t\t__set_errno (ETIMEDOUT);\t/* no answer obtained */\n\t} else\n\t\t__set_errno (terrno);\n\treturn (-1);\n}",
    "__resolv_context_get()": "struct resolv_context *\n__resolv_context_get (void)\n{\n  return context_get (false);\n}",
    "_nss_dns_getcanonname_r(const char *, char *, int, char **, int *, int *)": "enum nss_status\n_nss_dns_getcanonname_r (const char *name, char *buffer, size_t buflen,\n\t\t\t char **result,int *errnop, int *h_errnop)\n{\n  /* Just an alibi buffer, res_nquery will allocate a real buffer for\n     us.  */\n  unsigned char buf[20];\n  union\n  {\n    querybuf *buf;\n    unsigned char *ptr;\n  } ansp = { .ptr = buf };\n  enum nss_status status = NSS_STATUS_UNAVAIL;\n\n  struct resolv_context *ctx = __resolv_context_get ();\n  if (ctx == NULL)\n    {\n      *errnop = errno;\n      *h_errnop = NETDB_INTERNAL;\n      return NSS_STATUS_UNAVAIL;\n    }\n\n  for (int i = 0; i < nqtypes; ++i)\n    {\n      int r = __res_context_query (ctx, name, ns_c_in, qtypes[i],\n\t\t\t\t   buf, sizeof (buf), &ansp.ptr, NULL, NULL,\n\t\t\t\t   NULL, NULL);\n      if (r > 0)\n\t{\n\t  /* We need to decode the response.  Just one question record.\n\t     And if we got no answers we bail out, too.  */\n\t  if (ansp.buf->hdr.qdcount != htons (1))\n\t    continue;\n\n\t  /* Number of answers.   */\n\t  unsigned int ancount = ntohs (ansp.buf->hdr.ancount);\n\n\t  /* Beginning and end of the buffer with query, answer, and the\n\t     rest.  */\n\t  unsigned char *ptr = &ansp.buf->buf[sizeof (HEADER)];\n\t  unsigned char *endptr = ansp.ptr + r;\n\n\t  /* Skip over the query.  This is the name, type, and class.  */\n\t  int s = __libc_dn_skipname (ptr, endptr);\n\t  if (s < 0)\n\t    {\n\t    unavail:\n\t      status = NSS_STATUS_UNAVAIL;\n\t      break;\n\t    }\n\n\t  /* Skip over the name and the two 16-bit values containing type\n\t     and class.  */\n\t  ptr += s + 2 * sizeof (uint16_t);\n\n\t  while (ancount-- > 0)\n\t    {\n\t      /* Now the reply.  First again the name from the query,\n\t\t then type, class, TTL, and the length of the RDATA.\n\t\t We remember the name start.  */\n\t      unsigned char *namestart = ptr;\n\t      s = __libc_dn_skipname (ptr, endptr);\n\t      if (s < 0)\n\t\tgoto unavail;\n\n\t      ptr += s;\n\n\t      /* Check that there are enough bytes for the RR\n\t\t metadata.  */\n\t      if (endptr - ptr < 10)\n\t\tgoto unavail;\n\n\t      /* Check whether type and class match.  */\n\t      short int type;\n\t      NS_GET16 (type, ptr);\n\t      if (type == qtypes[i])\n\t\t{\n\t\t  /* We found the record.  */\n\t\t  s = __libc_dn_expand (ansp.buf->buf, endptr, namestart,\n\t\t\t\t\tbuffer, buflen);\n\t\t  if (s < 0)\n\t\t    {\n\t\t      if (errno != EMSGSIZE)\n\t\t\tgoto unavail;\n\n\t\t      /* The buffer is too small.  */\n\t\t      *errnop = ERANGE;\n\t\t      status = NSS_STATUS_TRYAGAIN;\n\t\t      h_errno = NETDB_INTERNAL;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* Success.  */\n\t\t      *result = buffer;\n\t\t      status = NSS_STATUS_SUCCESS;\n\t\t    }\n\n\t\t  goto out;\n\t\t}\n\n\t      if (type != ns_t_cname)\n\t\tgoto unavail;\n\n\t      uint16_t rrclass;\n\t      NS_GET16 (rrclass, ptr);\n\t      if (rrclass != ns_c_in)\n\t\tgoto unavail;\n\n\t      /* Skip over TTL.  */\n\t      ptr += sizeof (uint32_t);\n\n\t      /* Skip over RDATA length and RDATA itself.  */\n\t      uint16_t rdatalen;\n\t      NS_GET16 (rdatalen, ptr);\n\n\t      /* Not enough room for RDATA.  */\n\t      if (endptr - ptr < rdatalen)\n\t\tgoto unavail;\n\t      ptr += rdatalen;\n\t    }\n\t}\n\n      /* Restore original buffer before retry.  */\n      if (ansp.ptr != buf)\n\t{\n\t  free (ansp.ptr);\n\t  ansp.ptr = buf;\n\t}\n    }\n\n out:\n  *h_errnop = h_errno;\n\n  if (ansp.ptr != buf)\n    free (ansp.ptr);\n  __resolv_context_put (ctx);\n  return status;\n}",
    "_nss_dns_gethostbyname3_r(const char *, int, struct hostent *, char *, int, int *, int *, int32_t *, char **)": "enum nss_status\n_nss_dns_gethostbyname3_r (const char *name, int af, struct hostent *result,\n\t\t\t   char *buffer, size_t buflen, int *errnop,\n\t\t\t   int *h_errnop, int32_t *ttlp, char **canonp)\n{\n  struct resolv_context *ctx = __resolv_context_get ();\n  if (ctx == NULL)\n    {\n      *errnop = errno;\n      *h_errnop = NETDB_INTERNAL;\n      return NSS_STATUS_UNAVAIL;\n    }\n  enum nss_status status = gethostbyname3_context\n    (ctx, name, af, result, buffer, buflen, errnop, h_errnop, ttlp, canonp);\n  __resolv_context_put (ctx);\n  return status;\n}",
    "_nss_dns_gethostbyname2_r(const char *, int, struct hostent *, char *, int, int *, int *)": "enum nss_status\n_nss_dns_gethostbyname2_r (const char *name, int af, struct hostent *result,\n\t\t\t   char *buffer, size_t buflen, int *errnop,\n\t\t\t   int *h_errnop)\n{\n  enum nss_status status = check_name (name, h_errnop);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n  return _nss_dns_gethostbyname3_r (name, af, result, buffer, buflen, errnop,\n\t\t\t\t    h_errnop, NULL, NULL);\n}",
    "_nss_dns_getnetbyname_r(const char *, struct netent *, char *, int, int *, int *)": "enum nss_status\n_nss_dns_getnetbyname_r (const char *name, struct netent *result,\n\t\t\t char *buffer, size_t buflen, int *errnop,\n\t\t\t int *herrnop)\n{\n  /* Return entry for network with NAME.  */\n  union\n  {\n    querybuf *buf;\n    u_char *ptr;\n  } net_buffer;\n  querybuf *orig_net_buffer;\n  int anslen;\n  enum nss_status status;\n\n  struct resolv_context *ctx = __resolv_context_get ();\n  if (ctx == NULL)\n    {\n      *errnop = errno;\n      *herrnop = NETDB_INTERNAL;\n      return NSS_STATUS_UNAVAIL;\n    }\n\n  net_buffer.buf = orig_net_buffer = (querybuf *) alloca (1024);\n\n  anslen = __res_context_search\n    (ctx, name, C_IN, T_PTR, net_buffer.buf->buf,\n     1024, &net_buffer.ptr, NULL, NULL, NULL, NULL);\n  if (anslen < 0)\n    {\n      /* Nothing found.  */\n      *errnop = errno;\n      if (net_buffer.buf != orig_net_buffer)\n\tfree (net_buffer.buf);\n      __resolv_context_put (ctx);\n      return (errno == ECONNREFUSED\n\t      || errno == EPFNOSUPPORT\n\t      || errno == EAFNOSUPPORT)\n\t? NSS_STATUS_UNAVAIL : NSS_STATUS_NOTFOUND;\n    }\n\n  status = getanswer_r (net_buffer.buf, anslen, result, buffer, buflen,\n\t\t\terrnop, herrnop, BYNAME);\n  if (net_buffer.buf != orig_net_buffer)\n    free (net_buffer.buf);\n  __resolv_context_put (ctx);\n  return status;\n}",
    "__getrlimit(enum __rlimit_resource, struct rlimit *)": "int\n__getrlimit (enum __rlimit_resource resource, struct rlimit *rlimits)\n{\n  struct rlimit lim;\n\n  if (rlimits == NULL || (unsigned int) resource >= RLIMIT_NLIMITS)\n    return __hurd_fail (EINVAL);\n\n  HURD_CRITICAL_BEGIN;\n  __mutex_lock (&_hurd_rlimit_lock);\n  lim = _hurd_rlimits[resource];\n  __mutex_unlock (&_hurd_rlimit_lock);\n  HURD_CRITICAL_END;\n\n  *rlimits = lim;\n\n  return 0;\n}",
    "nice(int)": "int\nnice (int incr)\n{\n  int save;\n  int prio;\n  int result;\n\n  /* -1 is a valid priority, so we use errno to check for an error.  */\n  save = errno;\n  __set_errno (0);\n  prio = __getpriority (PRIO_PROCESS, 0);\n  if (prio == -1)\n    {\n      if (errno != 0)\n\treturn -1;\n    }\n\n  result = __setpriority (PRIO_PROCESS, 0, prio + incr);\n  if (result == -1)\n    {\n      if (errno == EACCES)\n\t__set_errno (EPERM);\n      return -1;\n    }\n\n  __set_errno (save);\n  return __getpriority (PRIO_PROCESS, 0);\n}",
    "setrlimit64(enum __rlimit_resource, const struct rlimit64 *)": "int\nsetrlimit64 (enum __rlimit_resource resource, const struct rlimit64 *rlimits)\n{\n  struct rlimit rlimits32;\n\n  if (rlimits->rlim_cur >= RLIM_INFINITY)\n    rlimits32.rlim_cur = RLIM_INFINITY;\n  else\n    rlimits32.rlim_cur = rlimits->rlim_cur;\n  if (rlimits->rlim_max >= RLIM_INFINITY)\n    rlimits32.rlim_max = RLIM_INFINITY;\n  else\n    rlimits32.rlim_max = rlimits->rlim_max;\n\n  return __setrlimit (resource, &rlimits32);\n}",
    "vlimit(enum __vlimit_resource, int)": "int\nvlimit (enum __vlimit_resource resource, int value)\n{\n  if (resource >= LIM_CPU && resource <= LIM_MAXRSS)\n    {\n      /* The rlimit codes happen to each be one less\n\t than the corresponding vlimit codes.  */\n      enum __rlimit_resource rlimit_res =\n\t(enum __rlimit_resource) ((int) resource - 1);\n      struct rlimit lims;\n\n      if (__getrlimit (rlimit_res, &lims) < 0)\n\treturn -1;\n\n      lims.rlim_cur = value;\n      return __setrlimit (rlimit_res, &lims);\n    }\n\n  __set_errno (EINVAL);\n  return -1;\n}",
    "mq_close(mqd_t)": "int\nmq_close (mqd_t mqdes)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mq_getattr(mqd_t, struct mq_attr *)": "int\nmq_getattr (mqd_t mqdes, struct mq_attr *mqstat)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mq_notify(mqd_t, const struct sigevent *)": "int\nmq_notify (mqd_t mqdes, const struct sigevent *notification)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mq_receive(mqd_t, char *, int, unsigned int *)": "ssize_t\nmq_receive (mqd_t mqdes, char *msg_ptr, size_t msg_len,\n\t    unsigned int *msg_prio)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mq_send(mqd_t, const char *, int, unsigned int)": "int\nmq_send (mqd_t mqdes, const char *msg_ptr, size_t msg_len,\n\t unsigned int msg_prio)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mq_setattr(mqd_t, const struct mq_attr *restrict, struct mq_attr *restrict)": "int\nmq_setattr (mqd_t mqdes, const struct mq_attr *__restrict mqstat,\n\t    struct mq_attr *__restrict omqstat)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mq_unlink(const char *)": "int\nmq_unlink (const char *name)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "timer_create(clockid_t, struct sigevent *, timer_t *)": "int\ntimer_create (clockid_t clock_id, struct sigevent *evp, timer_t *timerid)\n{\n  int retval = -1;\n  struct timer_node *newtimer = NULL;\n  struct thread_node *thread = NULL;\n\n  if (0\n#if defined _POSIX_CPUTIME && _POSIX_CPUTIME >= 0\n      || clock_id == CLOCK_PROCESS_CPUTIME_ID\n#endif\n#if defined _POSIX_THREAD_CPUTIME && _POSIX_THREAD_CPUTIME >= 0\n      || clock_id == CLOCK_THREAD_CPUTIME_ID\n#endif\n      )\n    {\n      /* We don't allow timers for CPU clocks.  At least not in the\n\t moment.  */\n      __set_errno (ENOTSUP);\n      return -1;\n    }\n\n  if (clock_id != CLOCK_REALTIME)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  pthread_once (&__timer_init_once_control, __timer_init_once);\n\n  if (__timer_init_failed)\n    {\n      __set_errno (ENOMEM);\n      return -1;\n    }\n\n  pthread_mutex_lock (&__timer_mutex);\n\n  newtimer = __timer_alloc ();\n  if (__glibc_unlikely (newtimer == NULL))\n    {\n      __set_errno (EAGAIN);\n      goto unlock_bail;\n    }\n\n  if (evp != NULL)\n    newtimer->event = *evp;\n  else\n    {\n      newtimer->event.sigev_notify = SIGEV_SIGNAL;\n      newtimer->event.sigev_signo = SIGALRM;\n      newtimer->event.sigev_value.sival_ptr = newtimer;\n      newtimer->event.sigev_notify_function = 0;\n    }\n\n  newtimer->event.sigev_notify_attributes = &newtimer->attr;\n  newtimer->creator_pid = getpid ();\n\n  switch (__builtin_expect (newtimer->event.sigev_notify, SIGEV_SIGNAL))\n    {\n    case SIGEV_NONE:\n    case SIGEV_SIGNAL:\n      /* We have a global thread for delivering timed signals.\n\t If it is not running, try to start it up.  */\n      thread = &__timer_signal_thread_rclk;\n      if (! thread->exists)\n\t{\n\t  if (__builtin_expect (__timer_thread_start (thread),\n\t\t\t\t1) < 0)\n\t    {\n\t      __set_errno (EAGAIN);\n\t      goto unlock_bail;\n            }\n        }\n      break;\n\n    case SIGEV_THREAD:\n      /* Copy over thread attributes or set up default ones.  */\n      if (evp->sigev_notify_attributes)\n\tnewtimer->attr = *(pthread_attr_t *) evp->sigev_notify_attributes;\n      else\n\tpthread_attr_init (&newtimer->attr);\n\n      /* Ensure thread attributes call for detached thread.  */\n      pthread_attr_setdetachstate (&newtimer->attr, PTHREAD_CREATE_DETACHED);\n\n      /* Try to find existing thread having the right attributes.  */\n      thread = __timer_thread_find_matching (&newtimer->attr, clock_id);\n\n      /* If no existing thread has these attributes, try to allocate one.  */\n      if (thread == NULL)\n\tthread = __timer_thread_alloc (&newtimer->attr, clock_id);\n\n      /* Out of luck; no threads are available.  */\n      if (__glibc_unlikely (thread == NULL))\n\t{\n\t  __set_errno (EAGAIN);\n\t  goto unlock_bail;\n\t}\n\n      /* If the thread is not running already, try to start it.  */\n      if (! thread->exists\n\t  && __builtin_expect (! __timer_thread_start (thread), 0))\n\t{\n\t  __set_errno (EAGAIN);\n\t  goto unlock_bail;\n\t}\n      break;\n\n    default:\n      __set_errno (EINVAL);\n      goto unlock_bail;\n    }\n\n  newtimer->clock = clock_id;\n  newtimer->abstime = 0;\n  newtimer->armed = 0;\n  newtimer->thread = thread;\n\n  *timerid = timer_ptr2id (newtimer);\n  retval = 0;\n\n  if (__builtin_expect (retval, 0) == -1)\n    {\n    unlock_bail:\n      if (thread != NULL)\n\t__timer_thread_dealloc (thread);\n      if (newtimer != NULL)\n\t{\n\t  timer_delref (newtimer);\n\t  __timer_dealloc (newtimer);\n\t}\n    }\n\n  pthread_mutex_unlock (&__timer_mutex);\n\n  return retval;\n}",
    "timer_delete(timer_t)": "int\ntimer_delete (timer_t timerid)\n{\n  struct timer_node *timer;\n  int retval = -1;\n\n  pthread_mutex_lock (&__timer_mutex);\n\n  timer = timer_id2ptr (timerid);\n  if (! timer_valid (timer))\n    /* Invalid timer ID or the timer is not in use.  */\n    __set_errno (EINVAL);\n  else\n    {\n      if (timer->armed && timer->thread != NULL)\n\t{\n\t  struct thread_node *thread = timer->thread;\n\t  assert (thread != NULL);\n\n\t  /* If thread is cancelled while waiting for handler to terminate,\n\t     the mutex is unlocked and timer_delete is aborted.  */\n\t  pthread_cleanup_push (__timer_mutex_cancel_handler, &__timer_mutex);\n\n\t  /* If timer is currently being serviced, wait for it to finish.  */\n\t  while (thread->current_timer == timer)\n\t    pthread_cond_wait (&thread->cond, &__timer_mutex);\n\n\t  pthread_cleanup_pop (0);\n        }\n\n      /* Remove timer from whatever queue it may be on and deallocate it.  */\n      timer->inuse = TIMER_DELETED;\n      list_unlink_ip (&timer->links);\n      timer_delref (timer);\n      retval = 0;\n    }\n\n  pthread_mutex_unlock (&__timer_mutex);\n\n  return retval;\n}",
    "timer_getoverrun(timer_t)": "int\ntimer_getoverrun (timer_t timerid)\n{\n  struct timer_node *timer;\n  int retval = -1;\n\n  pthread_mutex_lock (&__timer_mutex);\n\n  if (! timer_valid (timer = timer_id2ptr (timerid)))\n    __set_errno (EINVAL);\n  else\n    retval = timer->overrun_count;\n\n  pthread_mutex_unlock (&__timer_mutex);\n\n  return retval;\n}",
    "timer_gettime(timer_t, struct itimerspec *)": "int\ntimer_gettime (timer_t timerid, struct itimerspec *value)\n{\n  struct timer_node *timer;\n  struct timespec now, expiry;\n  int retval = -1, armed = 0, valid;\n  clock_t clock = 0;\n\n  pthread_mutex_lock (&__timer_mutex);\n\n  timer = timer_id2ptr (timerid);\n  valid = timer_valid (timer);\n\n  if (valid) {\n    armed = timer->armed;\n    expiry = timer->expirytime;\n    clock = timer->clock;\n    value->it_interval = timer->value.it_interval;\n  }\n\n  pthread_mutex_unlock (&__timer_mutex);\n\n  if (valid)\n    {\n      if (armed)\n\t{\n\t  __clock_gettime (clock, &now);\n\t  if (timespec_compare (&now, &expiry) < 0)\n\t    timespec_sub (&value->it_value, &expiry, &now);\n\t  else\n\t    {\n\t      value->it_value.tv_sec = 0;\n\t      value->it_value.tv_nsec = 0;\n\t    }\n\t}\n      else\n\t{\n\t  value->it_value.tv_sec = 0;\n\t  value->it_value.tv_nsec = 0;\n\t}\n\n      retval = 0;\n    }\n  else\n    __set_errno (EINVAL);\n\n  return retval;\n}",
    "timer_settime(timer_t, int, const struct itimerspec *, struct itimerspec *)": "int\ntimer_settime (timer_t timerid, int flags, const struct itimerspec *value,\n\t       struct itimerspec *ovalue)\n{\n  struct timer_node *timer;\n  struct thread_node *thread = NULL;\n  struct timespec now;\n  int have_now = 0, need_wakeup = 0;\n  int retval = -1;\n\n  timer = timer_id2ptr (timerid);\n  if (timer == NULL)\n    {\n      __set_errno (EINVAL);\n      goto bail;\n    }\n\n  if (! valid_nanoseconds (value->it_interval.tv_nsec)\n      || ! valid_nanoseconds (value->it_value.tv_nsec))\n    {\n      __set_errno (EINVAL);\n      goto bail;\n    }\n\n  /* Will need to know current time since this is a relative timer;\n     might as well make the system call outside of the lock now! */\n\n  if ((flags & TIMER_ABSTIME) == 0)\n    {\n      __clock_gettime (timer->clock, &now);\n      have_now = 1;\n    }\n\n  pthread_mutex_lock (&__timer_mutex);\n  timer_addref (timer);\n\n  /* One final check of timer validity; this one is possible only\n     until we have the mutex, because it accesses the inuse flag. */\n\n  if (! timer_valid(timer))\n    {\n      __set_errno (EINVAL);\n      goto unlock_bail;\n    }\n\n  if (ovalue != NULL)\n    {\n      ovalue->it_interval = timer->value.it_interval;\n\n      if (timer->armed)\n\t{\n\t  if (! have_now)\n\t    {\n\t      pthread_mutex_unlock (&__timer_mutex);\n\t      __clock_gettime (timer->clock, &now);\n\t      have_now = 1;\n\t      pthread_mutex_lock (&__timer_mutex);\n\t      timer_addref (timer);\n\t    }\n\n\t  timespec_sub (&ovalue->it_value, &timer->expirytime, &now);\n\t}\n      else\n\t{\n\t  ovalue->it_value.tv_sec = 0;\n\t  ovalue->it_value.tv_nsec = 0;\n\t}\n    }\n\n  timer->value = *value;\n\n  list_unlink_ip (&timer->links);\n  timer->armed = 0;\n\n  thread = timer->thread;\n\n  /* A value of { 0, 0 } causes the timer to be stopped. */\n  if (value->it_value.tv_sec != 0\n      || __builtin_expect (value->it_value.tv_nsec != 0, 1))\n    {\n      if ((flags & TIMER_ABSTIME) != 0)\n\t/* The user specified the expiration time.  */\n\ttimer->expirytime = value->it_value;\n      else\n\ttimespec_add (&timer->expirytime, &now, &value->it_value);\n\n      /* Only need to wake up the thread if timer is inserted\n\t at the head of the queue. */\n      if (thread != NULL)\n\tneed_wakeup = __timer_thread_queue_timer (thread, timer);\n      timer->armed = 1;\n    }\n\n  retval = 0;\n\nunlock_bail:\n  timer_delref (timer);\n  pthread_mutex_unlock (&__timer_mutex);\n\nbail:\n  if (thread != NULL && need_wakeup)\n    __timer_thread_wakeup (thread);\n\n  return retval;\n}",
    "_setjmp(struct __jmp_buf_tag *)": "int\n_setjmp (jmp_buf env)\n{\n  return __sigsetjmp (env, 0);\n}",
    "setjmp(struct __jmp_buf_tag *)": "int\nsetjmp (jmp_buf env)\n{\n  return __sigsetjmp (env, 1);\n}",
    "__libc_current_sigrtmin()": "int\n__libc_current_sigrtmin (void)\n{\n#ifdef __SIGRTMIN\n  return current_rtmin;\n#else\n  return -1;\n#endif\n}",
    "killpg(__pid_t, int)": "int\nkillpg (__pid_t pgrp, int sig)\n{\n  if (pgrp < 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __kill (- pgrp, sig);\n}",
    "__libc_sigaction(int, const struct sigaction *, struct sigaction *)": "int\n__libc_sigaction (int sig, const struct sigaction *act, struct sigaction *oact)\n{\n  int result;\n\n  struct kernel_sigaction kact, koact;\n\n  if (act)\n    {\n      kact.k_sa_handler = act->sa_handler;\n      memcpy (&kact.sa_mask, &act->sa_mask, sizeof (sigset_t));\n      kact.sa_flags = act->sa_flags;\n      SET_SA_RESTORER (&kact, act);\n    }\n\n  /* XXX The size argument hopefully will have to be changed to the\n     real size of the user-level sigset_t.  */\n  result = INLINE_SYSCALL_CALL (rt_sigaction, sig,\n\t\t\t\tact ? &kact : NULL,\n\t\t\t\toact ? &koact : NULL, STUB (act,\n\t\t\t\t\t\t\t    __NSIG_BYTES));\n\n  if (oact && result >= 0)\n    {\n      oact->sa_handler = koact.k_sa_handler;\n      memcpy (&oact->sa_mask, &koact.sa_mask, sizeof (sigset_t));\n      oact->sa_flags = koact.sa_flags;\n      RESET_SA_RESTORER (oact, &koact);\n    }\n  return result;\n}",
    "raise(int)": "int\nraise (int sig)\n{\n  int ret = __pthread_kill (__pthread_self (), sig);\n  if (ret != 0)\n    {\n      __set_errno (ret);\n      ret = -1;\n    }\n  return ret;\n}",
    "__sigaction(int, const struct sigaction *, struct sigaction *)": "int\n__sigaction (int sig, const struct sigaction *act, struct sigaction *oact)\n{\n  if (sig <= 0 || sig >= NSIG || is_internal_signal (sig))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __libc_sigaction (sig, act, oact);\n}",
    "sigaddset(sigset_t *, int)": "int\nsigaddset (sigset_t *set, int signo)\n{\n  if (set == NULL || signo <= 0 || signo >= NSIG\n      || is_internal_signal (signo))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __sigaddset (set, signo);\n  return 0;\n}",
    "sigaltstack(const stack_t *, stack_t *)": "int\nsigaltstack (const stack_t *ss, stack_t *oss)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "sigandset(sigset_t *, const sigset_t *, const sigset_t *)": "int\nsigandset (sigset_t *dest, const sigset_t *left, const sigset_t *right)\n{\n  if (!dest || !left || !right)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __sigandset (dest, left, right);\n  return 0;\n}",
    "sigdelset(sigset_t *, int)": "int\nsigdelset (sigset_t *set, int signo)\n{\n  if (set == NULL || signo <= 0 || signo >= NSIG\n      || is_internal_signal (signo))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __sigdelset (set, signo);\n  return 0;\n}",
    "sigemptyset(sigset_t *)": "int\nsigemptyset (sigset_t *set)\n{\n  if (set == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __sigemptyset (set);\n  return 0;\n}",
    "sigfillset(sigset_t *)": "int\nsigfillset (sigset_t *set)\n{\n  if (set == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __sigfillset (set);\n  clear_internal_signals (set);\n  return 0;\n}",
    "siggetmask()": "int\nsiggetmask (void)\n{\n  return __sigblock (0);\n}",
    "sighold(int)": "int\nsighold (int sig)\n{\n  sigset_t set;\n\n  sigemptyset (&set);\n  if (sigaddset (&set, sig) < 0)\n    return -1;\n  return __sigprocmask (SIG_BLOCK, &set, NULL);\n}",
    "sigignore(int)": "int\nsigignore (int sig)\n{\n  struct sigaction act;\n\n  act.sa_handler = SIG_IGN;\n  __sigemptyset (&act.sa_mask);\n  act.sa_flags = 0;\n\n  return __sigaction (sig, &act, NULL);\n}",
    "siginterrupt(int, int)": "int\nsiginterrupt (int sig, int interrupt)\n{\n#ifdef\tSA_RESTART\n  extern sigset_t _sigintr attribute_hidden;\t/* Defined in signal.c.  */\n  struct sigaction action;\n\n  if (__sigaction (sig, (struct sigaction *) NULL, &action) < 0)\n    return -1;\n\n  if (interrupt)\n    {\n      __sigaddset (&_sigintr, sig);\n      action.sa_flags &= ~SA_RESTART;\n    }\n  else\n    {\n      __sigdelset (&_sigintr, sig);\n      action.sa_flags |= SA_RESTART;\n    }\n\n  if (__sigaction (sig, &action, (struct sigaction *) NULL) < 0)\n    return -1;\n\n  return 0;\n#else\n  __set_errno (ENOSYS);\n  return -1;\n#endif\n}",
    "sigisemptyset(const sigset_t *)": "int\nsigisemptyset (const sigset_t *set)\n{\n  if (!set)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __sigisemptyset (set);\n}",
    "sigismember(const sigset_t *, int)": "int\nsigismember (const sigset_t *set, int signo)\n{\n  if (set == NULL || signo <= 0 || signo >= NSIG)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __sigismember (set, signo);\n}",
    "signal(int, __sighandler_t)": "__sighandler_t\nsignal (int sig, __sighandler_t handler)\n{\n  __set_errno (ENOSYS);\n  return SIG_ERR;\n}",
    "sigorset(sigset_t *, const sigset_t *, const sigset_t *)": "int\nsigorset (sigset_t *dest, const sigset_t *left, const sigset_t *right)\n{\n  if (!dest || !left || !right)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __sigorset (dest, left, right);\n  return 0;\n}",
    "__sigpause(int, int)": "int\n__sigpause (int sig_or_mask, int is_sig)\n{\n  sigset_t set;\n\n  if (is_sig != 0)\n    {\n      /* The modern X/Open implementation is requested.  */\n      if (__sigprocmask (0, NULL, &set) < 0\n\t  || sigdelset (&set, sig_or_mask) < 0)\n\treturn -1;\n    }\n  else if (sigset_set_old_mask (&set, sig_or_mask) < 0)\n    return -1;\n\n  /* Note the sigpause() is a cancellation point.  But since we call\n     sigsuspend() which itself is a cancellation point we do not have\n     to do anything here.  */\n  return __sigsuspend (&set);\n}",
    "sigpending(sigset_t *)": "int\nsigpending (sigset_t *set)\n{\n  return INLINE_SYSCALL_CALL (rt_sigpending, set, __NSIG_BYTES);\n}",
    "sigrelse(int)": "int\nsigrelse (int sig)\n{\n  sigset_t set;\n\n  sigemptyset (&set);\n  if (sigaddset (&set, sig) < 0)\n    return -1;\n  return __sigprocmask (SIG_UNBLOCK, &set, NULL);\n}",
    "sigset(int, __sighandler_t)": "__sighandler_t\nsigset (int sig, __sighandler_t disp)\n{\n  struct sigaction act;\n  struct sigaction oact;\n  sigset_t set;\n  sigset_t oset;\n\n  __sigemptyset (&set);\n  if (sigaddset (&set, sig) < 0)\n    return SIG_ERR;\n\n  if (disp == SIG_HOLD)\n    {\n      /* Add the signal to the current signal mask.  */\n      if (__sigprocmask (SIG_BLOCK, &set, &oset) < 0)\n\treturn SIG_ERR;\n\n      /* If the signal was already blocked signal this to the caller.  */\n      if (__sigismember (&oset, sig))\n\treturn SIG_HOLD;\n\n      /* We need to determine whether a specific handler is installed.  */\n      if (__sigaction (sig, NULL, &oact) < 0)\n\treturn SIG_ERR;\n\n      return oact.sa_handler;\n    }\n  else\n    {\n      act.sa_handler = disp;\n      __sigemptyset (&act.sa_mask);\n      act.sa_flags = 0;\n      if (__sigaction (sig, &act, &oact) < 0)\n\treturn SIG_ERR;\n\n      /* Remove the signal from the current signal mask.  */\n      if (__sigprocmask (SIG_UNBLOCK, &set, &oset) < 0)\n\treturn SIG_ERR;\n\n      /* If the signal was already blocked return SIG_HOLD.  */\n      return __sigismember (&oset, sig) ? SIG_HOLD : oact.sa_handler;\n    }\n}",
    "sigstack(struct sigstack *, struct sigstack *)": "int\nsigstack (struct sigstack *ss, struct sigstack *oss)\n{\n  stack_t sas;\n  stack_t *sasp = NULL;\n  stack_t osas;\n  stack_t *osasp = oss == NULL ? NULL : &osas;\n  int result;\n\n  if (ss != NULL)\n    {\n      /* We have to convert the information.  */\n      sas.ss_sp = ss->ss_sp;\n      sas.ss_flags = ss->ss_onstack ? SS_ONSTACK : 0;\n\n      /* For the size of the stack we have no value we can pass to the\n\t kernel.  This is why this function should not be used.  We simply\n\t assume that all the memory down to address zero (in case the stack\n\t grows down) is available.  */\n      sas.ss_size = ss->ss_sp - NULL;\n\n      sasp = &sas;\n    }\n\n  /* Call the kernel.  */\n  result = __sigaltstack (sasp, osasp);\n\n  /* Convert the result, if wanted and possible.  */\n  if (result == 0 && oss != NULL)\n    {\n      oss->ss_sp = osas.ss_sp;\n      oss->ss_onstack = (osas.ss_flags & SS_ONSTACK) != 0;\n    }\n\n  return result;\n}",
    "__sigsuspend(const sigset_t *)": "int\n__sigsuspend (const sigset_t *set)\n{\n  sigset_t oset;\n  int save;\n\n  if (set == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (sigprocmask (SIG_SETMASK, set, &oset) < 0)\n    return -1;\n\n  (void) pause();\n  save = errno;\n\n  if (sigprocmask (SIG_SETMASK, &oset, (sigset_t *) NULL) < 0)\n    return -1;\n\n  __set_errno (save);\n  return -1;\n}",
    "__sigtimedwait(const sigset_t *, siginfo_t *, const struct timespec *)": "int\n__sigtimedwait (const sigset_t *set, siginfo_t *info,\n\t\tconst struct timespec *timeout)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__sysv_signal(int, __sighandler_t)": "__sighandler_t\n__sysv_signal (int sig, __sighandler_t handler)\n{\n  struct sigaction act, oact;\n\n  /* Check signal extents to protect __sigismember.  */\n  if (handler == SIG_ERR || sig < 1 || sig >= NSIG)\n    {\n      __set_errno (EINVAL);\n      return SIG_ERR;\n    }\n\n  act.sa_handler = handler;\n  __sigemptyset (&act.sa_mask);\n  act.sa_flags = SA_ONESHOT | SA_NOMASK | SA_INTERRUPT;\n  act.sa_flags &= ~SA_RESTART;\n  if (__sigaction (sig, &act, &oact) < 0)\n    return SIG_ERR;\n\n  return oact.sa_handler;\n}",
    "accept(int, struct sockaddr *restrict, socklen_t *)": "int\naccept (int fd, __SOCKADDR_ARG addrarg, socklen_t *addr_len)\n{\n  return __libc_accept4 (fd, addrarg, addr_len, 0);\n}",
    "__connect(int, const struct sockaddr *, socklen_t)": "int\n__connect (int fd, __CONST_SOCKADDR_ARG addrarg, socklen_t len)\n{\n  error_t err;\n  addr_port_t aport;\n  const struct sockaddr_un *addr = addrarg.__sockaddr_un__;\n  int cancel_oldtype;\n\n  if (addr->sun_family == AF_LOCAL)\n    {\n      char *name = _hurd_sun_path_dupa (addr, len);\n      /* For the local domain, we must look up the name as a file and talk\n\t to it with the ifsock protocol.  */\n      file_t file;\n      cancel_oldtype = LIBC_CANCEL_ASYNC();\n      file = __file_name_lookup (name, 0, 0);\n      LIBC_CANCEL_RESET (cancel_oldtype);\n      if (file == MACH_PORT_NULL)\n\treturn -1;\n      err = __ifsock_getsockaddr (file, &aport);\n      __mach_port_deallocate (__mach_task_self (), file);\n      if (err == MIG_BAD_ID || err == EOPNOTSUPP)\n\t/* The file did not grok the ifsock protocol.  */\n\terr = ENOTSOCK;\n      if (err)\n\treturn __hurd_fail (err);\n    }\n  else\n    err = EIEIO;\n\n  err = HURD_DPORT_USE_CANCEL (fd,\n\t\t\t({\n\t\t\t  if (err)\n\t\t\t    err = __socket_create_address (port,\n\t\t\t\t\t\t\t   addr->sun_family,\n\t\t\t\t\t\t\t   (char *) addr, len,\n\t\t\t\t\t\t\t   &aport);\n\t\t\t  if (! err)\n\t\t\t    {\n\t\t\t      cancel_oldtype = LIBC_CANCEL_ASYNC();\n\t\t\t      err = __socket_connect (port, aport);\n\t\t\t      LIBC_CANCEL_RESET (cancel_oldtype);\n\t\t\t      __mach_port_deallocate (__mach_task_self (),\n\t\t\t\t\t\t      aport);\n\t\t\t    }\n\t\t\t  err;\n\t\t\t}));\n\n  return err ? __hurd_dfail (fd, err) : 0;\n}",
    "getpeername(int, struct sockaddr *restrict, socklen_t *)": "int\ngetpeername (int fd, __SOCKADDR_ARG addr, socklen_t *len)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "getsockopt(int, int, int, void *, socklen_t *)": "int\ngetsockopt (int fd,\n\t    int level,\n\t    int optname,\n\t    void *optval,\n\t    socklen_t *optlen)\n{\n  error_t err;\n  char *buf = optval;\n  mach_msg_type_number_t buflen = *optlen;\n\n  if (err = HURD_DPORT_USE (fd, __socket_getopt (port,\n\t\t\t\t\t\t level, optname,\n\t\t\t\t\t\t &buf, &buflen)))\n    return __hurd_dfail (fd, err);\n\n  if (*optlen > buflen)\n    *optlen = buflen;\n  if (buf != optval)\n    {\n      memcpy (optval, buf, *optlen);\n      __vm_deallocate (__mach_task_self (), (vm_address_t) buf, buflen);\n    }\n\n  return 0;\n}",
    "isfdtype(int, int)": "int\nisfdtype (int fildes, int fdtype)\n{\n  struct __stat64_t64 st;\n  int result;\n\n  {\n    int save_error = errno;\n    result = __fstat64_time64 (fildes, &st);\n    __set_errno (save_error);\n  }\n\n  return result ?: (st.st_mode & S_IFMT) == (mode_t) fdtype;\n}",
    "__recv(int, void *, int, int)": "ssize_t\n__recv (int fd, void *buf, size_t n, int flags)\n{\n  error_t err;\n  mach_port_t addrport;\n  char *bufp = buf;\n  mach_msg_type_number_t nread = n;\n  mach_port_t *ports;\n  mach_msg_type_number_t nports = 0;\n  char *cdata = NULL;\n  mach_msg_type_number_t clen = 0;\n  int cancel_oldtype;\n\n  cancel_oldtype = LIBC_CANCEL_ASYNC();\n  err = HURD_DPORT_USE_CANCEL (fd, __socket_recv (port, &addrport,\n\t\t\t\t\t\t  flags, &bufp, &nread,\n\t\t\t\t\t\t  &ports, &nports,\n\t\t\t\t\t\t  &cdata, &clen,\n\t\t\t\t\t\t  &flags,\n\t\t\t\t\t\t  n));\n  LIBC_CANCEL_RESET (cancel_oldtype);\n\n  if (err == MIG_BAD_ID || err == EOPNOTSUPP)\n    /* The file did not grok the socket protocol.  */\n    err = ENOTSOCK;\n  if (err)\n    return __hurd_sockfail (fd, flags, err);\n\n  if (MACH_PORT_VALID (addrport))\n    __mach_port_deallocate (__mach_task_self (), addrport);\n  __vm_deallocate (__mach_task_self (), (vm_address_t) cdata, clen);\n\n  if (bufp != buf)\n    {\n      memcpy (buf, bufp, nread);\n      __vm_deallocate (__mach_task_self (), (vm_address_t) bufp, nread);\n    }\n\n  return nread;\n}",
    "recvmmsg(int, struct mmsghdr *, unsigned int, int, struct timespec *)": "int\nrecvmmsg (int fd, struct mmsghdr *vmessages, unsigned int vlen, int flags,\n\t  struct timespec *tmo)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__libc_sa_len(sa_family_t)": "int\n__libc_sa_len (sa_family_t af)\n{\n  switch (af)\n    {\n# ifdef HAVE_NETATALK_AT_H\n    case AF_APPLETALK:\n      return sizeof (struct sockaddr_at);\n# endif\n# ifdef HAVE_NETASH_ASH_H\n    case AF_ASH:\n      return sizeof (struct sockaddr_ash);\n# endif\n# ifdef HAVE_NETAX25_AX25_H\n    case AF_AX25:\n      return sizeof (struct sockaddr_ax25);\n# endif\n# ifdef HAVE_NETECONET_EC_H\n    case AF_ECONET:\n      return sizeof (struct sockaddr_ec);\n# endif\n    case AF_INET:\n      return sizeof (struct sockaddr_in);\n    case AF_INET6:\n      return sizeof (struct sockaddr_in6);\n# ifdef HAVE_NETIPX_IPX_H\n    case AF_IPX:\n      return sizeof (struct sockaddr_ipx);\n# endif\n# ifdef HAVE_NETIUCV_IUCV_H\n    case AF_IUCV:\n      return sizeof (struct sockaddr_iucv);\n# endif\n    case AF_LOCAL:\n      return sizeof (struct sockaddr_un);\n# ifdef HAVE_NETPACKET_PACKET_H\n    case AF_PACKET:\n      return sizeof (struct sockaddr_ll);\n# endif\n# ifdef HAVE_NETROSE_ROSE_H\n    case AF_ROSE:\n      return sizeof (struct sockaddr_rose);\n# endif\n    }\n  return 0;\n}",
    "__send(int, const void *, int, int)": "ssize_t\n__send (int fd, const void *buf, size_t n, int flags)\n{\n  error_t err;\n  vm_size_t wrote;\n  int cancel_oldtype;\n\n  cancel_oldtype = LIBC_CANCEL_ASYNC();\n  err = HURD_DPORT_USE_CANCEL (fd, __socket_send (port, MACH_PORT_NULL,\n\t\t\t\t\t\t  flags, buf, n,\n\t\t\t\t\t\t  NULL, MACH_MSG_TYPE_COPY_SEND, 0,\n\t\t\t\t\t\t  NULL, 0, &wrote));\n  LIBC_CANCEL_RESET (cancel_oldtype);\n\n  if (err == MIG_BAD_ID || err == EOPNOTSUPP)\n    /* The file did not grok the socket protocol.  */\n    err = ENOTSOCK;\n\n  return err ? __hurd_sockfail (fd, flags, err) : wrote;\n}",
    "__sendmmsg(int, struct mmsghdr *, unsigned int, int)": "int\n__sendmmsg (int fd, struct mmsghdr *vmessages, unsigned int vlen, int flags)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "shutdown(int, int)": "int\nshutdown (int fd, int how)\n{\n  error_t err = HURD_DPORT_USE (fd, __socket_shutdown (port, how));\n  if (err)\n    return __hurd_dfail (fd, err);\n  return 0;\n}",
    "sockatmark(int)": "int\nsockatmark (int fd)\n{\n  int answ;\n\n  return __ioctl (fd, SIOCATMARK, &answ) == -1 ? -1 : answ;\n}",
    "__socket(int, int, int)": "int\n__socket (int fd, int type, int domain)\n{\n#ifdef __ASSUME_SOCKET_SYSCALL\n  return INLINE_SYSCALL_CALL (socket, fd, type, domain);\n#else\n  return SOCKETCALL (socket, fd, type, domain);\n#endif\n}",
    "socketpair(int, int, int, int *)": "int\nsocketpair (int domain, int type, int protocol, int fds[2])\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "ctermid(char *)": "char *\nctermid (char *s)\n{\n  char *name = (char /*drop const*/ *) \"/dev/tty\";\n\n  if (s == NULL)\n    return name;\n\n  return strcpy (s, name);\n}",
    "cuserid(char *)": "char *\ncuserid (char *s)\n{\n  static char name[L_cuserid];\n  char buf[NSS_BUFLEN_PASSWD];\n  struct passwd pwent;\n  struct passwd *pwptr;\n\n  if (__getpwuid_r (__geteuid (), &pwent, buf, sizeof (buf), &pwptr)\n      || pwptr == NULL)\n    {\n      if (s != NULL)\n\ts[0] = '\\0';\n      return s;\n    }\n\n  if (s == NULL)\n    s = name;\n  s[L_cuserid - 1] = '\\0';\n  return strncpy (s, pwptr->pw_name, L_cuserid - 1);\n}",
    "getw(FILE *)": "int\ngetw (FILE *stream)\n{\n  int w;\n\n  /* Is there a better way?  */\n  if (fread ((void *) &w, sizeof (w), 1, stream) != 1)\n    return EOF;\n  return w;\n}",
    "__isoc23_fscanf(FILE *, const char *, ...)": "int\n__isoc23_fscanf (FILE *stream, const char *format, ...)\n{\n  va_list arg;\n  int done;\n\n  va_start (arg, format);\n  done = __vfscanf_internal (stream, format, arg,\n\t\t\t     SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc23_scanf(const char *, ...)": "int\n__isoc23_scanf (const char *format, ...)\n{\n  va_list arg;\n  int done;\n\n  va_start (arg, format);\n  done = __vfscanf_internal (stdin, format, arg,\n\t\t\t     SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc23_sscanf(const char *, const char *, ...)": "int\n__isoc23_sscanf (const char *s, const char *format, ...)\n{\n  va_list arg;\n  int done;\n  _IO_strfile sf;\n  FILE *f = _IO_strfile_read (&sf, s);\n\n  va_start (arg, format);\n  done = __vfscanf_internal (f, format, arg,\n\t\t\t     SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc23_vfscanf(FILE *, const char *, va_list)": "int\n__isoc23_vfscanf (FILE *stream, const char *format, va_list args)\n{\n  return __vfscanf_internal (stream, format, args,\n\t\t\t     SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n}",
    "__isoc23_vscanf(const char *, va_list)": "int\n__isoc23_vscanf (const char *format, va_list args)\n{\n  return __vfscanf_internal (stdin, format, args,\n\t\t\t     SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n}",
    "__isoc23_vsscanf(const char *, const char *, int)": "int\n__isoc23_vsscanf (const char *string, const char *format, va_list args)\n{\n  _IO_strfile sf;\n  FILE *f = _IO_strfile_read (&sf, string);\n  return __vfscanf_internal (f, format, args,\n\t\t\t     SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n}",
    "__isoc99_fscanf(FILE *, const char *, ...)": "int\n__isoc99_fscanf (FILE *stream, const char *format, ...)\n{\n  va_list arg;\n  int done;\n\n  va_start (arg, format);\n  done = __vfscanf_internal (stream, format, arg, SCANF_ISOC99_A);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc99_scanf(const char *, ...)": "int\n__isoc99_scanf (const char *format, ...)\n{\n  va_list arg;\n  int done;\n\n  va_start (arg, format);\n  done = __vfscanf_internal (stdin, format, arg, SCANF_ISOC99_A);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc99_sscanf(const char *, const char *, ...)": "int\n__isoc99_sscanf (const char *s, const char *format, ...)\n{\n  va_list arg;\n  int done;\n  _IO_strfile sf;\n  FILE *f = _IO_strfile_read (&sf, s);\n\n  va_start (arg, format);\n  done = __vfscanf_internal (f, format, arg, SCANF_ISOC99_A);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc99_vfscanf(FILE *, const char *, va_list)": "int\n__isoc99_vfscanf (FILE *stream, const char *format, va_list args)\n{\n  return __vfscanf_internal (stream, format, args, SCANF_ISOC99_A);\n}",
    "__isoc99_vscanf(const char *, va_list)": "int\n__isoc99_vscanf (const char *format, va_list args)\n{\n  return __vfscanf_internal (stdin, format, args, SCANF_ISOC99_A);\n}",
    "__isoc99_vsscanf(const char *, const char *, int)": "int\n__isoc99_vsscanf (const char *string, const char *format, va_list args)\n{\n  _IO_strfile sf;\n  FILE *f = _IO_strfile_read (&sf, string);\n  return __vfscanf_internal (f, format, args, SCANF_ISOC99_A);\n}",
    "perror(const char *)": "void\nperror (const char *s)\n{\n  int errnum = errno;\n  FILE *fp;\n  int fd = -1;\n\n\n  /* The standard says that 'perror' must not change the orientation\n     of the stream.  What is supposed to happen when the stream isn't\n     oriented yet?  In this case we'll create a new stream which is\n     using the same underlying file descriptor.  */\n  if (__builtin_expect (_IO_fwide (stderr, 0) != 0, 1)\n      || (fd = __fileno (stderr)) == -1\n      || (fd = __dup (fd)) == -1\n      || (fp = fdopen (fd, \"w+\")) == NULL)\n    {\n      if (__glibc_unlikely (fd != -1))\n\t__close (fd);\n\n      /* Use standard error as is.  */\n      perror_internal (stderr, s, errnum);\n    }\n  else\n    {\n      /* We don't have to do any special hacks regarding the file\n\t position.  Since the stderr stream wasn't used so far we just\n\t write to the descriptor.  */\n      perror_internal (fp, s, errnum);\n\n      if (_IO_ferror_unlocked (fp))\n\tstderr->_flags |= _IO_ERR_SEEN;\n\n      /* Close the stream.  */\n      fclose (fp);\n    }\n}",
    "parse_printf_format(const char *, int, int *)": "size_t\nparse_printf_format (const char *fmt, size_t n, int *argtypes)\n{\n  size_t nargs;\t\t\t/* Number of arguments.  */\n  size_t max_ref_arg;\t\t/* Highest index used in a positional arg.  */\n  struct printf_spec spec;\n  const unsigned char *f = (const unsigned char *) fmt;\n  bool failed;\n\n  nargs = 0;\n  max_ref_arg = 0;\n\n  /* Search for format specifications.  */\n  for (f = __find_specmb (f); *f != '\\0'; f = spec.next_fmt)\n    {\n      /* Parse this spec.  */\n      nargs += __parse_one_specmb (f, nargs, &spec, &max_ref_arg, &failed);\n\n      /* If the width is determined by an argument, it is an int.  */\n      if (spec.width_arg != -1 && (size_t) spec.width_arg < n)\n\targtypes[spec.width_arg] = PA_INT;\n\n      /* If the precision is determined by an argument, it is an int.  */\n      if (spec.prec_arg != -1 && (size_t) spec.prec_arg < n)\n\targtypes[spec.prec_arg] = PA_INT;\n\n      if ((size_t) spec.data_arg < n)\n\tswitch (spec.ndata_args)\n\t  {\n\t  case 0:\t\t/* No arguments.  */\n\t    break;\n\t  case 1:\t\t/* One argument; we already have the type.  */\n\t    argtypes[spec.data_arg] = spec.data_arg_type;\n\t    break;\n\t  default:\n\t    /* We have more than one argument for this format spec.  We must\n               call the arginfo function again to determine all the types.  */\n\t    (void) (*__printf_arginfo_table[spec.info.spec])\n\t      (&spec.info, n - spec.data_arg, &argtypes[spec.data_arg],\n\t       &spec.size);\n\t    break;\n\t  }\n    }\n\n  return MAX (nargs, max_ref_arg);\n}",
    "printf_size_info(const struct printf_info *, int, int *)": "int\nprintf_size_info (const struct printf_info *info, size_t n, int *argtypes)\n{\n  /* We need only one double or long double argument.  */\n  if (n >= 1)\n    argtypes[0] = PA_DOUBLE | (info->is_long_double ? PA_FLAG_LONG_DOUBLE : 0);\n\n  return 1;\n}",
    "psiginfo(const siginfo_t *, const char *)": "void\npsiginfo (const siginfo_t *pinfo, const char *s)\n{\n  char buf[512];\n  FILE *fp = __fmemopen (buf, sizeof (buf), \"w\");\n  if (fp == NULL)\n    {\n      const char *colon;\n\n      if (s == NULL || *s == '\\0')\n\ts = colon = \"\";\n      else\n\tcolon = \": \";\n\n      __fxprintf (NULL, \"%s%ssignal %d\\n\", s, colon, pinfo->si_signo);\n      return;\n    }\n\n  if (s != NULL && *s != '\\0')\n    fprintf (fp, \"%s: \", s);\n\n  const char *desc;\n  if (pinfo->si_signo >= 0 && pinfo->si_signo < NSIG\n      && ((desc = __sys_siglist[pinfo->si_signo]) != NULL\n#ifdef SIGRTMIN\n\t  || (pinfo->si_signo >= SIGRTMIN && pinfo->si_signo < SIGRTMAX)\n#endif\n\t ))\n    {\n#ifdef SIGRTMIN\n      if (desc == NULL)\n\t{\n\t  if (pinfo->si_signo - SIGRTMIN < SIGRTMAX - pinfo->si_signo)\n\t    {\n\t      if (pinfo->si_signo == SIGRTMIN)\n\t\tfprintf (fp, \"SIGRTMIN (\");\n\t      else\n\t\tfprintf (fp, \"SIGRTMIN+%d (\", pinfo->si_signo - SIGRTMIN);\n\t    }\n\t  else\n\t    {\n\t      if (pinfo->si_signo == SIGRTMAX)\n\t\tfprintf (fp, \"SIGRTMAX (\");\n\t      else\n\t\tfprintf (fp, \"SIGRTMAX-%d (\", SIGRTMAX - pinfo->si_signo);\n\t    }\n\t}\n      else\n#endif\n\tfprintf (fp, \"%s (\", _(desc));\n\n      const char *base = NULL;\n      const uint8_t *offarr = NULL;\n      size_t offarr_len = 0;\n      switch (pinfo->si_signo)\n\t{\n#define H(sig) \\\n\tcase sig:\t\t\t\t\t\t\t      \\\n\t  base = C(codestrs_, sig).str;\t\t\t\t\t      \\\n\t  offarr = C (codes_, sig);\t\t\t\t\t      \\\n\t  offarr_len = array_length (C (codes_, sig));\t\t\t      \\\n\t  break\n\n\t  H (SIGILL);\n\t  H (SIGFPE);\n\t  H (SIGSEGV);\n\t  H (SIGBUS);\n\t  H (SIGTRAP);\n\t  H (SIGCHLD);\n\t  H (SIGPOLL);\n\t}\n\n      const char *str = NULL;\n      if (offarr != NULL\n\t  && pinfo->si_code >= 1 && pinfo->si_code <= offarr_len)\n\tstr = base + offarr[pinfo->si_code - 1];\n      else\n\tswitch (pinfo->si_code)\n\t  {\n\t  case SI_USER:\n\t    str = N_(\"Signal sent by kill()\");\n\t    break;\n\t  case SI_QUEUE:\n\t    str = N_(\"Signal sent by sigqueue()\");\n\t    break;\n\t  case SI_TIMER:\n\t    str = N_(\"Signal generated by the expiration of a timer\");\n\t    break;\n\t  case SI_ASYNCIO:\n\t    str = N_(\"\\\nSignal generated by the completion of an asynchronous I/O request\");\n\t    break;\n\t  case SI_MESGQ:\n\t    str = N_(\"\\\nSignal generated by the arrival of a message on an empty message queue\");\n\t    break;\n#ifdef SI_TKILL\n\t  case SI_TKILL:\n\t    str = N_(\"Signal sent by tkill()\");\n\t    break;\n#endif\n#ifdef SI_ASYNCNL\n\t  case SI_ASYNCNL:\n\t    str = N_(\"\\\nSignal generated by the completion of an asynchronous name lookup request\");\n\t    break;\n#endif\n#ifdef SI_SIGIO\n\t  case SI_SIGIO:\n\t    str = N_(\"\\\nSignal generated by the completion of an I/O request\");\n\t    break;\n#endif\n#ifdef SI_KERNEL\n\t  case SI_KERNEL:\n\t    str = N_(\"Signal sent by the kernel\");\n\t    break;\n#endif\n\t  }\n\n      if (str != NULL)\n\tfprintf (fp, \"%s \", _(str));\n      else\n\tfprintf (fp, \"%d \", pinfo->si_code);\n\n      if (pinfo->si_signo == SIGILL || pinfo->si_signo == SIGFPE\n\t  || pinfo->si_signo == SIGSEGV || pinfo->si_signo == SIGBUS)\n\tfprintf (fp, \"[%p])\\n\", pinfo->si_addr);\n      else if (pinfo->si_signo == SIGCHLD)\n\tfprintf (fp, \"%ld %d %ld)\\n\",\n\t\t (long int) pinfo->si_pid, pinfo->si_status,\n\t\t (long int) pinfo->si_uid);\n      else if (pinfo->si_signo == SIGPOLL)\n\tfprintf (fp, \"%ld)\\n\", (long int) pinfo->si_band);\n      else\n\tfprintf (fp, \"%ld %ld)\\n\",\n\t\t (long int) pinfo->si_pid, (long int) pinfo->si_uid);\n    }\n  else\n    fprintf (fp, _(\"Unknown signal %d\\n\"),  pinfo->si_signo);\n\n  fclose (fp);\n\n  __write_nocancel (STDERR_FILENO, buf, strlen (buf));\n}",
    "psignal(int, const char *)": "void\npsignal (int sig, const char *s)\n{\n  const char *colon, *desc;\n\n  if (s == NULL || *s == '\\0')\n    s = colon = \"\";\n  else\n    colon = \": \";\n\n  if (sig >= 0 && sig < NSIG && (desc = __sys_siglist[sig]) != NULL)\n    (void) __fxprintf (NULL, \"%s%s%s\\n\", s, colon, _(desc));\n  else\n    {\n      char *buf;\n\n      if (__asprintf (&buf, _(\"%s%sUnknown signal %d\\n\"), s, colon, sig) < 0)\n\t(void) __fxprintf (NULL, \"%s%s%s\\n\", s, colon, _(\"Unknown signal\"));\n      else\n\t{\n\t  (void) __fxprintf (NULL, \"%s\", buf);\n\n\t  free (buf);\n\t}\n    }\n}",
    "putw(int, FILE *)": "int\nputw (int w, FILE *stream)\n{\n  /* Is there a better way?  */\n  if (fwrite ((const void *) &w, sizeof (w), 1, stream) < 1)\n    return EOF;\n  return 0;\n}",
    "remove(const char *)": "int\nremove (const char *file)\n{\n  /* First try to unlink since this is more frequently the necessary action. */\n  if (__unlink (file) != 0\n      /* If it is indeed a directory...  */\n      && (IS_NO_DIRECTORY_ERROR\n\t  /* ...try to remove it.  */\n\t  || __rmdir (file) != 0))\n    /* Cannot remove the object for whatever reason.  */\n    return -1;\n\n  return 0;\n}",
    "rename(const char *, const char *)": "int\nrename (const char *old, const char *new)\n{\n#if defined (__NR_rename)\n  return INLINE_SYSCALL_CALL (rename, old, new);\n#elif defined (__NR_renameat)\n  return INLINE_SYSCALL_CALL (renameat, AT_FDCWD, old, AT_FDCWD, new);\n#else\n  return INLINE_SYSCALL_CALL (renameat2, AT_FDCWD, old, AT_FDCWD, new, 0);\n#endif\n}",
    "tempnam(const char *, const char *)": "char *\ntempnam (const char *dir, const char *pfx)\n{\n  char buf[FILENAME_MAX];\n\n  if (__path_search (buf, FILENAME_MAX, dir, pfx, 1))\n    return NULL;\n\n  if (__gen_tempname (buf, 0, 0, __GT_NOCREATE))\n    return NULL;\n\n  return __strdup (buf);\n}",
    "tmpnam(char *)": "char *\ntmpnam (char s[L_tmpnam])\n{\n  /* By using two buffers we manage to be thread safe in the case\n     where S != NULL.  */\n  char tmpbufmem[L_tmpnam];\n  char *tmpbuf = s ?: tmpbufmem;\n\n  /* In the following call we use the buffer pointed to by S if\n     non-NULL although we don't know the size.  But we limit the size\n     to L_tmpnam characters in any case.  */\n  if (__builtin_expect (__path_search (tmpbuf, L_tmpnam, NULL, NULL, 0),\n\t\t\t0))\n    return NULL;\n\n  if (__glibc_unlikely (__gen_tempname (tmpbuf, 0, 0, __GT_NOCREATE)))\n    return NULL;\n\n  if (s == NULL)\n    return (char *) memcpy (tmpnam_buffer, tmpbuf, L_tmpnam);\n\n  return s;\n}",
    "tmpnam_r(char *)": "char *\ntmpnam_r (char s[L_tmpnam])\n{\n  if (s == NULL)\n    return NULL;\n\n  if (__path_search (s, L_tmpnam, NULL, NULL, 0))\n    return NULL;\n  if (__gen_tempname (s, 0, 0, __GT_NOCREATE))\n    return NULL;\n\n  return s;\n}",
    "a64l(const char *)": "long int\na64l (const char *string)\n{\n  const char *ptr = string;\n  unsigned long int result = 0ul;\n  const char *end = ptr + 6;\n  int shift = 0;\n\n  do\n    {\n      unsigned index;\n      unsigned value;\n\n      index = *ptr - TABLE_BASE;\n      if ((unsigned int) index >= TABLE_SIZE)\n\tbreak;\n      value = (int) a64l_table[index];\n      if (value == (int) XX)\n\tbreak;\n      ++ptr;\n      result |= value << shift;\n      shift += 6;\n    }\n  while (ptr != end);\n\n  return (long int) result;\n}",
    "abort()": "void\nabort (void)\n{\n  struct sigaction act;\n\n  /* First acquire the lock.  */\n  __libc_lock_lock_recursive (lock);\n\n  /* Now it's for sure we are alone.  But recursive calls are possible.  */\n\n  /* Unblock SIGABRT.  */\n  if (stage == 0)\n    {\n      ++stage;\n      internal_sigset_t sigs;\n      internal_sigemptyset (&sigs);\n      internal_sigaddset (&sigs, SIGABRT);\n      internal_sigprocmask (SIG_UNBLOCK, &sigs, NULL);\n    }\n\n  /* Send signal which possibly calls a user handler.  */\n  if (stage == 1)\n    {\n      /* This stage is special: we must allow repeated calls of\n\t `abort' when a user defined handler for SIGABRT is installed.\n\t This is risky since the `raise' implementation might also\n\t fail but I don't see another possibility.  */\n      int save_stage = stage;\n\n      stage = 0;\n      __libc_lock_unlock_recursive (lock);\n\n      raise (SIGABRT);\n\n      __libc_lock_lock_recursive (lock);\n      stage = save_stage + 1;\n    }\n\n  /* There was a handler installed.  Now remove it.  */\n  if (stage == 2)\n    {\n      ++stage;\n      memset (&act, '\\0', sizeof (struct sigaction));\n      act.sa_handler = SIG_DFL;\n      __sigfillset (&act.sa_mask);\n      act.sa_flags = 0;\n      __sigaction (SIGABRT, &act, NULL);\n    }\n\n  /* Try again.  */\n  if (stage == 3)\n    {\n      ++stage;\n      raise (SIGABRT);\n    }\n\n  /* Now try to abort using the system specific command.  */\n  if (stage == 4)\n    {\n      ++stage;\n      ABORT_INSTRUCTION;\n    }\n\n  /* If we can't signal ourselves and the abort instruction failed, exit.  */\n  if (stage == 5)\n    {\n      ++stage;\n      _exit (127);\n    }\n\n  /* If even this fails try to use the provided instruction to crash\n     or otherwise make sure we never return.  */\n  while (1)\n    /* Try for ever and ever.  */\n    ABORT_INSTRUCTION;\n}",
    "abs(int)": "int\nabs (int i)\n{\n  return i < 0 ? -i : i;\n}",
    "atof(const char *)": "double\natof (const char *nptr)\n{\n  return strtod (nptr, (char **) NULL);\n}",
    "atoi(const char *)": "int\natoi (const char *nptr)\n{\n  return (int) strtol (nptr, (char **) NULL, 10);\n}",
    "atol(const char *)": "long int\natol (const char *nptr)\n{\n  return strtol (nptr, (char **) NULL, 10);\n}",
    "atoll(const char *)": "long long int\natoll (const char *nptr)\n{\n  return strtoll (nptr, (char **) NULL, 10);\n}",
    "bsearch(const void *, const void *, int, int, __compar_fn_t)": "void *\nbsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,\n\t __compar_fn_t __compar)\n{\n  size_t __l, __u, __idx;\n  const void *__p;\n  int __comparison;\n\n  __l = 0;\n  __u = __nmemb;\n  while (__l < __u)\n    {\n      __idx = (__l + __u) / 2;\n      __p = (const void *) (((const char *) __base) + (__idx * __size));\n      __comparison = (*__compar) (__key, __p);\n      if (__comparison < 0)\n\t__u = __idx;\n      else if (__comparison > 0)\n\t__l = __idx + 1;\n      else\n\t{\n#if __GNUC_PREREQ(4, 6)\n# pragma GCC diagnostic push\n# pragma GCC diagnostic ignored \"-Wcast-qual\"\n#endif\n\t  return (void *) __p;\n#if __GNUC_PREREQ(4, 6)\n# pragma GCC diagnostic pop\n#endif\n\t}\n    }\n\n  return NULL;\n}",
    "realpath(const char *, char *)": "char *\n__realpath (const char *name, char *resolved)\n{\n  struct realpath_bufs bufs;\n  scratch_buffer_init (&bufs.rname);\n  scratch_buffer_init (&bufs.extra);\n  scratch_buffer_init (&bufs.link);\n  char *result = realpath_stk (name, resolved, &bufs);\n  scratch_buffer_free (&bufs.link);\n  scratch_buffer_free (&bufs.extra);\n  scratch_buffer_free (&bufs.rname);\n  return result;\n}",
    "canonicalize_file_name(const char *)": "char *\n__canonicalize_file_name (const char *name)\n{\n  return __realpath (name, NULL);\n}",
    "__cxa_at_quick_exit(void (*)(void *), void *)": "int\n__cxa_at_quick_exit (void (*func) (void *), void *d)\n{\n  return __internal_atexit (func, NULL, d, &__quick_exit_funcs);\n}",
    "__cxa_finalize(void *)": "void\n__cxa_finalize (void *d)\n{\n  struct exit_function_list *funcs;\n\n  __libc_lock_lock (__exit_funcs_lock);\n\n restart:\n  for (funcs = __exit_funcs; funcs; funcs = funcs->next)\n    {\n      struct exit_function *f;\n\n      for (f = &funcs->fns[funcs->idx - 1]; f >= &funcs->fns[0]; --f)\n\tif ((d == NULL || d == f->func.cxa.dso_handle) && f->flavor == ef_cxa)\n\t  {\n\t    const uint64_t check = __new_exitfn_called;\n\t    void (*cxafn) (void *arg, int status) = f->func.cxa.fn;\n\t    void *cxaarg = f->func.cxa.arg;\n\n\t    /* We don't want to run this cleanup more than once.  The Itanium\n\t       C++ ABI requires that multiple calls to __cxa_finalize not\n\t       result in calling termination functions more than once.  One\n\t       potential scenario where that could happen is with a concurrent\n\t       dlclose and exit, where the running dlclose must at some point\n\t       release the list lock, an exiting thread may acquire it, and\n\t       without setting flavor to ef_free, might re-run this destructor\n\t       which could result in undefined behaviour.  Therefore we must\n\t       set flavor to ef_free to avoid calling this destructor again.\n\t       Note that the concurrent exit must also take the dynamic loader\n\t       lock (for library finalizer processing) and therefore will\n\t       block while dlclose completes the processing of any in-progress\n\t       exit functions. Lastly, once we release the list lock for the\n\t       entry marked ef_free, we must not read from that entry again\n\t       since it may have been reused by the time we take the list lock\n\t       again.  Lastly the detection of new registered exit functions is\n\t       based on a monotonically incrementing counter, and there is an\n\t       ABA if between the unlock to run the exit function and the\n\t       re-lock after completion the user registers 2^64 exit functions,\n\t       the implementation will not detect this and continue without\n\t       executing any more functions.\n\n\t       One minor issue remains: A registered exit function that is in\n\t       progress by a call to dlclose() may not completely finish before\n\t       the next registered exit function is run. This may, according to\n\t       some readings of POSIX violate the requirement that functions\n\t       run in effective LIFO order.  This should probably be fixed in a\n\t       future implementation to ensure the functions do not run in\n\t       parallel.  */\n\t    f->flavor = ef_free;\n\n\t    PTR_DEMANGLE (cxafn);\n\n\t    /* Unlock the list while we call a foreign function.  */\n\t    __libc_lock_unlock (__exit_funcs_lock);\n\t    cxafn (cxaarg, 0);\n\t    __libc_lock_lock (__exit_funcs_lock);\n\n\t    /* It is possible that that last exit function registered\n\t       more exit functions.  Start the loop over.  */\n\t    if (__glibc_unlikely (check != __new_exitfn_called))\n\t      goto restart;\n\t  }\n    }\n\n  /* Also remove the quick_exit handlers, but do not call them.  */\n  for (funcs = __quick_exit_funcs; funcs; funcs = funcs->next)\n    {\n      struct exit_function *f;\n\n      for (f = &funcs->fns[funcs->idx - 1]; f >= &funcs->fns[0]; --f)\n\tif (d == NULL || d == f->func.cxa.dso_handle)\n\t  f->flavor = ef_free;\n    }\n\n  /* Remove the registered fork handlers.  We do not have to\n     unregister anything if the program is going to terminate anyway.  */\n  if (d != NULL)\n    UNREGISTER_ATFORK (d);\n  __libc_lock_unlock (__exit_funcs_lock);\n}",
    "__cxa_thread_atexit_impl(dtor_func, void *, void *)": "int\n__cxa_thread_atexit_impl (dtor_func func, void *obj, void *dso_symbol)\n{\n  PTR_MANGLE (func);\n\n  /* Prepend.  */\n  struct dtor_list *new = calloc (1, sizeof (struct dtor_list));\n  if (__glibc_unlikely (new == NULL))\n    __libc_fatal (\"Fatal glibc error: failed to register TLS destructor: \"\n\t\t  \"out of memory\\n\");\n  new->func = func;\n  new->obj = obj;\n  new->next = tls_dtor_list;\n  tls_dtor_list = new;\n\n  /* We have to acquire the big lock to prevent a racing dlclose from pulling\n     our DSO from underneath us while we're setting up our destructor.  */\n  __rtld_lock_lock_recursive (GL(dl_load_lock));\n\n  /* See if we already encountered the DSO.  */\n  if (__glibc_unlikely (dso_symbol_cache != dso_symbol))\n    {\n      ElfW(Addr) caller = (ElfW(Addr)) dso_symbol;\n\n      struct link_map *l = _dl_find_dso_for_object (caller);\n\n      /* If the address is not recognized the call comes from the main\n\t program (we hope).  */\n      lm_cache = l ? l : GL(dl_ns)[LM_ID_BASE]._ns_loaded;\n    }\n\n  /* This increment may only be concurrently observed either by the decrement\n     in __call_tls_dtors since the other l_tls_dtor_count access in\n     _dl_close_worker is protected by the dl_load_lock.  The execution in\n     __call_tls_dtors does not really depend on this value beyond the fact that\n     it should be atomic, so Relaxed MO should be sufficient.  */\n  atomic_fetch_add_relaxed (&lm_cache->l_tls_dtor_count, 1);\n  __rtld_lock_unlock_recursive (GL(dl_load_lock));\n\n  new->map = lm_cache;\n\n  return 0;\n}",
    "__call_tls_dtors()": "void\n__call_tls_dtors (void)\n{\n  while (tls_dtor_list)\n    {\n      struct dtor_list *cur = tls_dtor_list;\n      dtor_func func = cur->func;\n      PTR_DEMANGLE (func);\n\n      tls_dtor_list = tls_dtor_list->next;\n      func (cur->obj);\n\n      /* Ensure that the MAP dereference happens before\n\t l_tls_dtor_count decrement.  That way, we protect this access from a\n\t potential DSO unload in _dl_close_worker, which happens when\n\t l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */\n      atomic_fetch_add_release (&cur->map->l_tls_dtor_count, -1);\n      free (cur);\n    }\n}",
    "div(int, int)": "div_t\ndiv (int numer, int denom)\n{\n  div_t result;\n\n  result.quot = numer / denom;\n  result.rem = numer % denom;\n\n  return result;\n}",
    "drand48()": "double\ndrand48 (void)\n{\n  double result;\n\n  (void) __erand48_r (__libc_drand48_data.__x, &__libc_drand48_data, &result);\n\n  return result;\n}",
    "drand48_r(struct drand48_data *, double *)": "int\ndrand48_r (struct drand48_data *buffer, double *result)\n{\n  return __erand48_r (buffer->__x, buffer, result);\n}",
    "erand48(unsigned short *)": "double\nerand48 (unsigned short int xsubi[3])\n{\n  double result;\n\n  (void) __erand48_r (xsubi, &__libc_drand48_data, &result);\n\n  return result;\n}",
    "fmtmsg(long, const char *, int, const char *, const char *, const char *)": "int\nfmtmsg (long int classification, const char *label, int severity,\n\tconst char *text, const char *action, const char *tag)\n{\n  __libc_once_define (static, once);\n  struct severity_info *severity_rec;\n\n  /* Make sure everything is initialized.  */\n  __libc_once (once, init);\n\n  /* Start the real work.  First check whether the input is ok.  */\n  if (label != MM_NULLLBL)\n    {\n      /* Must be two fields, separated by a colon.  */\n      const char *cp = strchr (label, ':');\n      if (cp == NULL)\n\treturn MM_NOTOK;\n\n      /* The first field must not contain more than 10 bytes.  */\n      if (cp - label > 10\n\t  /* The second field must not have more than 14 bytes.  */\n\t  || strlen (cp + 1) > 14)\n\treturn MM_NOTOK;\n    }\n\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &state);\n\n  __libc_lock_lock (lock);\n\n  for (severity_rec = severity_list; severity_rec != NULL;\n       severity_rec = severity_rec->next)\n    if (severity == severity_rec->severity)\n      /* Bingo.  */\n      break;\n\n  /* If we don't know anything about the severity level return an error.  */\n  int result = MM_NOTOK;\n  if (severity_rec != NULL)\n    {\n      result = MM_OK;\n\n      /* Now we can print.  */\n      if (classification & MM_PRINT)\n\t{\n\t  int do_label = (print & label_mask) && label != MM_NULLLBL;\n\t  int do_severity = (print & severity_mask) && severity != MM_NULLSEV;\n\t  int do_text = (print & text_mask) && text != MM_NULLTXT;\n\t  int do_action = (print & action_mask) && action != MM_NULLACT;\n\t  int do_tag = (print & tag_mask) && tag != MM_NULLTAG;\n\t  int need_colon = (do_label\n\t\t\t    && (do_severity | do_text | do_action | do_tag));\n\n\t  if (__fxprintf (stderr, \"%s%s%s%s%s%s%s%s%s%s\\n\",\n\t\t\t  do_label ? label : \"\",\n\t\t\t  need_colon ? \": \" : \"\",\n\t\t\t  do_severity ? severity_rec->string : \"\",\n\t\t\t  do_severity && (do_text | do_action | do_tag)\n\t\t\t  ? \": \" : \"\",\n\t\t\t  do_text ? text : \"\",\n\t\t\t  do_text && (do_action | do_tag) ? \"\\n\" : \"\",\n\t\t\t  do_action ? \"TO FIX: \" : \"\",\n\t\t\t  do_action ? action : \"\",\n\t\t\t  do_action && do_tag ? \"  \" : \"\",\n\t\t\t  do_tag ? tag : \"\") < 0)\n\t    /* Oh, oh.  An error occurred during the output.  */\n\t    result = MM_NOMSG;\n\t}\n\n      if (classification & MM_CONSOLE)\n\t{\n\t  int do_label = label != MM_NULLLBL;\n\t  int do_severity = severity != MM_NULLSEV;\n\t  int do_text = text != MM_NULLTXT;\n\t  int do_action = action != MM_NULLACT;\n\t  int do_tag = tag != MM_NULLTAG;\n\t  int need_colon = (do_label\n\t\t\t    && (do_severity | do_text | do_action | do_tag));\n\n\t  syslog (LOG_ERR, \"%s%s%s%s%s%s%s%s%s%s\\n\",\n\t\t  do_label ? label : \"\",\n\t\t  need_colon ? \": \" : \"\",\n\t\t  do_severity ? severity_rec->string : \"\",\n\t\t  do_severity && (do_text | do_action | do_tag) ? \": \" : \"\",\n\t\t  do_text ? text : \"\",\n\t\t  do_text && (do_action | do_tag) ? \"\\n\" : \"\",\n\t\t  do_action ? \"TO FIX: \" : \"\",\n\t\t  do_action ? action : \"\",\n\t\t  do_action && do_tag ? \"  \" : \"\",\n\t\t  do_tag ? tag : \"\");\n\t}\n    }\n\n  __libc_lock_unlock (lock);\n\n  __pthread_setcancelstate (state, NULL);\n\n  return result;\n}",
    "getcontext(ucontext_t *)": "int\ngetcontext (ucontext_t *ucp)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "getentropy(void *, int)": "int\ngetentropy (void *buffer, size_t length)\n{\n  /* The interface is documented to return EIO for buffer lengths\n     longer than 256 bytes.  */\n  if (length > 256)\n    {\n      __set_errno (EIO);\n      return -1;\n    }\n\n  /* Try to fill the buffer completely.  Even with the 256 byte limit\n     above, we might still receive an EINTR error (when blocking\n     during boot).  */\n  void *end = buffer + length;\n  while (buffer < end)\n    {\n      /* NB: No cancellation point.  */\n      ssize_t bytes = INLINE_SYSCALL_CALL (getrandom, buffer, end - buffer, 0);\n      if (bytes < 0)\n        {\n          if (errno == EINTR)\n            /* Try again if interrupted by a signal.  */\n            continue;\n          else\n            return -1;\n        }\n      if (bytes == 0)\n        {\n          /* No more bytes available.  This should not happen under\n             normal circumstances.  */\n          __set_errno (EIO);\n          return -1;\n        }\n      /* Try again in case of a short read.  */\n      buffer += bytes;\n    }\n  return 0;\n}",
    "getenv(const char *)": "char *\ngetenv (const char *name)\n{\n  if (__environ == NULL || name[0] == '\\0')\n    return NULL;\n\n  size_t len = strlen (name);\n  for (char **ep = __environ; *ep != NULL; ++ep)\n    {\n      if (name[0] == (*ep)[0]\n\t  && strncmp (name, *ep, len) == 0 && (*ep)[len] == '=')\n\treturn *ep + len + 1;\n    }\n\n  return NULL;\n}",
    "getsubopt(char **, char *const *, char **)": "int\ngetsubopt (char **optionp, char *const *tokens, char **valuep)\n{\n  char *endp, *vstart;\n  int cnt;\n\n  if (**optionp == '\\0')\n    return -1;\n\n  /* Find end of next token.  */\n  endp = __strchrnul (*optionp, ',');\n\n  /* Find start of value.  */\n  vstart = memchr (*optionp, '=', endp - *optionp);\n  if (vstart == NULL)\n    vstart = endp;\n\n  /* Try to match the characters between *OPTIONP and VSTART against\n     one of the TOKENS.  */\n  for (cnt = 0; tokens[cnt] != NULL; ++cnt)\n    if (strncmp (*optionp, tokens[cnt], vstart - *optionp) == 0\n\t&& tokens[cnt][vstart - *optionp] == '\\0')\n      {\n\t/* We found the current option in TOKENS.  */\n\t*valuep = vstart != endp ? vstart + 1 : NULL;\n\n\tif (*endp != '\\0')\n\t  *endp++ = '\\0';\n\t*optionp = endp;\n\n\treturn cnt;\n      }\n\n  /* The current suboption does not match any option.  */\n  *valuep = *optionp;\n\n  if (*endp != '\\0')\n    *endp++ = '\\0';\n  *optionp = endp;\n\n  return -1;\n}",
    "jrand48(unsigned short *)": "long int\njrand48 (unsigned short int xsubi[3])\n{\n  long int result;\n\n  (void) __jrand48_r (xsubi, &__libc_drand48_data, &result);\n\n  return result;\n}",
    "l64a(long)": "char *\nl64a (long int n)\n{\n  unsigned long int m = (unsigned long int) n;\n  static char result[7];\n  int cnt;\n\n  /* The standard says that only 32 bits are used.  */\n  m &= 0xffffffff;\n\n  if (m == 0ul)\n    /* The value for N == 0 is defined to be the empty string. */\n    return (char *) \"\";\n\n  for (cnt = 0; m > 0ul; ++cnt)\n    {\n      result[cnt] = conv_table[m & 0x3f];\n      m >>= 6;\n    }\n  result[cnt] = '\\0';\n\n  return result;\n}",
    "labs(long)": "long int\nlabs (long int i)\n{\n  return i < 0 ? -i : i;\n}",
    "lcong48(unsigned short *)": "void\nlcong48 (unsigned short int param[7])\n{\n  (void) __lcong48_r (param, &__libc_drand48_data);\n}",
    "ldiv(long, long)": "ldiv_t\nldiv (long int numer, long int denom)\n{\n  ldiv_t result;\n\n  result.quot = numer / denom;\n  result.rem = numer % denom;\n\n  return result;\n}",
    "llabs(long long)": "long long int\nllabs (long long int i)\n{\n  return i < 0 ? -i : i;\n}",
    "lldiv(long long, long long)": "lldiv_t\nlldiv (long long int numer, long long int denom)\n{\n  lldiv_t result;\n\n  result.quot = numer / denom;\n  result.rem = numer % denom;\n\n  return result;\n}",
    "lrand48()": "long int\nlrand48 (void)\n{\n  long int result;\n\n  (void) __nrand48_r (__libc_drand48_data.__x, &__libc_drand48_data, &result);\n\n  return result;\n}",
    "lrand48_r(struct drand48_data *, long *)": "int\nlrand48_r (struct drand48_data *buffer, long int *result)\n{\n  /* Be generous for the arguments, detect some errors.  */\n  if (buffer == NULL)\n   return -1;\n\n  return __nrand48_r (buffer->__x, buffer, result);\n}",
    "makecontext(ucontext_t *, void (*)(void), int, ...)": "void\nmakecontext (ucontext_t *ucp, void (*func) (void), int argc, ...)\n{\n  __set_errno (ENOSYS);\n}",
    "mblen(const char *, int)": "int\nmblen (const char *s, size_t n)\n{\n  int result;\n\n  /* If S is NULL the function has to return null or not null\n     depending on the encoding having a state depending encoding or\n     not.  */\n  if (s == NULL)\n    {\n      const struct gconv_fcts *fcts;\n\n      /* Get the conversion functions.  */\n      fcts = get_gconv_fcts (_NL_CURRENT_DATA (LC_CTYPE));\n\n      /* Reset the state.  */\n      memset (&state, '\\0', sizeof state);\n\n      result = fcts->towc->__stateful;\n    }\n  else if (*s == '\\0')\n    /* According to the ISO C 89 standard this is the expected behaviour.  */\n    result = 0;\n  else\n    {\n      memset (&state, '\\0', sizeof state);\n\n      result = __mbrtowc (NULL, s, n, &state);\n\n      /* The `mbrtowc' functions tell us more than we need.  Fold the -1\n\t and -2 result into -1.  */\n      if (result < 0)\n\tresult = -1;\n    }\n\n  return result;\n}",
    "mbstowcs(int *, const char *, int)": "size_t\nmbstowcs (wchar_t *pwcs, const char *s, size_t n)\n{\n  mbstate_t state;\n\n  memset (&state, '\\0', sizeof state);\n  /* Return how many we wrote (or maybe an error).  */\n  return __mbsrtowcs (pwcs, &s, n, &state);\n}",
    "mbtowc(int *, const char *, int)": "int\nmbtowc (wchar_t *pwc, const char *s, size_t n)\n{\n  int result;\n  static mbstate_t state;\n\n  /* If S is NULL the function has to return null or not null\n     depending on the encoding having a state depending encoding or\n     not.  */\n  if (s == NULL)\n    {\n      const struct gconv_fcts *fcts;\n\n      /* Get the conversion functions.  */\n      fcts = get_gconv_fcts (_NL_CURRENT_DATA (LC_CTYPE));\n\n      /* This is an extension in the Unix standard which does not directly\n\t violate ISO C.  */\n      memset (&state, '\\0', sizeof state);\n\n      result = fcts->towc->__stateful;\n    }\n  else if (*s == '\\0')\n    {\n      if (pwc != NULL)\n\t*pwc = L'\\0';\n      result = 0;\n    }\n  else\n    {\n      result = __mbrtowc (pwc, s, n, &state);\n\n      /* The `mbrtowc' functions tell us more than we need.  Fold the -1\n\t and -2 result into -1.  */\n      if (result < 0)\n\tresult = -1;\n    }\n\n  return result;\n}",
    "mrand48()": "long int\nmrand48 (void)\n{\n  long int result;\n\n  (void) __jrand48_r (__libc_drand48_data.__x, &__libc_drand48_data, &result);\n\n  return result;\n}",
    "mrand48_r(struct drand48_data *, long *)": "int\nmrand48_r (struct drand48_data *buffer, long int *result)\n{\n  /* Be generous for the arguments, detect some errors.  */\n  if (buffer == NULL)\n   return -1;\n\n  return __jrand48_r (buffer->__x, buffer, result);\n}",
    "nrand48(unsigned short *)": "long int\nnrand48 (unsigned short int xsubi[3])\n{\n  long int result;\n\n  (void) __nrand48_r (xsubi, &__libc_drand48_data, &result);\n\n  return result;\n}",
    "putenv(char *)": "int\nputenv (char *string)\n{\n  const char *const name_end = strchr (string, '=');\n\n  if (name_end != NULL)\n    {\n      char *name;\n#ifdef _LIBC\n      int use_malloc = !__libc_use_alloca (name_end - string + 1);\n      if (__builtin_expect (use_malloc, 0))\n\t{\n\t  name = __strndup (string, name_end - string);\n\t  if (name == NULL)\n\t    return -1;\n\t}\n      else\n\tname = strndupa (string, name_end - string);\n#else\n# define use_malloc 1\n      name = malloc (name_end - string + 1);\n      if (name == NULL)\n\treturn -1;\n      memcpy (name, string, name_end - string);\n      name[name_end - string] = '\\0';\n#endif\n      int result = __add_to_environ (name, NULL, string, 1);\n\n      if (__glibc_unlikely (use_malloc))\n\tfree (name);\n\n      return result;\n    }\n\n  __unsetenv (string);\n  return 0;\n}",
    "rand()": "int\nrand (void)\n{\n  return (int) __random ();\n}",
    "rand_r(unsigned int *)": "int\nrand_r (unsigned int *seed)\n{\n  unsigned int next = *seed;\n  int result;\n\n  next *= 1103515245;\n  next += 12345;\n  result = (unsigned int) (next / 65536) % 2048;\n\n  next *= 1103515245;\n  next += 12345;\n  result <<= 10;\n  result ^= (unsigned int) (next / 65536) % 1024;\n\n  next *= 1103515245;\n  next += 12345;\n  result <<= 10;\n  result ^= (unsigned int) (next / 65536) % 1024;\n\n  *seed = next;\n\n  return result;\n}",
    "rpmatch(const char *)": "int\nrpmatch (const char *response)\n{\n  /* We cache the response patterns and compiled regexps here.  */\n  static const char *yesexpr, *noexpr;\n  static regex_t yesre, nore;\n\n  return (try (response, YESEXPR, 1, 0, &yesexpr, &yesre) ?:\n\t  try (response, NOEXPR, 0, -1, &noexpr, &nore));\n}",
    "__libc_secure_getenv(const char *)": "char *\n__libc_secure_getenv (const char *name)\n{\n  return __libc_enable_secure ? NULL : getenv (name);\n}",
    "seed48(unsigned short *)": "unsigned short int *\nseed48 (unsigned short int seed16v[3])\n{\n  (void) __seed48_r (seed16v, &__libc_drand48_data);\n\n  return __libc_drand48_data.__old_x;\n}",
    "setcontext(const ucontext_t *)": "int\nsetcontext (const ucontext_t *ucp)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "setenv(const char *, const char *, int)": "int\nsetenv (const char *name, const char *value, int replace)\n{\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __add_to_environ (name, value, NULL, replace);\n}",
    "clearenv()": "int\nclearenv (void)\n{\n  LOCK;\n\n  if (__environ == last_environ && __environ != NULL)\n    {\n      /* We allocated this environment so we can free it.  */\n      free (__environ);\n      last_environ = NULL;\n    }\n\n  /* Clear the environment pointer removes the whole environment.  */\n  __environ = NULL;\n\n  UNLOCK;\n\n  return 0;\n}",
    "srand48(long)": "void\nsrand48 (long seedval)\n{\n  (void) __srand48_r (seedval, &__libc_drand48_data);\n}",
    "stdc_bit_ceil_uc(unsigned char)": "unsigned char\n(stdc_bit_ceil_uc) (unsigned char x)\n{\n  return stdc_bit_ceil_uc (x);\n}",
    "stdc_bit_ceil_ui(unsigned int)": "unsigned int\n(stdc_bit_ceil_ui) (unsigned int x)\n{\n  return stdc_bit_ceil_ui (x);\n}",
    "stdc_bit_ceil_ul(unsigned long)": "unsigned long int\n(stdc_bit_ceil_ul) (unsigned long int x)\n{\n  return stdc_bit_ceil_ul (x);\n}",
    "stdc_bit_ceil_ull(unsigned long long)": "unsigned long long int\n(stdc_bit_ceil_ull) (unsigned long long int x)\n{\n  return stdc_bit_ceil_ull (x);\n}",
    "stdc_bit_ceil_us(unsigned short)": "unsigned short\n(stdc_bit_ceil_us) (unsigned short x)\n{\n  return stdc_bit_ceil_us (x);\n}",
    "stdc_bit_floor_uc(unsigned char)": "unsigned char\n(stdc_bit_floor_uc) (unsigned char x)\n{\n  return stdc_bit_floor_uc (x);\n}",
    "stdc_bit_floor_ui(unsigned int)": "unsigned int\n(stdc_bit_floor_ui) (unsigned int x)\n{\n  return stdc_bit_floor_ui (x);\n}",
    "stdc_bit_floor_ul(unsigned long)": "unsigned long int\n(stdc_bit_floor_ul) (unsigned long int x)\n{\n  return stdc_bit_floor_ul (x);\n}",
    "stdc_bit_floor_ull(unsigned long long)": "unsigned long long int\n(stdc_bit_floor_ull) (unsigned long long int x)\n{\n  return stdc_bit_floor_ull (x);\n}",
    "stdc_bit_floor_us(unsigned short)": "unsigned short\n(stdc_bit_floor_us) (unsigned short x)\n{\n  return stdc_bit_floor_us (x);\n}",
    "stdc_bit_width_uc(unsigned char)": "unsigned int\n(stdc_bit_width_uc) (unsigned char x)\n{\n  return stdc_bit_width_uc (x);\n}",
    "stdc_bit_width_ui(unsigned int)": "unsigned int\n(stdc_bit_width_ui) (unsigned int x)\n{\n  return stdc_bit_width_ui (x);\n}",
    "stdc_bit_width_ul(unsigned long)": "unsigned int\n(stdc_bit_width_ul) (unsigned long int x)\n{\n  return stdc_bit_width_ul (x);\n}",
    "stdc_bit_width_ull(unsigned long long)": "unsigned int\n(stdc_bit_width_ull) (unsigned long long int x)\n{\n  return stdc_bit_width_ull (x);\n}",
    "stdc_bit_width_us(unsigned short)": "unsigned int\n(stdc_bit_width_us) (unsigned short x)\n{\n  return stdc_bit_width_us (x);\n}",
    "stdc_count_ones_uc(unsigned char)": "unsigned int\n(stdc_count_ones_uc) (unsigned char x)\n{\n  return stdc_count_ones_uc (x);\n}",
    "stdc_count_ones_ui(unsigned int)": "unsigned int\n(stdc_count_ones_ui) (unsigned int x)\n{\n  return stdc_count_ones_ui (x);\n}",
    "stdc_count_ones_ul(unsigned long)": "unsigned int\n(stdc_count_ones_ul) (unsigned long int x)\n{\n  return stdc_count_ones_ul (x);\n}",
    "stdc_count_ones_ull(unsigned long long)": "unsigned int\n(stdc_count_ones_ull) (unsigned long long int x)\n{\n  return stdc_count_ones_ull (x);\n}",
    "stdc_count_ones_us(unsigned short)": "unsigned int\n(stdc_count_ones_us) (unsigned short x)\n{\n  return stdc_count_ones_us (x);\n}",
    "stdc_count_zeros_uc(unsigned char)": "unsigned int\n(stdc_count_zeros_uc) (unsigned char x)\n{\n  return stdc_count_zeros_uc (x);\n}",
    "stdc_count_zeros_ui(unsigned int)": "unsigned int\n(stdc_count_zeros_ui) (unsigned int x)\n{\n  return stdc_count_zeros_ui (x);\n}",
    "stdc_count_zeros_ul(unsigned long)": "unsigned int\n(stdc_count_zeros_ul) (unsigned long int x)\n{\n  return stdc_count_zeros_ul (x);\n}",
    "stdc_count_zeros_ull(unsigned long long)": "unsigned int\n(stdc_count_zeros_ull) (unsigned long long int x)\n{\n  return stdc_count_zeros_ull (x);\n}",
    "stdc_count_zeros_us(unsigned short)": "unsigned int\n(stdc_count_zeros_us) (unsigned short x)\n{\n  return stdc_count_zeros_us (x);\n}",
    "stdc_first_leading_one_uc(unsigned char)": "unsigned int\n(stdc_first_leading_one_uc) (unsigned char x)\n{\n  return stdc_first_leading_one_uc (x);\n}",
    "stdc_first_leading_one_ui(unsigned int)": "unsigned int\n(stdc_first_leading_one_ui) (unsigned int x)\n{\n  return stdc_first_leading_one_ui (x);\n}",
    "stdc_first_leading_one_ul(unsigned long)": "unsigned int\n(stdc_first_leading_one_ul) (unsigned long int x)\n{\n  return stdc_first_leading_one_ul (x);\n}",
    "stdc_first_leading_one_ull(unsigned long long)": "unsigned int\n(stdc_first_leading_one_ull) (unsigned long long int x)\n{\n  return stdc_first_leading_one_ull (x);\n}",
    "stdc_first_leading_one_us(unsigned short)": "unsigned int\n(stdc_first_leading_one_us) (unsigned short x)\n{\n  return stdc_first_leading_one_us (x);\n}",
    "stdc_first_leading_zero_uc(unsigned char)": "unsigned int\n(stdc_first_leading_zero_uc) (unsigned char x)\n{\n  return stdc_first_leading_zero_uc (x);\n}",
    "stdc_first_leading_zero_ui(unsigned int)": "unsigned int\n(stdc_first_leading_zero_ui) (unsigned int x)\n{\n  return stdc_first_leading_zero_ui (x);\n}",
    "stdc_first_leading_zero_ul(unsigned long)": "unsigned int\n(stdc_first_leading_zero_ul) (unsigned long int x)\n{\n  return stdc_first_leading_zero_ul (x);\n}",
    "stdc_first_leading_zero_ull(unsigned long long)": "unsigned int\n(stdc_first_leading_zero_ull) (unsigned long long int x)\n{\n  return stdc_first_leading_zero_ull (x);\n}",
    "stdc_first_leading_zero_us(unsigned short)": "unsigned int\n(stdc_first_leading_zero_us) (unsigned short x)\n{\n  return stdc_first_leading_zero_us (x);\n}",
    "stdc_first_trailing_one_uc(unsigned char)": "unsigned int\n(stdc_first_trailing_one_uc) (unsigned char x)\n{\n  return stdc_first_trailing_one_uc (x);\n}",
    "stdc_first_trailing_one_ui(unsigned int)": "unsigned int\n(stdc_first_trailing_one_ui) (unsigned int x)\n{\n  return stdc_first_trailing_one_ui (x);\n}",
    "stdc_first_trailing_one_ul(unsigned long)": "unsigned int\n(stdc_first_trailing_one_ul) (unsigned long int x)\n{\n  return stdc_first_trailing_one_ul (x);\n}",
    "stdc_first_trailing_one_ull(unsigned long long)": "unsigned int\n(stdc_first_trailing_one_ull) (unsigned long long int x)\n{\n  return stdc_first_trailing_one_ull (x);\n}",
    "stdc_first_trailing_one_us(unsigned short)": "unsigned int\n(stdc_first_trailing_one_us) (unsigned short x)\n{\n  return stdc_first_trailing_one_us (x);\n}",
    "stdc_first_trailing_zero_uc(unsigned char)": "unsigned int\n(stdc_first_trailing_zero_uc) (unsigned char x)\n{\n  return stdc_first_trailing_zero_uc (x);\n}",
    "stdc_first_trailing_zero_ui(unsigned int)": "unsigned int\n(stdc_first_trailing_zero_ui) (unsigned int x)\n{\n  return stdc_first_trailing_zero_ui (x);\n}",
    "stdc_first_trailing_zero_ul(unsigned long)": "unsigned int\n(stdc_first_trailing_zero_ul) (unsigned long int x)\n{\n  return stdc_first_trailing_zero_ul (x);\n}",
    "stdc_first_trailing_zero_ull(unsigned long long)": "unsigned int\n(stdc_first_trailing_zero_ull) (unsigned long long int x)\n{\n  return stdc_first_trailing_zero_ull (x);\n}",
    "stdc_first_trailing_zero_us(unsigned short)": "unsigned int\n(stdc_first_trailing_zero_us) (unsigned short x)\n{\n  return stdc_first_trailing_zero_us (x);\n}",
    "stdc_has_single_bit_uc(unsigned char)": "_Bool\n(stdc_has_single_bit_uc) (unsigned char x)\n{\n  return stdc_has_single_bit_uc (x);\n}",
    "stdc_has_single_bit_ui(unsigned int)": "_Bool\n(stdc_has_single_bit_ui) (unsigned int x)\n{\n  return stdc_has_single_bit_ui (x);\n}",
    "stdc_has_single_bit_ul(unsigned long)": "_Bool\n(stdc_has_single_bit_ul) (unsigned long int x)\n{\n  return stdc_has_single_bit_ul (x);\n}",
    "stdc_has_single_bit_ull(unsigned long long)": "_Bool\n(stdc_has_single_bit_ull) (unsigned long long int x)\n{\n  return stdc_has_single_bit_ull (x);\n}",
    "stdc_has_single_bit_us(unsigned short)": "_Bool\n(stdc_has_single_bit_us) (unsigned short x)\n{\n  return stdc_has_single_bit_us (x);\n}",
    "stdc_leading_ones_uc(unsigned char)": "unsigned int\n(stdc_leading_ones_uc) (unsigned char x)\n{\n  return stdc_leading_ones_uc (x);\n}",
    "stdc_leading_ones_ui(unsigned int)": "unsigned int\n(stdc_leading_ones_ui) (unsigned int x)\n{\n  return stdc_leading_ones_ui (x);\n}",
    "stdc_leading_ones_ul(unsigned long)": "unsigned int\n(stdc_leading_ones_ul) (unsigned long int x)\n{\n  return stdc_leading_ones_ul (x);\n}",
    "stdc_leading_ones_ull(unsigned long long)": "unsigned int\n(stdc_leading_ones_ull) (unsigned long long int x)\n{\n  return stdc_leading_ones_ull (x);\n}",
    "stdc_leading_ones_us(unsigned short)": "unsigned int\n(stdc_leading_ones_us) (unsigned short x)\n{\n  return stdc_leading_ones_us (x);\n}",
    "stdc_leading_zeros_uc(unsigned char)": "unsigned int\n(stdc_leading_zeros_uc) (unsigned char x)\n{\n  return stdc_leading_zeros_uc (x);\n}",
    "stdc_leading_zeros_ui(unsigned int)": "unsigned int\n(stdc_leading_zeros_ui) (unsigned int x)\n{\n  return stdc_leading_zeros_ui (x);\n}",
    "stdc_leading_zeros_ul(unsigned long)": "unsigned int\n(stdc_leading_zeros_ul) (unsigned long int x)\n{\n  return stdc_leading_zeros_ul (x);\n}",
    "stdc_leading_zeros_ull(unsigned long long)": "unsigned int\n(stdc_leading_zeros_ull) (unsigned long long int x)\n{\n  return stdc_leading_zeros_ull (x);\n}",
    "stdc_leading_zeros_us(unsigned short)": "unsigned int\n(stdc_leading_zeros_us) (unsigned short x)\n{\n  return stdc_leading_zeros_us (x);\n}",
    "stdc_trailing_ones_uc(unsigned char)": "unsigned int\n(stdc_trailing_ones_uc) (unsigned char x)\n{\n  return stdc_trailing_ones_uc (x);\n}",
    "stdc_trailing_ones_ui(unsigned int)": "unsigned int\n(stdc_trailing_ones_ui) (unsigned int x)\n{\n  return stdc_trailing_ones_ui (x);\n}",
    "stdc_trailing_ones_ul(unsigned long)": "unsigned int\n(stdc_trailing_ones_ul) (unsigned long int x)\n{\n  return stdc_trailing_ones_ul (x);\n}",
    "stdc_trailing_ones_ull(unsigned long long)": "unsigned int\n(stdc_trailing_ones_ull) (unsigned long long int x)\n{\n  return stdc_trailing_ones_ull (x);\n}",
    "stdc_trailing_ones_us(unsigned short)": "unsigned int\n(stdc_trailing_ones_us) (unsigned short x)\n{\n  return stdc_trailing_ones_us (x);\n}",
    "stdc_trailing_zeros_uc(unsigned char)": "unsigned int\n(stdc_trailing_zeros_uc) (unsigned char x)\n{\n  return stdc_trailing_zeros_uc (x);\n}",
    "stdc_trailing_zeros_ui(unsigned int)": "unsigned int\n(stdc_trailing_zeros_ui) (unsigned int x)\n{\n  return stdc_trailing_zeros_ui (x);\n}",
    "stdc_trailing_zeros_ul(unsigned long)": "unsigned int\n(stdc_trailing_zeros_ul) (unsigned long int x)\n{\n  return stdc_trailing_zeros_ul (x);\n}",
    "stdc_trailing_zeros_ull(unsigned long long)": "unsigned int\n(stdc_trailing_zeros_ull) (unsigned long long int x)\n{\n  return stdc_trailing_zeros_ull (x);\n}",
    "stdc_trailing_zeros_us(unsigned short)": "unsigned int\n(stdc_trailing_zeros_us) (unsigned short x)\n{\n  return stdc_trailing_zeros_us (x);\n}",
    "strfromd(char *, int, const char *, double)": "int\nSTRFROM (char *dest, size_t size, const char *format, FLOAT f)\n{\n  struct __printf_buffer_snprintf buf;\n\n  /* Single-precision values need to be stored in a double type, because\n     __printf_fp_l and __printf_fphex do not accept the float type.  */\n  union {\n    double flt;\n    FLOAT value;\n  } fpnum;\n  const void *fpptr;\n  fpptr = &fpnum;\n\n  /* Variables to control the output format.  */\n  int precision = -1; /* printf_fp and printf_fphex treat this internally.  */\n  int specifier;\n  struct printf_info info;\n\n  /* Single-precision values need to be converted into double-precision,\n     because __printf_fp and __printf_fphex only accept double and long double\n     as the floating-point argument.  */\n  if (__builtin_types_compatible_p (FLOAT, float))\n    fpnum.flt = keep_sign_conversion (f);\n  else\n    fpnum.value = f;\n\n  /* Check if the first character in the format string is indeed the '%'\n     character.  Otherwise, abort.  */\n  if (*format == '%')\n    format++;\n  else\n    abort ();\n\n  /* The optional precision specification always starts with a '.'.  If such\n     character is present, read the precision.  */\n  if (*format == '.')\n    {\n      format++;\n\n      /* Parse the precision.  */\n      if (ISDIGIT (*format))\n\tprecision = read_int (&format);\n      /* If only the period is specified, the precision is taken as zero, as\n\t described in ISO/IEC 9899:2011, section 7.21.6.1, 4th paragraph, 3rd\n\t item.  */\n      else\n\tprecision = 0;\n    }\n\n  /* Now there is only the conversion specifier to be read.  */\n  switch (*format)\n    {\n    case 'a':\n    case 'A':\n    case 'e':\n    case 'E':\n    case 'f':\n    case 'F':\n    case 'g':\n    case 'G':\n      specifier = *format;\n      break;\n    default:\n      abort ();\n    }\n\n  /* Prepare the string buffer.  */\n  __printf_buffer_snprintf_init (&buf, dest, size);\n\n  /* Prepare the format specification for printf_fp.  */\n  memset (&info, '\\0', sizeof (info));\n\n  /* The functions strfromd and strfromf pass a floating-point number with\n     double precision to printf_fp, whereas strfroml passes a floating-point\n     number with long double precision.  The following line informs printf_fp\n     which type of floating-point number is being passed.  */\n  info.is_long_double = __builtin_types_compatible_p (FLOAT, long double);\n\n  /* Similarly, the function strfromf128 passes a floating-point number in\n     _Float128 format to printf_fp.  */\n#if __HAVE_DISTINCT_FLOAT128\n  info.is_binary128 = __builtin_types_compatible_p (FLOAT, _Float128);\n#endif\n\n  /* Set info according to the format string.  */\n  info.prec = precision;\n  info.spec = specifier;\n\n  if (info.spec != 'a' && info.spec != 'A')\n    __printf_fp_l_buffer (&buf.base, _NL_CURRENT_LOCALE, &info, &fpptr);\n  else\n    __printf_fphex_l_buffer (&buf.base, _NL_CURRENT_LOCALE, &info, &fpptr);\n  return __printf_buffer_snprintf_done (&buf);\n}",
    "strfromf(char *, int, const char *, float)": "int\nSTRFROM (char *dest, size_t size, const char *format, FLOAT f)\n{\n  struct __printf_buffer_snprintf buf;\n\n  /* Single-precision values need to be stored in a double type, because\n     __printf_fp_l and __printf_fphex do not accept the float type.  */\n  union {\n    double flt;\n    FLOAT value;\n  } fpnum;\n  const void *fpptr;\n  fpptr = &fpnum;\n\n  /* Variables to control the output format.  */\n  int precision = -1; /* printf_fp and printf_fphex treat this internally.  */\n  int specifier;\n  struct printf_info info;\n\n  /* Single-precision values need to be converted into double-precision,\n     because __printf_fp and __printf_fphex only accept double and long double\n     as the floating-point argument.  */\n  if (__builtin_types_compatible_p (FLOAT, float))\n    fpnum.flt = keep_sign_conversion (f);\n  else\n    fpnum.value = f;\n\n  /* Check if the first character in the format string is indeed the '%'\n     character.  Otherwise, abort.  */\n  if (*format == '%')\n    format++;\n  else\n    abort ();\n\n  /* The optional precision specification always starts with a '.'.  If such\n     character is present, read the precision.  */\n  if (*format == '.')\n    {\n      format++;\n\n      /* Parse the precision.  */\n      if (ISDIGIT (*format))\n\tprecision = read_int (&format);\n      /* If only the period is specified, the precision is taken as zero, as\n\t described in ISO/IEC 9899:2011, section 7.21.6.1, 4th paragraph, 3rd\n\t item.  */\n      else\n\tprecision = 0;\n    }\n\n  /* Now there is only the conversion specifier to be read.  */\n  switch (*format)\n    {\n    case 'a':\n    case 'A':\n    case 'e':\n    case 'E':\n    case 'f':\n    case 'F':\n    case 'g':\n    case 'G':\n      specifier = *format;\n      break;\n    default:\n      abort ();\n    }\n\n  /* Prepare the string buffer.  */\n  __printf_buffer_snprintf_init (&buf, dest, size);\n\n  /* Prepare the format specification for printf_fp.  */\n  memset (&info, '\\0', sizeof (info));\n\n  /* The functions strfromd and strfromf pass a floating-point number with\n     double precision to printf_fp, whereas strfroml passes a floating-point\n     number with long double precision.  The following line informs printf_fp\n     which type of floating-point number is being passed.  */\n  info.is_long_double = __builtin_types_compatible_p (FLOAT, long double);\n\n  /* Similarly, the function strfromf128 passes a floating-point number in\n     _Float128 format to printf_fp.  */\n#if __HAVE_DISTINCT_FLOAT128\n  info.is_binary128 = __builtin_types_compatible_p (FLOAT, _Float128);\n#endif\n\n  /* Set info according to the format string.  */\n  info.prec = precision;\n  info.spec = specifier;\n\n  if (info.spec != 'a' && info.spec != 'A')\n    __printf_fp_l_buffer (&buf.base, _NL_CURRENT_LOCALE, &info, &fpptr);\n  else\n    __printf_fphex_l_buffer (&buf.base, _NL_CURRENT_LOCALE, &info, &fpptr);\n  return __printf_buffer_snprintf_done (&buf);\n}",
    "strfroml(char *, int, const char *, long double)": "int\nSTRFROM (char *dest, size_t size, const char *format, FLOAT f)\n{\n  struct __printf_buffer_snprintf buf;\n\n  /* Single-precision values need to be stored in a double type, because\n     __printf_fp_l and __printf_fphex do not accept the float type.  */\n  union {\n    double flt;\n    FLOAT value;\n  } fpnum;\n  const void *fpptr;\n  fpptr = &fpnum;\n\n  /* Variables to control the output format.  */\n  int precision = -1; /* printf_fp and printf_fphex treat this internally.  */\n  int specifier;\n  struct printf_info info;\n\n  /* Single-precision values need to be converted into double-precision,\n     because __printf_fp and __printf_fphex only accept double and long double\n     as the floating-point argument.  */\n  if (__builtin_types_compatible_p (FLOAT, float))\n    fpnum.flt = keep_sign_conversion (f);\n  else\n    fpnum.value = f;\n\n  /* Check if the first character in the format string is indeed the '%'\n     character.  Otherwise, abort.  */\n  if (*format == '%')\n    format++;\n  else\n    abort ();\n\n  /* The optional precision specification always starts with a '.'.  If such\n     character is present, read the precision.  */\n  if (*format == '.')\n    {\n      format++;\n\n      /* Parse the precision.  */\n      if (ISDIGIT (*format))\n\tprecision = read_int (&format);\n      /* If only the period is specified, the precision is taken as zero, as\n\t described in ISO/IEC 9899:2011, section 7.21.6.1, 4th paragraph, 3rd\n\t item.  */\n      else\n\tprecision = 0;\n    }\n\n  /* Now there is only the conversion specifier to be read.  */\n  switch (*format)\n    {\n    case 'a':\n    case 'A':\n    case 'e':\n    case 'E':\n    case 'f':\n    case 'F':\n    case 'g':\n    case 'G':\n      specifier = *format;\n      break;\n    default:\n      abort ();\n    }\n\n  /* Prepare the string buffer.  */\n  __printf_buffer_snprintf_init (&buf, dest, size);\n\n  /* Prepare the format specification for printf_fp.  */\n  memset (&info, '\\0', sizeof (info));\n\n  /* The functions strfromd and strfromf pass a floating-point number with\n     double precision to printf_fp, whereas strfroml passes a floating-point\n     number with long double precision.  The following line informs printf_fp\n     which type of floating-point number is being passed.  */\n  info.is_long_double = __builtin_types_compatible_p (FLOAT, long double);\n\n  /* Similarly, the function strfromf128 passes a floating-point number in\n     _Float128 format to printf_fp.  */\n#if __HAVE_DISTINCT_FLOAT128\n  info.is_binary128 = __builtin_types_compatible_p (FLOAT, _Float128);\n#endif\n\n  /* Set info according to the format string.  */\n  info.prec = precision;\n  info.spec = specifier;\n\n  if (info.spec != 'a' && info.spec != 'A')\n    __printf_fp_l_buffer (&buf.base, _NL_CURRENT_LOCALE, &info, &fpptr);\n  else\n    __printf_fphex_l_buffer (&buf.base, _NL_CURRENT_LOCALE, &info, &fpptr);\n  return __printf_buffer_snprintf_done (&buf);\n}",
    "__strtod_internal(const char *, char **, int)": "FLOAT\nINTERNAL (STRTOF) (const STRING_TYPE *nptr, STRING_TYPE **endptr, int group)\n{\n  return INTERNAL(STRTOF_L) (nptr, endptr, group, _NL_CURRENT_LOCALE);\n}",
    "strtod(const char *, char **)": "FLOAT\n#ifdef weak_function\nweak_function\n#endif\nSTRTOF (const STRING_TYPE *nptr, STRING_TYPE **endptr)\n{\n  return INTERNAL(STRTOF_L) (nptr, endptr, 0, _NL_CURRENT_LOCALE);\n}",
    "__strtod_l(const char *, char **, locale_t)": "FLOAT\n#ifdef weak_function\nweak_function\n#endif\n__STRTOF (const STRING_TYPE *nptr, STRING_TYPE **endptr, locale_t loc)\n{\n  return ____STRTOF_INTERNAL (nptr, endptr, 0, loc);\n}",
    "__strtod_nan(const char *, char **, char)": "FLOAT\nSTRTOD_NAN (const STRING_TYPE *str, STRING_TYPE **endptr, STRING_TYPE endc)\n{\n  const STRING_TYPE *cp = str;\n\n  while ((*cp >= L_('0') && *cp <= L_('9'))\n\t || (*cp >= L_('A') && *cp <= L_('Z'))\n\t || (*cp >= L_('a') && *cp <= L_('z'))\n\t || *cp == L_('_'))\n    ++cp;\n\n  FLOAT retval = NAN;\n  if (*cp != endc)\n    goto out;\n\n  /* This is a system-dependent way to specify the bitmask used for\n     the NaN.  We expect it to be a number which is put in the\n     mantissa of the number.  */\n  STRING_TYPE *endp;\n  unsigned long long int mant;\n\n  mant = STRTOULL (str, &endp, 0);\n  if (endp == cp)\n    SET_NAN_PAYLOAD (retval, mant);\n\n out:\n  if (endptr != NULL)\n    *endptr = (STRING_TYPE *) cp;\n  return retval;\n}",
    "__strtof_internal(const char *, char **, int)": "FLOAT\nINTERNAL (STRTOF) (const STRING_TYPE *nptr, STRING_TYPE **endptr, int group)\n{\n  return INTERNAL(STRTOF_L) (nptr, endptr, group, _NL_CURRENT_LOCALE);\n}",
    "strtof(const char *, char **)": "FLOAT\n#ifdef weak_function\nweak_function\n#endif\nSTRTOF (const STRING_TYPE *nptr, STRING_TYPE **endptr)\n{\n  return INTERNAL(STRTOF_L) (nptr, endptr, 0, _NL_CURRENT_LOCALE);\n}",
    "__strtof_l(const char *, char **, locale_t)": "FLOAT\n#ifdef weak_function\nweak_function\n#endif\n__STRTOF (const STRING_TYPE *nptr, STRING_TYPE **endptr, locale_t loc)\n{\n  return ____STRTOF_INTERNAL (nptr, endptr, 0, loc);\n}",
    "__strtof_nan(const char *, char **, char)": "FLOAT\nSTRTOD_NAN (const STRING_TYPE *str, STRING_TYPE **endptr, STRING_TYPE endc)\n{\n  const STRING_TYPE *cp = str;\n\n  while ((*cp >= L_('0') && *cp <= L_('9'))\n\t || (*cp >= L_('A') && *cp <= L_('Z'))\n\t || (*cp >= L_('a') && *cp <= L_('z'))\n\t || *cp == L_('_'))\n    ++cp;\n\n  FLOAT retval = NAN;\n  if (*cp != endc)\n    goto out;\n\n  /* This is a system-dependent way to specify the bitmask used for\n     the NaN.  We expect it to be a number which is put in the\n     mantissa of the number.  */\n  STRING_TYPE *endp;\n  unsigned long long int mant;\n\n  mant = STRTOULL (str, &endp, 0);\n  if (endp == cp)\n    SET_NAN_PAYLOAD (retval, mant);\n\n out:\n  if (endptr != NULL)\n    *endptr = (STRING_TYPE *) cp;\n  return retval;\n}",
    "__strtol_internal(const char *, char **, int, int)": "INT\nINTERNAL (strtol) (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n\t\t   int base, int group)\n{\n  return INTERNAL (__strtol_l) (nptr, endptr, base, group, false,\n\t\t\t\t_NL_CURRENT_LOCALE);\n}",
    "__strtol_l(const char *, char **, int, locale_t)": "INT\n#ifdef weak_function\nweak_function\n#endif\n__strtol_l (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n\t    int base, locale_t loc)\n{\n  return INTERNAL (__strtol_l) (nptr, endptr, base, 0, false, loc);\n}",
    "__strtold_internal(const char *, char **, int)": "FLOAT\nINTERNAL (STRTOF) (const STRING_TYPE *nptr, STRING_TYPE **endptr, int group)\n{\n  return INTERNAL(STRTOF_L) (nptr, endptr, group, _NL_CURRENT_LOCALE);\n}",
    "strtold(const char *, char **)": "FLOAT\n#ifdef weak_function\nweak_function\n#endif\nSTRTOF (const STRING_TYPE *nptr, STRING_TYPE **endptr)\n{\n  return INTERNAL(STRTOF_L) (nptr, endptr, 0, _NL_CURRENT_LOCALE);\n}",
    "__strtold_nan(const char *, char **, char)": "FLOAT\nSTRTOD_NAN (const STRING_TYPE *str, STRING_TYPE **endptr, STRING_TYPE endc)\n{\n  const STRING_TYPE *cp = str;\n\n  while ((*cp >= L_('0') && *cp <= L_('9'))\n\t || (*cp >= L_('A') && *cp <= L_('Z'))\n\t || (*cp >= L_('a') && *cp <= L_('z'))\n\t || *cp == L_('_'))\n    ++cp;\n\n  FLOAT retval = NAN;\n  if (*cp != endc)\n    goto out;\n\n  /* This is a system-dependent way to specify the bitmask used for\n     the NaN.  We expect it to be a number which is put in the\n     mantissa of the number.  */\n  STRING_TYPE *endp;\n  unsigned long long int mant;\n\n  mant = STRTOULL (str, &endp, 0);\n  if (endp == cp)\n    SET_NAN_PAYLOAD (retval, mant);\n\n out:\n  if (endptr != NULL)\n    *endptr = (STRING_TYPE *) cp;\n  return retval;\n}",
    "__strtoll_internal(const char *, char **, int, int)": "INT\nINTERNAL (strtol) (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n\t\t   int base, int group)\n{\n  return INTERNAL (__strtol_l) (nptr, endptr, base, group, false,\n\t\t\t\t_NL_CURRENT_LOCALE);\n}",
    "__strtoll_l(const char *, char **, int, locale_t)": "INT\n#ifdef weak_function\nweak_function\n#endif\n__strtol_l (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n\t    int base, locale_t loc)\n{\n  return INTERNAL (__strtol_l) (nptr, endptr, base, 0, false, loc);\n}",
    "__strtoul_internal(const char *, char **, int, int)": "INT\nINTERNAL (strtol) (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n\t\t   int base, int group)\n{\n  return INTERNAL (__strtol_l) (nptr, endptr, base, group, false,\n\t\t\t\t_NL_CURRENT_LOCALE);\n}",
    "__strtoul_l(const char *, char **, int, locale_t)": "INT\n#ifdef weak_function\nweak_function\n#endif\n__strtol_l (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n\t    int base, locale_t loc)\n{\n  return INTERNAL (__strtol_l) (nptr, endptr, base, 0, false, loc);\n}",
    "__strtoull_internal(const char *, char **, int, int)": "INT\nINTERNAL (strtol) (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n\t\t   int base, int group)\n{\n  return INTERNAL (__strtol_l) (nptr, endptr, base, group, false,\n\t\t\t\t_NL_CURRENT_LOCALE);\n}",
    "__strtoull_l(const char *, char **, int, locale_t)": "INT\n#ifdef weak_function\nweak_function\n#endif\n__strtol_l (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n\t    int base, locale_t loc)\n{\n  return INTERNAL (__strtol_l) (nptr, endptr, base, 0, false, loc);\n}",
    "swapcontext(ucontext_t *, const ucontext_t *)": "int\nswapcontext (ucontext_t *oucp, const ucontext_t *ucp)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__libc_system(const char *)": "int\n__libc_system (const char *line)\n{\n  if (line == NULL)\n    /* Check that we have a command processor available.  It might\n       not be available after a chroot(), for example.  */\n    return do_system (\"exit 0\") == 0;\n\n  return do_system (line);\n}",
    "wcstombs(char *, const int *, int)": "size_t\nwcstombs (char *s, const wchar_t *pwcs, size_t n)\n{\n  mbstate_t state;\n\n  memset (&state, '\\0', sizeof state);\n\n  /* Return how many we wrote (or maybe an error).  */\n  return __wcsrtombs (s, &pwcs, n, &state);\n}",
    "wctomb(char *, int)": "int\nwctomb (char *s, wchar_t wchar)\n{\n  /* If S is NULL the function has to return null or not null\n     depending on the encoding having a state depending encoding or\n     not.  */\n  if (s == NULL)\n    {\n      const struct gconv_fcts *fcts;\n\n      /* Get the conversion functions.  */\n      fcts = get_gconv_fcts (_NL_CURRENT_DATA (LC_CTYPE));\n\n      /* This is an extension in the Unix standard which does not directly\n\t violate ISO C.  */\n      memset (&__wctomb_state, '\\0', sizeof __wctomb_state);\n\n      return fcts->tomb->__stateful;\n    }\n\n  return __wcrtomb (s, wchar, &__wctomb_state);\n}",
    "__xpg_basename(char *)": "char *\n__xpg_basename (char *filename)\n{\n  char *p;\n\n  if (filename == NULL || filename[0] == '\\0')\n    /* We return a pointer to a static string containing \".\".  */\n    p = (char *) \".\";\n  else\n    {\n      p = strrchr (filename, '/');\n\n      if (p == NULL)\n\t/* There is no slash in the filename.  Return the whole string.  */\n\tp = filename;\n      else\n\t{\n\t  if (p[1] == '\\0')\n\t    {\n\t      /* We must remove trailing '/'.  */\n\t      while (p > filename && p[-1] == '/')\n\t\t--p;\n\n\t      /* Now we can be in two situations:\n\t\t a) the string only contains '/' characters, so we return\n\t\t    '/'\n\t\t b) p points past the last component, but we have to remove\n\t\t    the trailing slash.  */\n\t      if (p > filename)\n\t\t{\n\t\t  *p-- = '\\0';\n\t\t  while (p > filename && p[-1] != '/')\n\t\t    --p;\n\t\t}\n\t      else\n\t\t/* The last slash we already found is the right position\n\t\t   to return.  */\n\t\twhile (p[1] != '\\0')\n\t\t  ++p;\n\t    }\n\t  else\n\t    /* Go to the first character of the name.  */\n\t    ++p;\n\t}\n    }\n\n  return p;\n}",
    "__strerror_r(int, char *, int)": "char *\n__strerror_r (int errnum, char *buf, size_t buflen)\n{\n  int system;\n  int sub;\n  int code;\n  const struct error_system *es;\n  extern void __mach_error_map_compat (int *);\n\n  __mach_error_map_compat (&errnum);\n\n  system = err_get_system (errnum);\n  sub = err_get_sub (errnum);\n  code = err_get_code (errnum);\n\n  if (system > err_max_system || ! __mach_error_systems[system].bad_sub)\n    {\n      __snprintf (buf, buflen, \"%s%X\", _(\"Error in unknown error system: \"),\n\t\t  errnum);\n      return buf;\n    }\n\n  es = &__mach_error_systems[system];\n\n  if (sub >= es->max_sub)\n    return (char *) es->bad_sub;\n\n  if (code >= es->subsystem[sub].max_code)\n    {\n      __snprintf (buf, buflen, \"%s%s %d\", _(\"Unknown error \"),\n\t\t  es->subsystem[sub].subsys_name, errnum);\n      return buf;\n    }\n\n  return (char *) _(es->subsystem[sub].codes[code]);\n}",
    "__argz_count(const char *, int)": "size_t\n__argz_count (const char *argz, size_t len)\n{\n  size_t count = 0;\n  while (len > 0)\n    {\n      size_t part_len = strlen(argz);\n      argz += part_len + 1;\n      len -= part_len + 1;\n      count++;\n    }\n  return count;\n}",
    "argz_delete(char **, int *, char *)": "void\nargz_delete (char **argz, size_t *argz_len, char *entry)\n{\n  if (entry)\n    /* Get rid of the old value for NAME.  */\n    {\n      size_t entry_len = strlen (entry) + 1;\n      *argz_len -= entry_len;\n      memmove (entry, entry + entry_len, *argz_len - (entry - *argz));\n      if (*argz_len == 0)\n\t{\n\t  free (*argz);\n\t  *argz = 0;\n\t}\n    }\n}",
    "__argz_next(const char *, int, const char *)": "char *\n__argz_next (const char *argz, size_t argz_len, const char *entry)\n{\n  if (entry)\n    {\n      if (entry < argz + argz_len)\n\tentry = strchr (entry, '\\0') + 1;\n\n      return entry >= argz + argz_len ? NULL : (char *) entry;\n    }\n  else\n    if (argz_len > 0)\n      return (char *) argz;\n    else\n      return NULL;\n}",
    "__argz_stringify(char *, int, int)": "void\n__argz_stringify (char *argz, size_t len, int sep)\n{\n  if (len > 0)\n    while (1)\n      {\n\tsize_t part_len = __strnlen (argz, len);\n\targz += part_len;\n\tlen -= part_len;\n\tif (len-- <= 1)\t\t/* includes final '\\0' we want to stop at */\n\t  break;\n\t*argz++ = sep;\n      }\n}",
    "bcopy(const void *, void *, int)": "void\nbcopy (const void *src, void *dest, size_t len)\n{\n  memmove (dest, src, len);\n}",
    "__bzero(void *, int)": "void\n__bzero (void *s, size_t len)\n{\n  memset (s, '\\0', len);\n}",
    "envz_entry(const char *, int, const char *)": "char *\nenvz_entry (const char *envz, size_t envz_len, const char *name)\n{\n  while (envz_len)\n    {\n      const char *p = name;\n      const char *entry = envz;\t/* Start of this entry. */\n\n      /* See how far NAME and ENTRY match.  */\n      while (envz_len && *p == *envz && *p && *p != SEP)\n\tp++, envz++, envz_len--;\n\n      if ((*envz == '\\0' || *envz == SEP) && (*p == '\\0' || *p == SEP))\n\t/* Bingo! */\n\treturn (char *) entry;\n\n      /* No match, skip to the next entry.  */\n      while (envz_len && *envz)\n\tenvz++, envz_len--;\n      if (envz_len)\n\tenvz++, envz_len--;\t/* skip '\\0' */\n    }\n\n  return 0;\n}",
    "envz_remove(char **, int *, const char *)": "void\nenvz_remove (char **envz, size_t *envz_len, const char *name)\n{\n  char *entry = envz_entry (*envz, *envz_len, name);\n  if (entry)\n    argz_delete (envz, envz_len, entry);\n}",
    "envz_merge(char **, int *, const char *, int, int)": "error_t\nenvz_merge (char **envz, size_t *envz_len, const char *envz2,\n\t    size_t envz2_len, int override)\n{\n  error_t err = 0;\n\n  while (envz2_len && ! err)\n    {\n      char *old = envz_entry (*envz, *envz_len, envz2);\n      size_t new_len = strlen (envz2) + 1;\n\n      if (! old)\n\terr = __argz_append (envz, envz_len, envz2, new_len);\n      else if (override)\n\t{\n\t  argz_delete (envz, envz_len, old);\n\t  err = __argz_append (envz, envz_len, envz2, new_len);\n\t}\n\n      envz2 += new_len;\n      envz2_len -= new_len;\n    }\n\n  return err;\n}",
    "envz_strip(char **, int *)": "void\nenvz_strip (char **envz, size_t *envz_len)\n{\n  char *entry = *envz;\n  size_t left = *envz_len;\n  while (left)\n    {\n      size_t entry_len = strlen (entry) + 1;\n      left -= entry_len;\n      if (! strchr (entry, SEP))\n\t/* Null entry. */\n\tmemmove (entry, entry + entry_len, left);\n      else\n\tentry += entry_len;\n    }\n  *envz_len = entry - *envz;\n}",
    "explicit_bzero(void *, int)": "void\nexplicit_bzero (void *s, size_t len)\n{\n  memset (s, '\\0', len);\n  /* Compiler barrier.  */\n  asm volatile (\"\" ::: \"memory\");\n}",
    "__ffs(int)": "int\n__ffs (int x)\n{\n  int cnt;\n  int tmp;\n\n  asm (\"bsfl %2,%0\\n\"\t\t/* Count low bits in X and store in %1.  */\n       \"cmovel %1,%0\\n\"\t\t/* If number was zero, use -1 as result.  */\n       : \"=&r\" (cnt), \"=r\" (tmp) : \"rm\" (x), \"1\" (-1));\n\n  return cnt + 1;\n}",
    "ffsll(long long)": "int\nffsll (long long int x)\n{\n  long long int cnt;\n  long long int tmp;\n\n  asm (\"bsfq %2,%0\\n\"\t\t/* Count low bits in X and store in %1.  */\n       \"cmoveq %1,%0\\n\"\t\t/* If number was zero, use -1 as result.  */\n       : \"=&r\" (cnt), \"=r\" (tmp) : \"rm\" (x), \"1\" (-1));\n\n  return cnt + 1;\n}",
    "memcmp(const void *, const void *, int)": "int\nMEMCMP (const void *s1, const void *s2, size_t len)\n{\n  op_t a0;\n  op_t b0;\n  long int srcp1 = (long int) s1;\n  long int srcp2 = (long int) s2;\n  op_t res;\n\n  if (len >= OP_T_THRES)\n    {\n      /* There are at least some bytes to compare.  No need to test\n\t for LEN == 0 in this alignment loop.  */\n      while (srcp2 % OPSIZ != 0)\n\t{\n\t  a0 = ((byte *) srcp1)[0];\n\t  b0 = ((byte *) srcp2)[0];\n\t  srcp1 += 1;\n\t  srcp2 += 1;\n\t  res = a0 - b0;\n\t  if (res != 0)\n\t    return res;\n\t  len -= 1;\n\t}\n\n      /* SRCP2 is now aligned for memory operations on `op_t'.\n\t SRCP1 alignment determines if we can do a simple,\n\t aligned compare or need to shuffle bits.  */\n\n      if (srcp1 % OPSIZ == 0)\n\tres = memcmp_common_alignment (srcp1, srcp2, len / OPSIZ);\n      else\n\tres = memcmp_not_common_alignment (srcp1, srcp2, len / OPSIZ);\n      if (res != 0)\n\treturn res;\n\n      /* Number of bytes remaining in the interval [0..OPSIZ-1].  */\n      srcp1 += len & -OPSIZ;\n      srcp2 += len & -OPSIZ;\n      len %= OPSIZ;\n    }\n\n  /* There are just a few bytes to compare.  Use byte memory operations.  */\n  while (len != 0)\n    {\n      a0 = ((byte *) srcp1)[0];\n      b0 = ((byte *) srcp2)[0];\n      srcp1 += 1;\n      srcp2 += 1;\n      res = a0 - b0;\n      if (res != 0)\n\treturn res;\n      len -= 1;\n    }\n\n  return 0;\n}",
    "memcpy(void *, const void *, int)": "void *\nMEMCPY (void *dstpp, const void *srcpp, size_t len)\n{\n  unsigned long int dstp = (long int) dstpp;\n  unsigned long int srcp = (long int) srcpp;\n\n  /* Copy from the beginning to the end.  */\n\n  /* If there not too few bytes to copy, use word copy.  */\n  if (len >= OP_T_THRES)\n    {\n      /* Copy just a few bytes to make DSTP aligned.  */\n      len -= (-dstp) % OPSIZ;\n      BYTE_COPY_FWD (dstp, srcp, (-dstp) % OPSIZ);\n\n      /* Copy whole pages from SRCP to DSTP by virtual address manipulation,\n\t as much as possible.  */\n\n      PAGE_COPY_FWD_MAYBE (dstp, srcp, len, len);\n\n      /* Copy from SRCP to DSTP taking advantage of the known alignment of\n\t DSTP.  Number of bytes remaining is put in the third argument,\n\t i.e. in LEN.  This number may vary from machine to machine.  */\n\n      WORD_COPY_FWD (dstp, srcp, len, len);\n\n      /* Fall out and copy the tail.  */\n    }\n\n  /* There are just a few bytes to copy.  Use byte memory operations.  */\n  BYTE_COPY_FWD (dstp, srcp, len);\n\n  return dstpp;\n}",
    "memfrob(void *, int)": "void *\nmemfrob (void *s, size_t n)\n{\n  char *p = (char *) s;\n\n  while (n-- > 0)\n    *p++ ^= 42;\n\n  return s;\n}",
    "memmem(const void *, int, const void *, int)": "void *\n__memmem (const void *haystack, size_t hs_len,\n\t  const void *needle, size_t ne_len)\n{\n  const unsigned char *hs = (const unsigned char *) haystack;\n  const unsigned char *ne = (const unsigned char *) needle;\n\n  if (ne_len == 0)\n    return (void *) hs;\n  if (ne_len == 1)\n    return (void *) memchr (hs, ne[0], hs_len);\n\n  /* Ensure haystack length is >= needle length.  */\n  if (hs_len < ne_len)\n    return NULL;\n\n  const unsigned char *end = hs + hs_len - ne_len;\n\n  if (ne_len == 2)\n    {\n      uint32_t nw = ne[0] << 16 | ne[1], hw = hs[0] << 16 | hs[1];\n      for (hs++; hs <= end && hw != nw; )\n\thw = hw << 16 | *++hs;\n      return hw == nw ? (void *)hs - 1 : NULL;\n    }\n\n  /* Use Two-Way algorithm for very long needles.  */\n  if (__builtin_expect (ne_len > 256, 0))\n    return two_way_long_needle (hs, hs_len, ne, ne_len);\n\n  uint8_t shift[256];\n  size_t tmp, shift1;\n  size_t m1 = ne_len - 1;\n  size_t offset = 0;\n\n  memset (shift, 0, sizeof (shift));\n  for (int i = 1; i < m1; i++)\n    shift[hash2 (ne + i)] = i;\n  /* Shift1 is the amount we can skip after matching the hash of the\n     needle end but not the full needle.  */\n  shift1 = m1 - shift[hash2 (ne + m1)];\n  shift[hash2 (ne + m1)] = m1;\n\n  for ( ; hs <= end; )\n    {\n      /* Skip past character pairs not in the needle.  */\n      do\n\t{\n\t  hs += m1;\n\t  tmp = shift[hash2 (hs)];\n\t}\n      while (tmp == 0 && hs <= end);\n\n      /* If the match is not at the end of the needle, shift to the end\n\t and continue until we match the hash of the needle end.  */\n      hs -= tmp;\n      if (tmp < m1)\n\tcontinue;\n\n      /* Hash of the last 2 characters matches.  If the needle is long,\n\t try to quickly filter out mismatches.  */\n      if (m1 < 15 || memcmp (hs + offset, ne + offset, 8) == 0)\n\t{\n\t  if (memcmp (hs, ne, m1) == 0)\n\t    return (void *) hs;\n\n\t  /* Adjust filter offset when it doesn't find the mismatch.  */\n\t  offset = (offset >= 8 ? offset : m1) - 8;\n\t}\n\n      /* Skip based on matching the hash of the needle end.  */\n      hs += shift1;\n    }\n  return NULL;\n}",
    "__mempcpy(void *, const void *, int)": "void *\nMEMPCPY (void *dest, const void *src, size_t len)\n{\n  return memcpy (dest, src, len) + len;\n}",
    "__rawmemchr(const void *, int)": "void *\nRAWMEMCHR (const void *s, int c)\n{\n  if ((unsigned char) c != '\\0')\n    return memchr (s, c, (size_t)-1);\n  return (char *)s + strlen (s);\n}",
    "sigabbrev_np(int)": "const char *\nsigabbrev_np (int signum)\n{\n  const char *abbrev = NULL;\n\n  if (signum >= 0 && signum <= NSIG\n      && signum < array_length (__sys_sigabbrev))\n    abbrev = __sys_sigabbrev[signum];\n\n  return abbrev;\n}",
    "__stpcpy(char *, const char *)": "char *\nSTPCPY (char *dest, const char *src)\n{\n  /* Copy just a few bytes to make DEST aligned.  */\n  size_t len = (-(uintptr_t) dest) % OPSIZ;\n  for (; len != 0; len--, ++dest)\n    {\n      char c = *src++;\n      *dest = c;\n      if (c == '\\0')\n\treturn dest;\n    }\n\n  /* DEST is now aligned to op_t, SRC may or may not be.  */\n  uintptr_t ofs = (uintptr_t) src % OPSIZ;\n  return ofs == 0 ? stpcpy_aligned_loop ((op_t*) dest, (const op_t *) src)\n\t\t  : stpcpy_unaligned_loop ((op_t*) dest,\n\t\t\t\t\t   (const op_t *) (src - ofs) , ofs);\n}",
    "stpncpy(char *, const char *, int)": "char *\nSTPNCPY (char *dest, const char *src, size_t n)\n{\n  size_t size = __strnlen (src, n);\n  memcpy (dest, src, size);\n  dest += size;\n  if (size == n)\n    return dest;\n  return memset (dest, '\\0', n - size);\n}",
    "strcasecmp(const char *, const char *)": "int\n__strcasecmp (const char *s1, const char *s2 LOCALE_PARAM)\n{\n#if defined _LIBC && !defined USE_IN_EXTENDED_LOCALE_MODEL\n  locale_t loc = _NL_CURRENT_LOCALE;\n#endif\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  int result;\n\n  if (p1 == p2)\n    return 0;\n\n  while ((result = TOLOWER (*p1) - TOLOWER (*p2++)) == 0)\n    if (*p1++ == '\\0')\n      break;\n\n  return result;\n}",
    "strcasecmp(const char *, const char *, locale_t)": "int\n__strcasecmp (const char *s1, const char *s2 LOCALE_PARAM)\n{\n#if defined _LIBC && !defined USE_IN_EXTENDED_LOCALE_MODEL\n  locale_t loc = _NL_CURRENT_LOCALE;\n#endif\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  int result;\n\n  if (p1 == p2)\n    return 0;\n\n  while ((result = TOLOWER (*p1) - TOLOWER (*p2++)) == 0)\n    if (*p1++ == '\\0')\n      break;\n\n  return result;\n}",
    "__strcasestr(const char *, const char *)": "char *\nSTRCASESTR (const char *haystack, const char *needle)\n{\n  size_t needle_len; /* Length of NEEDLE.  */\n  size_t haystack_len; /* Known minimum length of HAYSTACK.  */\n\n  /* Handle empty NEEDLE special case.  */\n  if (needle[0] == '\\0')\n    return (char *) haystack;\n\n  /* Ensure HAYSTACK length is at least as long as NEEDLE length.\n     Since a match may occur early on in a huge HAYSTACK, use strnlen\n     and read ahead a few cachelines for improved performance.  */\n  needle_len = strlen (needle);\n  haystack_len = __strnlen (haystack, needle_len + 256);\n  if (haystack_len < needle_len)\n    return NULL;\n\n  /* Perform the search.  Abstract memory is considered to be an array\n     of 'unsigned char' values, not an array of 'char' values.  See\n     ISO C 99 section 6.2.6.1.  */\n  if (needle_len < LONG_NEEDLE_THRESHOLD)\n    return two_way_short_needle ((const unsigned char *) haystack,\n\t\t\t\t haystack_len,\n\t\t\t\t (const unsigned char *) needle,\n\t\t\t\t needle_len);\n  return two_way_long_needle ((const unsigned char *) haystack, haystack_len,\n\t\t\t      (const unsigned char *) needle,\n\t\t\t      needle_len);\n}",
    "strcat(char *, const char *)": "char *\nSTRCAT (char *dest, const char *src)\n{\n  strcpy (dest + strlen (dest), src);\n  return dest;\n}",
    "strchr(const char *, int)": "char *\nstrchr (const char *s, int c_in)\n{\n  char *r = __strchrnul (s, c_in);\n  return (*(unsigned char *)r == (unsigned char)c_in) ? r : NULL;\n}",
    "strcmp(const char *, const char *)": "int\nstrcmp (const char *p1, const char *p2)\n{\n  /* Handle the unaligned bytes of p1 first.  */\n  uintptr_t n = -(uintptr_t)p1 % sizeof(op_t);\n  for (int i = 0; i < n; ++i)\n    {\n      unsigned char c1 = *p1++;\n      unsigned char c2 = *p2++;\n      int diff = c1 - c2;\n      if (c1 == '\\0' || diff != 0)\n\treturn diff;\n    }\n\n  /* P1 is now aligned to op_t.  P2 may or may not be.  */\n  const op_t *x1 = (const op_t *) p1;\n  op_t w1 = *x1++;\n  uintptr_t ofs = (uintptr_t) p2 % sizeof(op_t);\n  return ofs == 0\n    ? strcmp_aligned_loop (x1, (const op_t *)p2, w1)\n    : strcmp_unaligned_loop (x1, (const op_t *)(p2 - ofs), w1, ofs);\n}",
    "strcoll(const char *, const char *)": "int\nSTRCOLL (const STRING_TYPE *s1, const STRING_TYPE *s2)\n{\n  return STRCOLL_L (s1, s2, _NL_CURRENT_LOCALE);\n}",
    "__strcoll_l(const char *, const char *, locale_t)": "int\nSTRCOLL (const STRING_TYPE *s1, const STRING_TYPE *s2, locale_t l)\n{\n  struct __locale_data *current = l->__locales[LC_COLLATE];\n  uint32_t nrules = current->values[_NL_ITEM_INDEX (_NL_COLLATE_NRULES)].word;\n  /* We don't assign the following values right away since it might be\n     unnecessary in case there are no rules.  */\n  const unsigned char *rulesets;\n  const int32_t *table;\n  const USTRING_TYPE *weights;\n  const USTRING_TYPE *extra;\n  const int32_t *indirect;\n\n  if (nrules == 0)\n    return STRCMP (s1, s2);\n\n  /* Catch empty strings.  */\n  if (__glibc_unlikely (*s1 == '\\0') || __glibc_unlikely (*s2 == '\\0'))\n    return (*s1 != '\\0') - (*s2 != '\\0');\n\n  rulesets = (const unsigned char *)\n    current->values[_NL_ITEM_INDEX (_NL_COLLATE_RULESETS)].string;\n  table = (const int32_t *)\n    current->values[_NL_ITEM_INDEX (CONCAT(_NL_COLLATE_TABLE,SUFFIX))].string;\n  weights = (const USTRING_TYPE *)\n    current->values[_NL_ITEM_INDEX (CONCAT(_NL_COLLATE_WEIGHT,SUFFIX))].string;\n  extra = (const USTRING_TYPE *)\n    current->values[_NL_ITEM_INDEX (CONCAT(_NL_COLLATE_EXTRA,SUFFIX))].string;\n  indirect = (const int32_t *)\n    current->values[_NL_ITEM_INDEX (CONCAT(_NL_COLLATE_INDIRECT,SUFFIX))].string;\n\n  assert (((uintptr_t) table) % __alignof__ (table[0]) == 0);\n  assert (((uintptr_t) weights) % __alignof__ (weights[0]) == 0);\n  assert (((uintptr_t) extra) % __alignof__ (extra[0]) == 0);\n  assert (((uintptr_t) indirect) % __alignof__ (indirect[0]) == 0);\n\n  int result = 0, rule = 0;\n\n  /* With GCC 7 when compiling with -Os the compiler warns that\n     seq1.back_us and seq2.back_us might be used uninitialized.\n     Sometimes this warning appears at locations in locale/weightwc.h\n     where the actual use is, but on architectures other than x86_64,\n     x86 and s390x, a warning appears at the definitions of seq1 and\n     seq2.  This uninitialized use is impossible for the same reason\n     as described in comments in locale/weightwc.h.  */\n  DIAG_PUSH_NEEDS_COMMENT;\n  DIAG_IGNORE_Os_NEEDS_COMMENT (7, \"-Wmaybe-uninitialized\");\n  coll_seq seq1, seq2;\n  DIAG_POP_NEEDS_COMMENT;\n  seq1.len = 0;\n  seq1.idxmax = 0;\n  seq1.rule = 0;\n  seq2.len = 0;\n  seq2.idxmax = 0;\n\n  for (int pass = 0; pass < nrules; ++pass)\n    {\n      seq1.idxcnt = 0;\n      seq1.idx = 0;\n      seq2.idx = 0;\n      seq1.backw_stop = ~0ul;\n      seq1.backw = ~0ul;\n      seq2.idxcnt = 0;\n      seq2.backw_stop = ~0ul;\n      seq2.backw = ~0ul;\n\n      /* We need the elements of the strings as unsigned values since they\n\t are used as indices.  */\n      seq1.us = (const USTRING_TYPE *) s1;\n      seq2.us = (const USTRING_TYPE *) s2;\n\n      /* We assume that if a rule has defined `position' in one section\n\t this is true for all of them.  Please note that the localedef programs\n\t makes sure that `position' is not used at the first level.  */\n\n      int position = rulesets[rule * nrules + pass] & sort_position;\n\n      while (1)\n\t{\n\t  get_next_seq (&seq1, nrules, rulesets, weights, table,\n\t\t\t\t    extra, indirect, pass);\n\t  get_next_seq (&seq2, nrules, rulesets, weights, table,\n\t\t\t\t    extra, indirect, pass);\n\t  /* See whether any or both strings are empty.  */\n\t  if (seq1.len == 0 || seq2.len == 0)\n\t    {\n\t      if (seq1.len == seq2.len)\n\t\t{\n\t\t  /* Both strings ended and are equal at this level.  Do a\n\t\t     byte-level comparison to ensure that we don't waste time\n\t\t     going through multiple passes for totally equal strings\n\t\t     before proceeding to subsequent passes.  */\n\t\t  if (pass == 0 && STRCMP (s1, s2) == 0)\n\t\t    return result;\n\t\t  else\n\t\t    break;\n\t        }\n\n\t      /* This means one string is shorter than the other.  Find out\n\t\t which one and return an appropriate value.  */\n\t      return seq1.len == 0 ? -1 : 1;\n\t    }\n\n\t  result = do_compare (&seq1, &seq2, position, weights);\n\t  if (result != 0)\n\t    return result;\n\t}\n\n      rule = seq1.rule;\n    }\n\n  return result;\n}",
    "strcpy(char *, const char *)": "char *\nSTRCPY (char *dest, const char *src)\n{\n  __stpcpy (dest, src);\n  return dest;\n}",
    "strcspn(const char *, const char *)": "size_t\nSTRCSPN (const char *str, const char *reject)\n{\n  if (__glibc_unlikely (reject[0] == '\\0')\n      || __glibc_unlikely (reject[1] == '\\0'))\n    return __strchrnul (str, reject [0]) - str;\n\n  /* Use multiple small memsets to enable inlining on most targets.  */\n  unsigned char table[256];\n  unsigned char *p = memset (table, 0, 64);\n  memset (p + 64, 0, 64);\n  memset (p + 128, 0, 64);\n  memset (p + 192, 0, 64);\n\n  unsigned char *s = (unsigned char*) reject;\n  unsigned char tmp;\n  do\n    p[tmp = *s++] = 1;\n  while (tmp);\n\n  s = (unsigned char*) str;\n  if (p[s[0]]) return 0;\n  if (p[s[1]]) return 1;\n  if (p[s[2]]) return 2;\n  if (p[s[3]]) return 3;\n\n  s = (unsigned char *) PTR_ALIGN_DOWN (s, 4);\n\n  unsigned int c0, c1, c2, c3;\n  do\n    {\n      s += 4;\n      c0 = p[s[0]];\n      c1 = p[s[1]];\n      c2 = p[s[2]];\n      c3 = p[s[3]];\n    }\n  while ((c0 | c1 | c2 | c3) == 0);\n\n  size_t count = s - (unsigned char *) str;\n  return (c0 | c1) != 0 ? count - c0 + 1 : count - c2 + 3;\n}",
    "strdup(const char *)": "char *\n__strdup (const char *s)\n{\n  size_t len = strlen (s) + 1;\n  void *new = malloc (len);\n\n  if (new == NULL)\n    return NULL;\n\n  return (char *) memcpy (new, s, len);\n}",
    "strerror(int)": "char *\nstrerror (int errnum)\n{\n  return __strerror_l (errnum, __libc_tsd_get (locale_t, LOCALE));\n}",
    "strerrorname_np(int)": "const char *\nstrerrorname_np (int errnum)\n{\n  return __get_errname (errnum);\n}",
    "strfry(char *)": "char *\nstrfry (char *string)\n{\n  static int init;\n  static struct random_data rdata;\n\n  if (!init)\n    {\n      static char state[32];\n      rdata.state = NULL;\n      __initstate_r (random_bits (),\n\t\t     state, sizeof (state), &rdata);\n      init = 1;\n    }\n\n  size_t len = strlen (string);\n  if (len > 0)\n    for (size_t i = 0; i < len - 1; ++i)\n      {\n\tint32_t j;\n\t__random_r (&rdata, &j);\n\tj = j % (len - i) + i;\n\n\tchar c = string[i];\n\tstring[i] = string[j];\n\tstring[j] = c;\n      }\n\n  return string;\n}",
    "strncasecmp(const char *, const char *, int)": "int\n__strncasecmp (const char *s1, const char *s2, size_t n LOCALE_PARAM)\n{\n#if defined _LIBC && !defined USE_IN_EXTENDED_LOCALE_MODEL\n  locale_t loc = _NL_CURRENT_LOCALE;\n#endif\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  int result;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  while ((result = TOLOWER (*p1) - TOLOWER (*p2++)) == 0)\n    if (*p1++ == '\\0' || --n == 0)\n      break;\n\n  return result;\n}",
    "strncasecmp(const char *, const char *, int, locale_t)": "int\n__strncasecmp (const char *s1, const char *s2, size_t n LOCALE_PARAM)\n{\n#if defined _LIBC && !defined USE_IN_EXTENDED_LOCALE_MODEL\n  locale_t loc = _NL_CURRENT_LOCALE;\n#endif\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  int result;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  while ((result = TOLOWER (*p1) - TOLOWER (*p2++)) == 0)\n    if (*p1++ == '\\0' || --n == 0)\n      break;\n\n  return result;\n}",
    "strncat(char *, const char *, int)": "char *\nSTRNCAT (char *s1, const char *s2, size_t n)\n{\n  char *s = s1;\n\n  /* Find the end of S1.  */\n  s1 += strlen (s1);\n\n  size_t ss = __strnlen (s2, n);\n\n  s1[ss] = '\\0';\n  memcpy (s1, s2, ss);\n\n  return s;\n}",
    "strncmp(const char *, const char *, int)": "int\nSTRNCMP (const char *p1, const char *p2, size_t n)\n{\n  /* Handle the unaligned bytes of p1 first.  */\n  uintptr_t a = MIN (-(uintptr_t)p1 % sizeof(op_t), n);\n  int diff = 0;\n  for (int i = 0; i < a; ++i)\n    {\n      unsigned char c1 = *p1++;\n      unsigned char c2 = *p2++;\n      diff = c1 - c2;\n      if (c1 == '\\0' || diff != 0)\n\treturn diff;\n    }\n  if (a == n)\n    return 0;\n\n  /* P1 is now aligned to op_t.  P2 may or may not be.  */\n  const op_t *x1 = (const op_t *) p1;\n  op_t w1 = *x1++;\n  uintptr_t ofs = (uintptr_t) p2 % sizeof(op_t);\n  return ofs == 0\n    ? strncmp_aligned_loop (x1, (const op_t *) p2, w1, n - a)\n    : strncmp_unaligned_loop (x1, (const op_t *) (p2 - ofs), w1, ofs, n - a);\n}",
    "strncpy(char *, const char *, int)": "char *\nSTRNCPY (char *s1, const char *s2, size_t n)\n{\n  size_t size = __strnlen (s2, n);\n  if (size != n)\n    memset (s1 + size, '\\0', n - size);\n  return memcpy (s1, s2, size);\n}",
    "strndup(const char *, int)": "char *\n__strndup (const char *s, size_t n)\n{\n  size_t len = __strnlen (s, n);\n  char *new = (char *) malloc (len + 1);\n\n  if (new == NULL)\n    return NULL;\n\n  new[len] = '\\0';\n  return (char *) memcpy (new, s, len);\n}",
    "strpbrk(const char *, const char *)": "char *\nSTRPBRK (const char *s, const char *accept)\n{\n  s += strcspn (s, accept);\n  return *s ? (char *)s : NULL;\n}",
    "strrchr(const char *, int)": "char *\nSTRRCHR (const char *s, int c)\n{\n  return __memrchr (s, c, strlen (s) + 1);\n}",
    "strsignal(int)": "char *\nstrsignal (int signum)\n{\n  const char *desc = __sigdescr_np (signum);\n  if (desc != NULL)\n    return _(desc);\n\n  struct tls_internal_t *tls_internal = __glibc_tls_internal ();\n  free (tls_internal->strsignal_buf);\n\n  int r;\n#ifdef SIGRTMIN\n  if (signum >= SIGRTMIN && signum <= SIGRTMAX)\n    r = __asprintf (&tls_internal->strsignal_buf, _(\"Real-time signal %d\"),\n\t\t    signum - SIGRTMIN);\n  else\n#endif\n    r = __asprintf (&tls_internal->strsignal_buf, _(\"Unknown signal %d\"),\n\t\t    signum);\n\n  if (r == -1)\n    tls_internal->strsignal_buf = NULL;\n\n  return tls_internal->strsignal_buf;\n}",
    "strspn(const char *, const char *)": "size_t\n__attribute__ ((section (\".text.sse4.2\")))\nSTRSPN (const char *s, const char *a)\n{\n  if (*a == 0)\n    return 0;\n\n  const char *aligned;\n  __m128i mask, maskz, zero;\n  unsigned int maskz_bits;\n  unsigned int offset = (int) ((size_t) a & 15);\n  zero = _mm_set1_epi8 (0);\n  if (offset != 0)\n    {\n      /* Load masks.  */\n      aligned = (const char *) ((size_t) a & -16L);\n      __m128i mask0 = _mm_load_si128 ((__m128i *) aligned);\n      maskz = _mm_cmpeq_epi8 (mask0, zero);\n\n      /* Find where the NULL terminator is.  */\n      maskz_bits = _mm_movemask_epi8 (maskz) >> offset;\n      if (maskz_bits != 0)\n        {\n          mask = __m128i_shift_right (mask0, offset);\n          offset = (unsigned int) ((size_t) s & 15);\n          if (offset)\n            goto start_unaligned;\n\n          aligned = s;\n          goto start_loop;\n        }\n    }\n\n  /* A is aligned.  */\n  mask = _mm_loadu_si128 ((__m128i *) a);\n\n  /* Find where the NULL terminator is.  */\n  maskz = _mm_cmpeq_epi8 (mask, zero);\n  maskz_bits = _mm_movemask_epi8 (maskz);\n  if (maskz_bits == 0)\n    {\n      /* There is no NULL terminator.  Don't use SSE4.2 if the length\n         of A > 16.  */\n      if (a[16] != 0)\n        return __strspn_generic (s, a);\n    }\n  aligned = s;\n  offset = (unsigned int) ((size_t) s & 15);\n\n  if (offset != 0)\n    {\n    start_unaligned:\n      /* Check partial string.  */\n      aligned = (const char *) ((size_t) s & -16L);\n      __m128i value = _mm_load_si128 ((__m128i *) aligned);\n      __m128i adj_value = __m128i_shift_right (value, offset);\n\n      unsigned int length = _mm_cmpistri (mask, adj_value, 0x12);\n      /* No need to check CFlag since it is always 1.  */\n      if (length < 16 - offset)\n\treturn length;\n      /* Find where the NULL terminator is.  */\n      maskz = _mm_cmpeq_epi8 (value, zero);\n      maskz_bits = _mm_movemask_epi8 (maskz) >> offset;\n      if (maskz_bits != 0)\n\treturn length;\n      aligned += 16;\n    }\n\nstart_loop:\n  while (1)\n    {\n      __m128i value = _mm_load_si128 ((__m128i *) aligned);\n      unsigned int index = _mm_cmpistri (mask, value, 0x12);\n      unsigned int cflag = _mm_cmpistrc (mask, value, 0x12);\n      if (cflag)\n\treturn (size_t) (aligned + index - s);\n      aligned += 16;\n    }\n}",
    "strstr(const char *, const char *)": "char *\nSTRSTR (const char *haystack, const char *needle)\n{\n  const unsigned char *hs = (const unsigned char *) haystack;\n  const unsigned char *ne = (const unsigned char *) needle;\n\n  /* Handle short needle special cases first.  */\n  if (ne[0] == '\\0')\n    return (char *)hs;\n  hs = (const unsigned char *)strchr ((const char*)hs, ne[0]);\n  if (hs == NULL || ne[1] == '\\0')\n    return (char*)hs;\n  if (ne[2] == '\\0')\n    return strstr2 (hs, ne);\n  if (ne[3] == '\\0')\n    return strstr3 (hs, ne);\n\n  /* Ensure haystack length is at least as long as needle length.\n     Since a match may occur early on in a huge haystack, use strnlen\n     and read ahead a few cachelines for improved performance.  */\n  size_t ne_len = strlen ((const char*)ne);\n  size_t hs_len = __strnlen ((const char*)hs, ne_len | 512);\n  if (hs_len < ne_len)\n    return NULL;\n\n  /* Check whether we have a match.  This improves performance since we\n     avoid initialization overheads.  */\n  if (memcmp (hs, ne, ne_len) == 0)\n    return (char *) hs;\n\n  /* Use Two-Way algorithm for very long needles.  */\n  if (__glibc_unlikely (ne_len > 256))\n    return two_way_long_needle (hs, hs_len, ne, ne_len);\n\n  const unsigned char *end = hs + hs_len - ne_len;\n  uint8_t shift[256];\n  size_t tmp, shift1;\n  size_t m1 = ne_len - 1;\n  size_t offset = 0;\n\n  /* Initialize bad character shift hash table.  */\n  memset (shift, 0, sizeof (shift));\n  for (int i = 1; i < m1; i++)\n    shift[hash2 (ne + i)] = i;\n  /* Shift1 is the amount we can skip after matching the hash of the\n     needle end but not the full needle.  */\n  shift1 = m1 - shift[hash2 (ne + m1)];\n  shift[hash2 (ne + m1)] = m1;\n\n  while (1)\n    {\n      if (__glibc_unlikely (hs > end))\n\t{\n\t  end += __strnlen ((const char*)end + m1 + 1, 2048);\n\t  if (hs > end)\n\t    return NULL;\n\t}\n\n      /* Skip past character pairs not in the needle.  */\n      do\n\t{\n\t  hs += m1;\n\t  tmp = shift[hash2 (hs)];\n\t}\n      while (tmp == 0 && hs <= end);\n\n      /* If the match is not at the end of the needle, shift to the end\n\t and continue until we match the hash of the needle end.  */\n      hs -= tmp;\n      if (tmp < m1)\n\tcontinue;\n\n      /* Hash of the last 2 characters matches.  If the needle is long,\n\t try to quickly filter out mismatches.  */\n      if (m1 < 15 || memcmp (hs + offset, ne + offset, 8) == 0)\n\t{\n\t  if (memcmp (hs, ne, m1) == 0)\n\t    return (void *) hs;\n\n\t  /* Adjust filter offset when it doesn't find the mismatch.  */\n\t  offset = (offset >= 8 ? offset : m1) - 8;\n\t}\n\n      /* Skip based on matching the hash of the needle end.  */\n      hs += shift1;\n    }\n}",
    "strtok(char *, const char *)": "char *\nstrtok (char *s, const char *delim)\n{\n  static char *olds;\n  return __strtok_r (s, delim, &olds);\n}",
    "strtok_r(char *, const char *, char **)": "char *\n__strtok_r (char *s, const char *delim, char **save_ptr)\n{\n  char *end;\n\n  if (s == NULL)\n    s = *save_ptr;\n\n  if (*s == '\\0')\n    {\n      *save_ptr = s;\n      return NULL;\n    }\n\n  /* Scan leading delimiters.  */\n  s += strspn (s, delim);\n  if (*s == '\\0')\n    {\n      *save_ptr = s;\n      return NULL;\n    }\n\n  /* Find the end of the token.  */\n  end = s + strcspn (s, delim);\n  if (*end == '\\0')\n    {\n      *save_ptr = end;\n      return s;\n    }\n\n  /* Terminate the token and make *SAVE_PTR point past it.  */\n  *end = '\\0';\n  *save_ptr = end + 1;\n  return s;\n}",
    "__strverscmp(const char *, const char *)": "nt\n__strverscmp (const char *s1, const char *s2)\n{\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n\n  /* Symbol(s)    0       [1-9]   others\n     Transition   (10) 0  (01) d  (00) x   */\n  static const uint8_t next_state[] =\n  {\n      /* state    x    d    0  */\n      /* S_N */  S_N, S_I, S_Z,\n      /* S_I */  S_N, S_I, S_I,\n      /* S_F */  S_N, S_F, S_F,\n      /* S_Z */  S_N, S_F, S_Z\n  };\n\n  static const int8_t result_type[] =\n  {\n      /* state   x/x  x/d  x/0  d/x  d/d  d/0  0/x  0/d  0/0  */\n\n      /* S_N */  CMP, CMP, CMP, CMP, LEN, CMP, CMP, CMP, CMP,\n      /* S_I */  CMP, -1,  -1,  +1,  LEN, LEN, +1,  LEN, LEN,\n      /* S_F */  CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,\n      /* S_Z */  CMP, +1,  +1,  -1,  CMP, CMP, -1,  CMP, CMP\n  };\n\n  if (p1 == p2)\n    return 0;\n\n  unsigned char c1 = *p1++;\n  unsigned char c2 = *p2++;\n  /* Hint: '0' is a digit too.  */\n  int state = S_N + ((c1 == '0') + (isdigit (c1) != 0));\n\n  int diff;\n  while ((diff = c1 - c2) == 0)\n    {\n      if (c1 == '\\0')\n\treturn diff;\n\n      state = next_state[state];\n      c1 = *p1++;\n      c2 = *p2++;\n      state += (c1 == '0') + (isdigit (c1) != 0);\n    }\n\n  state = result_type[state * 3 + (((c2 == '0') + (isdigit (c2) != 0)))];\n\n  switch (state)\n  {\n    case CMP:\n      return diff;\n\n    case LEN:\n      while (isdigit (*p1++))\n\tif (!isdigit (*p2++))\n\t  return 1;\n\n      return isdigit (*p2) ? -1 : diff;\n\n    default:\n      return state;\n  }\n}\n",
    "strxfrm(char *, const char *, int)": "size_t\nSTRXFRM (STRING_TYPE *dest, const STRING_TYPE *src, size_t n)\n{\n  return STRXFRM_L (dest, src, n, _NL_CURRENT_LOCALE);\n}",
    "__strxfrm_l(char *, const char *, int, locale_t)": "size_t\nSTRXFRM (STRING_TYPE *dest, const STRING_TYPE *src, size_t n, locale_t l)\n{\n  locale_data_t l_data;\n  struct __locale_data *current = l->__locales[LC_COLLATE];\n  l_data.nrules = current->values[_NL_ITEM_INDEX (_NL_COLLATE_NRULES)].word;\n\n  /* Handle byte comparison case.  */\n  if (l_data.nrules == 0)\n    {\n      size_t srclen = STRLEN (src);\n\n      if (n != 0)\n\tSTPNCPY (dest, src, MIN (srclen + 1, n));\n\n      return srclen;\n    }\n\n  /* Handle an empty string, code hereafter relies on strlen (src) > 0.  */\n  if (*src == L('\\0'))\n    {\n      if (n != 0)\n\t*dest = L('\\0');\n      return 0;\n    }\n\n  /* Get the locale data.  */\n  l_data.rulesets = (unsigned char *)\n    current->values[_NL_ITEM_INDEX (_NL_COLLATE_RULESETS)].string;\n  l_data.table = (int32_t *)\n    current->values[_NL_ITEM_INDEX (CONCAT(_NL_COLLATE_TABLE,SUFFIX))].string;\n  l_data.weights = (USTRING_TYPE *)\n    current->values[_NL_ITEM_INDEX (CONCAT(_NL_COLLATE_WEIGHT,SUFFIX))].string;\n  l_data.extra = (USTRING_TYPE *)\n    current->values[_NL_ITEM_INDEX (CONCAT(_NL_COLLATE_EXTRA,SUFFIX))].string;\n  l_data.indirect = (int32_t *)\n    current->values[_NL_ITEM_INDEX (CONCAT(_NL_COLLATE_INDIRECT,SUFFIX))].string;\n\n  assert (((uintptr_t) l_data.table) % __alignof__ (l_data.table[0]) == 0);\n  assert (((uintptr_t) l_data.weights) % __alignof__ (l_data.weights[0]) == 0);\n  assert (((uintptr_t) l_data.extra) % __alignof__ (l_data.extra[0]) == 0);\n  assert (((uintptr_t) l_data.indirect) % __alignof__ (l_data.indirect[0]) == 0);\n\n  /* We need the elements of the string as unsigned values since they\n     are used as indices.  */\n  const USTRING_TYPE *usrc = (const USTRING_TYPE *) src;\n\n  /* Allocate cache for small strings on the stack and fill it with weight and\n     rule indices.  If the cache size is not sufficient, continue with the\n     uncached xfrm version.  */\n  size_t idxmax = 0;\n  const USTRING_TYPE *cur = usrc;\n  int32_t *idxarr = alloca (SMALL_STR_SIZE * sizeof (int32_t));\n  unsigned char *rulearr = alloca (SMALL_STR_SIZE + 1);\n\n  do\n    {\n      int32_t tmp = findidx (l_data.table, l_data.indirect, l_data.extra, &cur,\n\t\t\t     -1);\n      rulearr[idxmax] = tmp >> 24;\n      idxarr[idxmax] = tmp & 0xffffff;\n\n      ++idxmax;\n    }\n  while (*cur != L('\\0') && idxmax < SMALL_STR_SIZE);\n\n  /* This element is only read, the value never used but to determine\n     another value which then is ignored.  */\n  rulearr[idxmax] = '\\0';\n\n  /* Do the transformation.  */\n  if (*cur == L('\\0'))\n    return do_xfrm_cached (dest, n, &l_data, idxmax, idxarr, rulearr);\n  else\n    return do_xfrm (usrc, dest, n, &l_data);\n}",
    "swab(const void *, void *, ssize_t)": "void\nswab (const void *bfrom, void *bto, ssize_t n)\n{\n  const char *from = (const char *) bfrom;\n  char *to = (char *) bto;\n\n  n &= ~((ssize_t) 1);\n  while (n > 1)\n    {\n      const char b0 = from[--n], b1 = from[--n];\n      to[n] = b0;\n      to[n + 1] = b1;\n    }\n}",
    "__xpg_strerror_r(int, char *, int)": "int\n__xpg_strerror_r (int errnum, char *buf, size_t buflen)\n{\n  int system;\n  int sub;\n  int code;\n  const struct error_system *es;\n  extern void __mach_error_map_compat (int *);\n  const char *estr;\n\n  __mach_error_map_compat (&errnum);\n\n  system = err_get_system (errnum);\n  sub = err_get_sub (errnum);\n  code = err_get_code (errnum);\n\n  if (system > err_max_system || ! __mach_error_systems[system].bad_sub)\n    {\n      __snprintf (buf, buflen, \"%s%X\", _(\"Error in unknown error system: \"),\n\t\t  errnum);\n      return EINVAL;\n    }\n\n  es = &__mach_error_systems[system];\n\n  if (sub >= es->max_sub)\n    estr = (const char *) es->bad_sub;\n  else if (code >= es->subsystem[sub].max_code)\n    return EINVAL;\n  else\n    estr = (const char *) _(es->subsystem[sub].codes[code]);\n\n  size_t estrlen = strlen (estr);\n\n  /* Terminate the string in any case.  */\n  if (buflen > 0)\n    *((char *) __mempcpy (buf, estr, MIN (buflen - 1, estrlen))) = '\\0';\n\n  return buflen <= estrlen ? ERANGE : 0;\n}",
    "authdes_create(const char *, u_int, struct sockaddr *, des_block *)": "AUTH *\nauthdes_create (const char *servername, u_int window,\n\t\tstruct sockaddr *syncaddr, des_block *ckey)\n  /* servername - network name of server */\n  /* window     - time to live */\n  /* syncaddr   - optional addr of host to sync with */\n  /* ckey       - optional conversation key to use */\n{\n  char pkey_data[1024];\n  netobj pkey;\n\n  if (!getpublickey (servername, pkey_data))\n    return NULL;\n\n  pkey.n_bytes = pkey_data;\n  pkey.n_len = strlen (pkey_data) + 1;\n  return authdes_pk_create (servername, &pkey, window, syncaddr, ckey);\n}",
    "authnone_create()": "AUTH *\nauthnone_create (void)\n{\n  __libc_once (authnone_private_guard, authnone_create_once);\n  return &authnone_private.no_client;\n}",
    "authunix_create(char *, uid_t, gid_t, int, gid_t *)": "AUTH *\nauthunix_create (char *machname, uid_t uid, gid_t gid, int len,\n\t\t gid_t *aup_gids)\n{\n  struct authunix_parms aup;\n  char mymem[MAX_AUTH_BYTES];\n  struct timespec now;\n  XDR xdrs;\n  AUTH *auth;\n  struct audata *au;\n\n  /*\n   * Allocate and set up auth handle\n   */\n  auth = (AUTH *) mem_alloc (sizeof (*auth));\n  au = (struct audata *) mem_alloc (sizeof (*au));\n  if (auth == NULL || au == NULL)\n    {\nno_memory:\n      (void) __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n      mem_free (auth, sizeof (*auth));\n      mem_free (au, sizeof (*au));\n      return NULL;\n    }\n  auth->ah_ops = (struct auth_ops *) &auth_unix_ops;\n  auth->ah_private = (caddr_t) au;\n  auth->ah_verf = au->au_shcred = _null_auth;\n  au->au_shfaults = 0;\n\n  /*\n   * fill in param struct from the given params\n   */\n  __clock_gettime (CLOCK_REALTIME, &now);\n  aup.aup_time = now.tv_sec;\n  aup.aup_machname = machname;\n  aup.aup_uid = uid;\n  aup.aup_gid = gid;\n  aup.aup_len = (u_int) len;\n  aup.aup_gids = aup_gids;\n\n  /*\n   * Serialize the parameters into origcred\n   */\n  xdrmem_create (&xdrs, mymem, MAX_AUTH_BYTES, XDR_ENCODE);\n  if (!xdr_authunix_parms (&xdrs, &aup))\n    abort ();\n  au->au_origcred.oa_length = len = XDR_GETPOS (&xdrs);\n  au->au_origcred.oa_flavor = AUTH_UNIX;\n  au->au_origcred.oa_base = mem_alloc ((u_int) len);\n  if (au->au_origcred.oa_base == NULL)\n    goto no_memory;\n  memcpy(au->au_origcred.oa_base, mymem, (u_int) len);\n\n  /*\n   * set auth handle to reflect new cred.\n   */\n  auth->ah_cred = au->au_origcred;\n  marshal_new_auth (auth);\n  return auth;\n}",
    "xdr_authdes_cred(XDR *, struct authdes_cred *)": "bool_t\nxdr_authdes_cred (XDR *xdrs, struct authdes_cred *cred)\n{\n  /*\n   * Unrolled xdr\n   */\n  ATTEMPT (xdr_enum (xdrs, (enum_t *) & cred->adc_namekind));\n  switch (cred->adc_namekind)\n    {\n    case ADN_FULLNAME:\n      ATTEMPT (xdr_string (xdrs, &cred->adc_fullname.name, MAXNETNAMELEN));\n      ATTEMPT (xdr_opaque (xdrs, (caddr_t) & cred->adc_fullname.key,\n\t\t\t   sizeof (des_block)));\n      ATTEMPT (xdr_opaque (xdrs, (caddr_t) & cred->adc_fullname.window,\n\t\t\t   sizeof (cred->adc_fullname.window)));\n      return (TRUE);\n    case ADN_NICKNAME:\n      ATTEMPT (xdr_opaque (xdrs, (caddr_t) & cred->adc_nickname,\n\t\t\t   sizeof (cred->adc_nickname)));\n      return TRUE;\n    default:\n      return FALSE;\n    }\n}",
    "xdr_authunix_parms(XDR *, struct authunix_parms *)": "bool_t\nxdr_authunix_parms (XDR * xdrs, struct authunix_parms *p)\n{\n  if (xdr_u_long (xdrs, &(p->aup_time))\n      && xdr_string (xdrs, &(p->aup_machname), MAX_MACHINE_NAME)\n      && (sizeof (uid_t) == sizeof (short int)\n\t  ? xdr_u_short (xdrs, (u_short *) & (p->aup_uid))\n\t  : xdr_u_int (xdrs, (u_int *) & (p->aup_uid)))\n      && (sizeof (gid_t) == sizeof (short int)\n\t  ? xdr_u_short (xdrs, (u_short *) & (p->aup_gid))\n\t  : xdr_u_int (xdrs, (u_int *) & (p->aup_gid)))\n      && xdr_array (xdrs, (caddr_t *) & (p->aup_gids),\n\t\t    & (p->aup_len), NGRPS, sizeof (gid_t),\n\t\t    (sizeof (gid_t) == sizeof (short int)\n\t\t     ? (xdrproc_t) xdr_u_short\n\t\t     : (xdrproc_t) xdr_u_int)))\n    {\n      return TRUE;\n    }\n  return FALSE;\n}",
    "clnt_create(const char *, u_long, u_long, const char *)": "CLIENT *\nclnt_create (const char *hostname, u_long prog, u_long vers,\n\t     const char *proto)\n{\n  struct protoent protobuf, *p;\n  size_t prtbuflen;\n  char *prttmpbuf;\n  struct sockaddr_in sin;\n  struct sockaddr_un sun;\n  int sock;\n  struct timeval tv;\n  CLIENT *client;\n\n  if (strcmp (proto, \"unix\") == 0)\n    {\n      if (__sockaddr_un_set (&sun, hostname) < 0)\n\t{\n\t  struct rpc_createerr *ce = &get_rpc_createerr ();\n\t  ce->cf_stat = RPC_SYSTEMERROR;\n\t  ce->cf_error.re_errno = errno;\n\t  return NULL;\n\t}\n      sock = RPC_ANYSOCK;\n      client = clntunix_create (&sun, prog, vers, &sock, 0, 0);\n      if (client == NULL)\n\treturn NULL;\n#if 0\n      /* This is not wanted.  This would disable the user from having\n\t a timeout in the clnt_call() call.  Only a call to cnlt_control()\n\t by the user should set the timeout value.  */\n      tv.tv_sec = 25;\n      tv.tv_usec = 0;\n      clnt_control (client, CLSET_TIMEOUT, (char *)&tv);\n#endif\n      return client;\n    }\n\n  if (__libc_rpc_gethostbyname (hostname, &sin) != 0)\n    return NULL;\n\n  prtbuflen = 1024;\n  prttmpbuf = __alloca (prtbuflen);\n  while (__getprotobyname_r (proto, &protobuf, prttmpbuf, prtbuflen, &p) != 0\n\t || p == NULL)\n    if (errno != ERANGE)\n      {\n\tstruct rpc_createerr *ce = &get_rpc_createerr ();\n\tce->cf_stat = RPC_UNKNOWNPROTO;\n\tce->cf_error.re_errno = EPFNOSUPPORT;\n\treturn NULL;\n      }\n    else\n      {\n\t/* Enlarge the buffer.  */\n\tprtbuflen *= 2;\n\tprttmpbuf = __alloca (prtbuflen);\n      }\n\n  sock = RPC_ANYSOCK;\n  switch (p->p_proto)\n    {\n    case IPPROTO_UDP:\n      tv.tv_sec = 5;\n      tv.tv_usec = 0;\n      client = clntudp_create (&sin, prog, vers, tv, &sock);\n      if (client == NULL)\n\t{\n\t  return NULL;\n\t}\n#if 0\n      /* This is not wanted.  This would disable the user from having\n\t a timeout in the clnt_call() call.  Only a call to cnlt_control()\n\t by the user should set the timeout value.  */\n      tv.tv_sec = 25;\n      clnt_control (client, CLSET_TIMEOUT, (char *)&tv);\n#endif\n      break;\n    case IPPROTO_TCP:\n      client = clnttcp_create (&sin, prog, vers, &sock, 0, 0);\n      if (client == NULL)\n\t{\n\t  return NULL;\n\t}\n#if 0\n      /* This is not wanted.  This would disable the user from having\n\t a timeout in the clnt_call() call.  Only a call to cnlt_control()\n\t by the user should set the timeout value.  */\n      tv.tv_sec = 25;\n      tv.tv_usec = 0;\n      clnt_control (client, CLSET_TIMEOUT, (char *)&tv);\n#endif\n      break;\n    default:\n      {\n\tstruct rpc_createerr *ce = &get_rpc_createerr ();\n\tce->cf_stat = RPC_SYSTEMERROR;\n\tce->cf_error.re_errno = EPFNOSUPPORT;\n      }\n      return (NULL);\n    }\n  return client;\n}",
    "clnt_sperror(int *, const char *)": "char *\nclnt_sperror (CLIENT * rpch, const char *msg)\n{\n  struct rpc_err e;\n  CLNT_GETERR (rpch, &e);\n\n  const char *errstr = clnt_sperrno (e.re_status);\n\n  char chrbuf[1024];\n  char *str;\n  char *tmpstr;\n  int res;\n  switch (e.re_status)\n    {\n    case RPC_SUCCESS:\n    case RPC_CANTENCODEARGS:\n    case RPC_CANTDECODERES:\n    case RPC_TIMEDOUT:\n    case RPC_PROGUNAVAIL:\n    case RPC_PROCUNAVAIL:\n    case RPC_CANTDECODEARGS:\n    case RPC_SYSTEMERROR:\n    case RPC_UNKNOWNHOST:\n    case RPC_UNKNOWNPROTO:\n    case RPC_PMAPFAILURE:\n    case RPC_PROGNOTREGISTERED:\n    case RPC_FAILED:\n      res = __asprintf (&str, \"%s: %s\\n\", msg, errstr);\n      break;\n\n    case RPC_CANTSEND:\n    case RPC_CANTRECV:\n      res = __asprintf (&str, \"%s: %s; errno = %s\\n\",\n\t\t\tmsg, errstr, __strerror_r (e.re_errno,\n\t\t\t\t\t\t   chrbuf, sizeof chrbuf));\n      break;\n\n    case RPC_VERSMISMATCH:\n      res = __asprintf (&str,\n\t\t\t_(\"%s: %s; low version = %lu, high version = %lu\"),\n\t\t\tmsg, errstr, e.re_vers.low, e.re_vers.high);\n      break;\n\n    case RPC_AUTHERROR:\n      tmpstr = auth_errmsg (e.re_why);\n      if (tmpstr != NULL)\n\tres = __asprintf (&str, _(\"%s: %s; why = %s\\n\"), msg, errstr, tmpstr);\n      else\n\tres = __asprintf (&str, _(\"\\\n%s: %s; why = (unknown authentication error - %d)\\n\"),\n\t\t\t  msg, errstr, (int) e.re_why);\n      break;\n\n    case RPC_PROGVERSMISMATCH:\n      res = __asprintf (&str,\n\t\t\t_(\"%s: %s; low version = %lu, high version = %lu\"),\n\t\t\tmsg, errstr, e.re_vers.low, e.re_vers.high);\n      break;\n\n    default:\t\t\t/* unknown */\n      res = __asprintf (&str, \"%s: %s; s1 = %lu, s2 = %lu\",\n\t\t\tmsg, errstr, e.re_lb.s1, e.re_lb.s2);\n      break;\n    }\n\n  if (res < 0)\n    return NULL;\n\n  char *oldbuf = buf;\n  buf = str;\n  free (oldbuf);\n\n  return str;\n}",
    "clnt_sperrno(enum clnt_stat)": "char *\nclnt_sperrno (enum clnt_stat stat)\n{\n  size_t i;\n\n  for (i = 0; i < sizeof (rpc_errlist) / sizeof (struct rpc_errtab); i++)\n    {\n      if (rpc_errlist[i].status == stat)\n\t{\n\t  return _(rpc_errstr + rpc_errlist[i].message_off);\n\t}\n    }\n  return _(\"RPC: (unknown error code)\");\n}",
    "clntraw_create(u_long, u_long)": "CLIENT *\nclntraw_create (u_long prog, u_long vers)\n{\n  struct clntraw_private_s *clp = clntraw_private;\n  struct rpc_msg call_msg;\n  XDR *xdrs;\n  CLIENT *client;\n\n  if (clp == 0)\n    {\n      clp = (struct clntraw_private_s *) calloc (1, sizeof (*clp));\n      if (clp == 0)\n\treturn (0);\n      clntraw_private = clp;\n    }\n  xdrs = &clp->xdr_stream;\n  client = &clp->client_object;\n  /*\n   * pre-serialize the static part of the call msg and stash it away\n   */\n  call_msg.rm_direction = CALL;\n  call_msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;\n  call_msg.rm_call.cb_prog = prog;\n  call_msg.rm_call.cb_vers = vers;\n  xdrmem_create (xdrs, clp->mashl_callmsg.msg, MCALL_MSG_SIZE, XDR_ENCODE);\n  if (!xdr_callhdr (xdrs, &call_msg))\n    {\n      perror (_ (\"clnt_raw.c: fatal header serialization error\"));\n    }\n  clp->mcnt = XDR_GETPOS (xdrs);\n  XDR_DESTROY (xdrs);\n\n  /*\n   * Set xdrmem for client/server shared buffer\n   */\n  xdrmem_create (xdrs, clp->_raw_buf, UDPMSGSIZE, XDR_FREE);\n\n  /*\n   * create client handle\n   */\n  client->cl_ops = (struct clnt_ops *) &client_ops;\n  client->cl_auth = authnone_create ();\n  return client;\n}",
    "callrpc(const char *, u_long, u_long, u_long, int, const char *, int, char *)": "int\ncallrpc (const char *host, u_long prognum, u_long versnum, u_long procnum,\n\t xdrproc_t inproc, const char *in, xdrproc_t outproc, char *out)\n{\n  struct callrpc_private_s *crp = callrpc_private;\n  struct sockaddr_in server_addr;\n  enum clnt_stat clnt_stat;\n  struct timeval timeout, tottimeout;\n\n  if (crp == 0)\n    {\n      crp = (struct callrpc_private_s *) calloc (1, sizeof (*crp));\n      if (crp == 0)\n\treturn 0;\n      callrpc_private = crp;\n    }\n  if (crp->oldhost == NULL)\n    {\n      crp->oldhost = malloc (256);\n      crp->oldhost[0] = 0;\n      crp->socket = RPC_ANYSOCK;\n    }\n  if (crp->valid && crp->oldprognum == prognum && crp->oldversnum == versnum\n      && strcmp (crp->oldhost, host) == 0)\n    {\n      /* reuse old client */\n    }\n  else\n    {\n      crp->valid = 0;\n      if (crp->socket != RPC_ANYSOCK)\n\t{\n\t  (void) __close (crp->socket);\n\t  crp->socket = RPC_ANYSOCK;\n\t}\n      if (crp->client)\n\t{\n\t  clnt_destroy (crp->client);\n\t  crp->client = NULL;\n\t}\n\n      if (__libc_rpc_gethostbyname (host, &server_addr) != 0)\n\treturn (int) get_rpc_createerr().cf_stat;\n\n      timeout.tv_usec = 0;\n      timeout.tv_sec = 5;\n      if ((crp->client = clntudp_create (&server_addr, (u_long) prognum,\n\t\t\t  (u_long) versnum, timeout, &crp->socket)) == NULL)\n\treturn (int) get_rpc_createerr().cf_stat;\n      crp->valid = 1;\n      crp->oldprognum = prognum;\n      crp->oldversnum = versnum;\n      (void) strncpy (crp->oldhost, host, 255);\n      crp->oldhost[255] = '\\0';\n    }\n  tottimeout.tv_sec = 25;\n  tottimeout.tv_usec = 0;\n  clnt_stat = clnt_call (crp->client, procnum, inproc, (char *) in,\n\t\t\t outproc, out, tottimeout);\n  /*\n   * if call failed, empty cache\n   */\n  if (clnt_stat != RPC_SUCCESS)\n    crp->valid = 0;\n  return (int) clnt_stat;\n}",
    "clnttcp_create(struct sockaddr_in *, u_long, u_long, int *, u_int, u_int)": "CLIENT *\nclnttcp_create (struct sockaddr_in *raddr, u_long prog, u_long vers,\n\t\tint *sockp, u_int sendsz, u_int recvsz)\n{\n  CLIENT *h;\n  struct ct_data *ct;\n  struct rpc_msg call_msg;\n\n  h = (CLIENT *) mem_alloc (sizeof (*h));\n  ct = (struct ct_data *) mem_alloc (sizeof (*ct));\n  if (h == NULL || ct == NULL)\n    {\n      struct rpc_createerr *ce = &get_rpc_createerr ();\n      (void) __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n      ce->cf_stat = RPC_SYSTEMERROR;\n      ce->cf_error.re_errno = ENOMEM;\n      goto fooy;\n    }\n\n  /*\n   * If no port number given ask the pmap for one\n   */\n  if (raddr->sin_port == 0)\n    {\n      u_short port;\n      if ((port = pmap_getport (raddr, prog, vers, IPPROTO_TCP)) == 0)\n\t{\n\t  mem_free ((caddr_t) ct, sizeof (struct ct_data));\n\t  mem_free ((caddr_t) h, sizeof (CLIENT));\n\t  return ((CLIENT *) NULL);\n\t}\n      raddr->sin_port = htons (port);\n    }\n\n  /*\n   * If no socket given, open one\n   */\n  if (*sockp < 0)\n    {\n      *sockp = __socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);\n      (void) bindresvport (*sockp, (struct sockaddr_in *) 0);\n      if ((*sockp < 0)\n\t  || (__connect (*sockp, (struct sockaddr *) raddr,\n\t\t\t sizeof (*raddr)) < 0))\n\t{\n\t  struct rpc_createerr *ce = &get_rpc_createerr ();\n\t  ce->cf_stat = RPC_SYSTEMERROR;\n\t  ce->cf_error.re_errno = errno;\n\t  if (*sockp >= 0)\n\t    (void) __close (*sockp);\n\t  goto fooy;\n\t}\n      ct->ct_closeit = TRUE;\n    }\n  else\n    {\n      ct->ct_closeit = FALSE;\n    }\n\n  /*\n   * Set up private data struct\n   */\n  ct->ct_sock = *sockp;\n  ct->ct_wait.tv_usec = 0;\n  ct->ct_waitset = FALSE;\n  ct->ct_addr = *raddr;\n\n  /*\n   * Initialize call message\n   */\n  call_msg.rm_xid = _create_xid ();\n  call_msg.rm_direction = CALL;\n  call_msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;\n  call_msg.rm_call.cb_prog = prog;\n  call_msg.rm_call.cb_vers = vers;\n\n  /*\n   * pre-serialize the static part of the call msg and stash it away\n   */\n  xdrmem_create (&(ct->ct_xdrs), ct->ct_mcall, MCALL_MSG_SIZE, XDR_ENCODE);\n  if (!xdr_callhdr (&(ct->ct_xdrs), &call_msg))\n    {\n      if (ct->ct_closeit)\n\t{\n\t  (void) __close (*sockp);\n\t}\n      goto fooy;\n    }\n  ct->ct_mpos = XDR_GETPOS (&(ct->ct_xdrs));\n  XDR_DESTROY (&(ct->ct_xdrs));\n\n  /*\n   * Create a client handle which uses xdrrec for serialization\n   * and authnone for authentication.\n   */\n  xdrrec_create (&(ct->ct_xdrs), sendsz, recvsz,\n\t\t (caddr_t) ct, readtcp, writetcp);\n  h->cl_ops = (struct clnt_ops *) &tcp_ops;\n  h->cl_private = (caddr_t) ct;\n  h->cl_auth = authnone_create ();\n  return h;\n\nfooy:\n  /*\n   * Something goofed, free stuff and barf\n   */\n  mem_free ((caddr_t) ct, sizeof (struct ct_data));\n  mem_free ((caddr_t) h, sizeof (CLIENT));\n  return ((CLIENT *) NULL);\n}",
    "__libc_clntudp_bufcreate(struct sockaddr_in *, u_long, u_long, struct timeval, int *, u_int, u_int, int)": "CLIENT *\n__libc_clntudp_bufcreate (struct sockaddr_in *raddr, u_long program,\n\t\t\t  u_long version, struct timeval wait, int *sockp,\n\t\t\t  u_int sendsz, u_int recvsz, int flags)\n{\n  CLIENT *cl;\n  struct cu_data *cu = NULL;\n  struct rpc_msg call_msg;\n\n  cl = (CLIENT *) mem_alloc (sizeof (CLIENT));\n  sendsz = ((sendsz + 3) / 4) * 4;\n  recvsz = ((recvsz + 3) / 4) * 4;\n  cu = (struct cu_data *) mem_alloc (sizeof (*cu) + sendsz + recvsz);\n  if (cl == NULL || cu == NULL)\n    {\n      struct rpc_createerr *ce = &get_rpc_createerr ();\n      (void) __fxprintf (NULL, \"%s: %s\",\n\t\t\t \"clntudp_create\", _(\"out of memory\\n\"));\n      ce->cf_stat = RPC_SYSTEMERROR;\n      ce->cf_error.re_errno = ENOMEM;\n      goto fooy;\n    }\n  cu->cu_outbuf = &cu->cu_inbuf[recvsz];\n\n  if (raddr->sin_port == 0)\n    {\n      u_short port;\n      if ((port =\n\t   pmap_getport (raddr, program, version, IPPROTO_UDP)) == 0)\n\t{\n\t  goto fooy;\n\t}\n      raddr->sin_port = htons (port);\n    }\n  cl->cl_ops = (struct clnt_ops *) &udp_ops;\n  cl->cl_private = (caddr_t) cu;\n  cu->cu_raddr = *raddr;\n  cu->cu_rlen = sizeof (cu->cu_raddr);\n  cu->cu_wait = wait;\n  cu->cu_total.tv_sec = -1;\n  cu->cu_total.tv_usec = -1;\n  cu->cu_sendsz = sendsz;\n  cu->cu_recvsz = recvsz;\n  call_msg.rm_xid = _create_xid ();\n  call_msg.rm_direction = CALL;\n  call_msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;\n  call_msg.rm_call.cb_prog = program;\n  call_msg.rm_call.cb_vers = version;\n  xdrmem_create (&(cu->cu_outxdrs), cu->cu_outbuf, sendsz, XDR_ENCODE);\n  if (!xdr_callhdr (&(cu->cu_outxdrs), &call_msg))\n    {\n      goto fooy;\n    }\n  cu->cu_xdrpos = XDR_GETPOS (&(cu->cu_outxdrs));\n  if (*sockp < 0)\n    {\n      *sockp = __socket (AF_INET, SOCK_DGRAM|SOCK_NONBLOCK|flags, IPPROTO_UDP);\n      if (__glibc_unlikely (*sockp < 0))\n\t{\n\t  struct rpc_createerr *ce = &get_rpc_createerr ();\n\t  ce->cf_stat = RPC_SYSTEMERROR;\n\t  ce->cf_error.re_errno = errno;\n\t  goto fooy;\n\t}\n      /* attempt to bind to prov port */\n      (void) bindresvport (*sockp, (struct sockaddr_in *) 0);\n#ifdef IP_RECVERR\n      {\n\tint on = 1;\n\t__setsockopt (*sockp, SOL_IP, IP_RECVERR, &on, sizeof(on));\n      }\n#endif\n      cu->cu_closeit = TRUE;\n    }\n  else\n    {\n      cu->cu_closeit = FALSE;\n    }\n  cu->cu_sock = *sockp;\n  cl->cl_auth = authnone_create ();\n  return cl;\nfooy:\n  if (cu)\n    mem_free ((caddr_t) cu, sizeof (*cu) + sendsz + recvsz);\n  if (cl)\n    mem_free ((caddr_t) cl, sizeof (CLIENT));\n  return (CLIENT *) NULL;\n}",
    "clntunix_create(struct sockaddr_un *, u_long, u_long, int *, u_int, u_int)": "CLIENT *\nclntunix_create (struct sockaddr_un *raddr, u_long prog, u_long vers,\n\t\t int *sockp, u_int sendsz, u_int recvsz)\n{\n  CLIENT *h;\n  struct ct_data *ct = (struct ct_data *) mem_alloc (sizeof (*ct));\n  struct rpc_msg call_msg;\n  int len;\n\n  h = (CLIENT *) mem_alloc (sizeof (*h));\n  if (h == NULL || ct == NULL)\n    {\n      struct rpc_createerr *ce = &get_rpc_createerr ();\n      (void) __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n      ce->cf_stat = RPC_SYSTEMERROR;\n      ce->cf_error.re_errno = ENOMEM;\n      goto fooy;\n    }\n\n  /*\n   * If no socket given, open one\n   */\n  if (*sockp < 0)\n    {\n      *sockp = __socket (AF_UNIX, SOCK_STREAM, 0);\n      len = strlen (raddr->sun_path) + sizeof (raddr->sun_family) + 1;\n      if (*sockp < 0\n\t  || __connect (*sockp, (struct sockaddr *) raddr, len) < 0)\n\t{\n\t  struct rpc_createerr *ce = &get_rpc_createerr ();\n\t  ce->cf_stat = RPC_SYSTEMERROR;\n\t  ce->cf_error.re_errno = errno;\n\t  if (*sockp != -1)\n\t    __close (*sockp);\n\t  goto fooy;\n\t}\n      ct->ct_closeit = TRUE;\n    }\n  else\n    {\n      ct->ct_closeit = FALSE;\n    }\n\n  /*\n   * Set up private data struct\n   */\n  ct->ct_sock = *sockp;\n  ct->ct_wait.tv_usec = 0;\n  ct->ct_waitset = FALSE;\n  ct->ct_addr = *raddr;\n\n  /*\n   * Initialize call message\n   */\n  call_msg.rm_xid = _create_xid ();\n  call_msg.rm_direction = CALL;\n  call_msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;\n  call_msg.rm_call.cb_prog = prog;\n  call_msg.rm_call.cb_vers = vers;\n\n  /*\n   * pre-serialize the static part of the call msg and stash it away\n   */\n  xdrmem_create (&(ct->ct_xdrs), ct->ct_mcall, MCALL_MSG_SIZE, XDR_ENCODE);\n  if (!xdr_callhdr (&(ct->ct_xdrs), &call_msg))\n    {\n      if (ct->ct_closeit)\n\t__close (*sockp);\n      goto fooy;\n    }\n  ct->ct_mpos = XDR_GETPOS (&(ct->ct_xdrs));\n  XDR_DESTROY (&(ct->ct_xdrs));\n\n  /*\n   * Create a client handle which uses xdrrec for serialization\n   * and authnone for authentication.\n   */\n  xdrrec_create (&(ct->ct_xdrs), sendsz, recvsz,\n\t\t (caddr_t) ct, readunix, writeunix);\n  h->cl_ops = (struct clnt_ops *) &unix_ops;\n  h->cl_private = (caddr_t) ct;\n  h->cl_auth = authnone_create ();\n  return h;\n\nfooy:\n  /*\n   * Something goofed, free stuff and barf\n   */\n  mem_free ((caddr_t) ct, sizeof (struct ct_data));\n  mem_free ((caddr_t) h, sizeof (CLIENT));\n  return (CLIENT *) NULL;\n}",
    "cbc_crypt(char *, char *, unsigned int, unsigned int, char *)": "int\ncbc_crypt (char *key, char *buf, unsigned int len, unsigned int mode,\n\t   char *ivec)\n{\n  int err;\n  struct desparams dp;\n\n  dp.des_mode = CBC;\n  COPY8 (ivec, dp.des_ivec);\n  err = common_crypt (key, buf, len, mode, &dp);\n  COPY8 (dp.des_ivec, ivec);\n  return err;\n}",
    "des_setparity(char *)": "void\ndes_setparity (char *p)\n{\n  int i;\n\n  for (i = 0; i < 8; i++)\n    {\n      *p = partab[*p & 0x7f];\n      p++;\n    }\n}",
    "get_myaddress(struct sockaddr_in *)": "void\nget_myaddress (struct sockaddr_in *addr)\n{\n  struct ifaddrs *ifa;\n\n  if (getifaddrs (&ifa) != 0)\n    {\n      perror (\"get_myaddress: getifaddrs\");\n      exit (1);\n    }\n\n  int loopback = 0;\n  struct ifaddrs *run;\n\n again:\n  run = ifa;\n  while (run != NULL)\n    {\n      if ((run->ifa_flags & IFF_UP)\n\t  && run->ifa_addr != NULL\n\t  && run->ifa_addr->sa_family == AF_INET\n\t  && (!(run->ifa_flags & IFF_LOOPBACK)\n\t      || (loopback == 1 && (run->ifa_flags & IFF_LOOPBACK))))\n\t{\n\t  *addr = *((struct sockaddr_in *) run->ifa_addr);\n\t  addr->sin_port = htons (PMAPPORT);\n\t  goto out;\n\t}\n\n      run = run->ifa_next;\n    }\n\n  if (loopback == 0)\n    {\n      loopback = 1;\n      goto again;\n    }\n out:\n  freeifaddrs (ifa);\n\n  /* The function is horribly specified.  It does not return any error\n     if no interface is up.  Probably this won't happen (at least\n     loopback is there) but still...  */\n}",
    "getrpcport(const char *, u_long, u_long, u_int)": "int\ngetrpcport (const char *host, u_long prognum, u_long versnum, u_int proto)\n{\n  struct sockaddr_in addr;\n\n  if (__libc_rpc_gethostbyname (host, &addr) != 0)\n    return 0;\n  return pmap_getport (&addr, prognum, versnum, proto);\n}",
    "key_setsecret(char *)": "int\nkey_setsecret (char *secretkey)\n{\n  keystatus status;\n\n  if (!key_call ((u_long) KEY_SET, (xdrproc_t) xdr_keybuf, secretkey,\n\t\t (xdrproc_t) xdr_keystatus, (char *) &status))\n    return -1;\n  if (status != KEY_SUCCESS)\n    {\n      debug (\"set status is nonzero\");\n      return -1;\n    }\n  return 0;\n}",
    "xdr_keystatus(int *, keystatus *)": "bool_t\nxdr_keystatus (XDR * xdrs, keystatus * objp)\n{\n  if (!xdr_enum (xdrs, (enum_t *) objp))\n    return FALSE;\n\n  return TRUE;\n}",
    "user2netname(char, const uid_t, const char *)": "int\nuser2netname (char netname[MAXNETNAMELEN + 1], const uid_t uid,\n\t      const char *domain)\n{\n  char dfltdom[MAXNETNAMELEN + 1];\n  size_t i;\n\n  if (domain == NULL)\n    {\n      if (getdomainname (dfltdom, sizeof (dfltdom)) < 0)\n\treturn 0;\n    }\n  else\n    {\n      strncpy (dfltdom, domain, MAXNETNAMELEN);\n      dfltdom[MAXNETNAMELEN] = '\\0';\n    }\n\n  if ((strlen (dfltdom) + OPSYS_LEN + 3 + MAXIPRINT) > (size_t) MAXNETNAMELEN)\n    return 0;\n\n  /* GCC with -Os or -O1 warns that sprint might overflow while handling\n     dfltdom, however the above test does check if an overflow would\n     happen.  */\n#if __GNUC_PREREQ (8, 0)\n  DIAG_PUSH_NEEDS_COMMENT;\n  DIAG_IGNORE_NEEDS_COMMENT (8, \"-Wformat-overflow\");\n#endif\n  sprintf (netname, \"%s.%d@%s\", OPSYS, uid, dfltdom);\n#if __GNUC_PREREQ (8, 0)\n  DIAG_POP_NEEDS_COMMENT;\n#endif\n  i = strlen (netname);\n  if (netname[i - 1] == '.')\n    netname[i - 1] = '\\0';\n  return 1;\n}",
    "pmap_getmaps(struct sockaddr_in *)": "struct pmaplist *\npmap_getmaps (struct sockaddr_in *address)\n{\n  struct pmaplist *head = (struct pmaplist *) NULL;\n  struct timeval minutetimeout;\n  CLIENT *client;\n  bool closeit = false;\n\n  minutetimeout.tv_sec = 60;\n  minutetimeout.tv_usec = 0;\n  address->sin_port = htons (PMAPPORT);\n\n  /* Don't need a reserved port to get ports from the portmapper.  */\n  int socket = __get_socket (address);\n  if (socket != -1)\n    closeit = true;\n\n  client = clnttcp_create (address, PMAPPROG, PMAPVERS, &socket, 50, 500);\n  if (client != (CLIENT *) NULL)\n    {\n      if (CLNT_CALL (client, PMAPPROC_DUMP, (xdrproc_t)xdr_void, NULL,\n\t\t     (xdrproc_t)xdr_pmaplist, (caddr_t)&head,\n\t\t     minutetimeout) != RPC_SUCCESS)\n\t{\n\t  clnt_perror (client, _(\"pmap_getmaps.c: rpc problem\"));\n\t}\n      CLNT_DESTROY (client);\n    }\n  /* We only need to close the socket here if we opened  it.  */\n  if (closeit)\n    __close_nocancel (socket);\n  address->sin_port = 0;\n  return head;\n}",
    "__libc_rpc_getport(struct sockaddr_in *, u_long, u_long, u_int, time_t, time_t)": "u_short\n__libc_rpc_getport (struct sockaddr_in *address, u_long program,\n\t\t    u_long version, u_int protocol, time_t timeout_sec,\n\t\t    time_t tottimeout_sec)\n{\n  const struct timeval timeout = {timeout_sec, 0};\n  const struct timeval tottimeout = {tottimeout_sec, 0};\n\n  u_short port = 0;\n  int socket = -1;\n  CLIENT *client;\n  struct pmap parms;\n  bool closeit = false;\n\n  address->sin_port = htons (PMAPPORT);\n  if (protocol == IPPROTO_TCP)\n    {\n      /* Don't need a reserved port to get ports from the portmapper.  */\n      socket = __get_socket(address);\n      if (socket != -1)\n\tcloseit = true;\n      client = clnttcp_create (address, PMAPPROG, PMAPVERS, &socket,\n\t\t\t       RPCSMALLMSGSIZE, RPCSMALLMSGSIZE);\n    }\n  else\n    client = clntudp_bufcreate (address, PMAPPROG, PMAPVERS, timeout,\n\t\t\t\t&socket, RPCSMALLMSGSIZE, RPCSMALLMSGSIZE);\n  if (client != (CLIENT *) NULL)\n    {\n      struct rpc_createerr *ce = &get_rpc_createerr ();\n      parms.pm_prog = program;\n      parms.pm_vers = version;\n      parms.pm_prot = protocol;\n      parms.pm_port = 0;\t/* not needed or used */\n      if (CLNT_CALL (client, PMAPPROC_GETPORT, (xdrproc_t)xdr_pmap,\n\t\t     (caddr_t)&parms, (xdrproc_t)xdr_u_short,\n\t\t     (caddr_t)&port, tottimeout) != RPC_SUCCESS)\n\t{\n\t  ce->cf_stat = RPC_PMAPFAILURE;\n\t  clnt_geterr (client, &ce->cf_error);\n\t}\n      else if (port == 0)\n\t{\n\t  ce->cf_stat = RPC_PROGNOTREGISTERED;\n\t}\n      CLNT_DESTROY (client);\n    }\n  /* We only need to close the socket here if we opened  it.  */\n  if (closeit)\n    (void) __close (socket);\n  address->sin_port = 0;\n  return port;\n}",
    "pmap_set(u_long, u_long, int, u_short)": "bool_t\npmap_set (u_long program, u_long version, int protocol, u_short port)\n{\n  struct sockaddr_in myaddress;\n  int socket = -1;\n  CLIENT *client;\n  struct pmap parms;\n  bool_t rslt;\n\n  if (!__get_myaddress (&myaddress))\n    return FALSE;\n  client = clntudp_bufcreate (&myaddress, PMAPPROG, PMAPVERS, timeout, &socket,\n\t\t\t      RPCSMALLMSGSIZE, RPCSMALLMSGSIZE);\n  if (client == (CLIENT *) NULL)\n    return (FALSE);\n  parms.pm_prog = program;\n  parms.pm_vers = version;\n  parms.pm_prot = protocol;\n  parms.pm_port = port;\n  if (CLNT_CALL (client, PMAPPROC_SET, (xdrproc_t)xdr_pmap,\n\t\t (caddr_t)&parms, (xdrproc_t)xdr_bool, (caddr_t)&rslt,\n\t\t tottimeout) != RPC_SUCCESS)\n    {\n      clnt_perror (client, _(\"Cannot register service\"));\n      rslt = FALSE;\n    }\n  CLNT_DESTROY (client);\n  /* (void)close(socket); CLNT_DESTROY closes it */\n  return rslt;\n}",
    "xdr_pmap(XDR *, struct pmap *)": "bool_t\nxdr_pmap (XDR *xdrs, struct pmap *regs)\n{\n\n  if (xdr_u_long (xdrs, &regs->pm_prog) &&\n      xdr_u_long (xdrs, &regs->pm_vers) &&\n      xdr_u_long (xdrs, &regs->pm_prot))\n    return xdr_u_long (xdrs, &regs->pm_port);\n  return FALSE;\n}",
    "xdr_pmaplist(XDR *, struct pmaplist **)": "bool_t\nxdr_pmaplist (XDR *xdrs, struct pmaplist **rp)\n{\n  /*\n   * more_elements is pre-computed in case the direction is\n   * XDR_ENCODE or XDR_FREE.  more_elements is overwritten by\n   * xdr_bool when the direction is XDR_DECODE.\n   */\n  bool_t more_elements;\n  int freeing = (xdrs->x_op == XDR_FREE);\n  struct pmaplist *next = NULL;\n\n  while (TRUE)\n    {\n      more_elements = (bool_t) (*rp != NULL);\n      if (!xdr_bool (xdrs, &more_elements))\n\treturn FALSE;\n      if (!more_elements)\n\treturn TRUE;\t\t/* we are done */\n      /*\n       * the unfortunate side effect of non-recursion is that in\n       * the case of freeing we must remember the next object\n       * before we free the current object ...\n       */\n      if (freeing)\n\tnext = (*rp)->pml_next;\n      if (!xdr_reference (xdrs, (caddr_t *) rp,\n\t\t\t  (u_int) sizeof (struct pmaplist),\n\t\t\t  (xdrproc_t) xdr_pmap))\n\t  return FALSE;\n      rp = freeing ? &next : &((*rp)->pml_next);\n    }\n}",
    "pmap_rmtcall(struct sockaddr_in *, u_long, u_long, u_long, int, caddr_t, int, caddr_t, struct timeval, u_long *)": "enum clnt_stat\npmap_rmtcall (struct sockaddr_in *addr, u_long prog, u_long vers, u_long proc,\n\t      xdrproc_t xdrargs, caddr_t argsp, xdrproc_t xdrres, caddr_t resp,\n\t      struct timeval tout, u_long *port_ptr)\n{\n  int socket = -1;\n  CLIENT *client;\n  struct rmtcallargs a;\n  struct rmtcallres r;\n  enum clnt_stat stat;\n\n  addr->sin_port = htons (PMAPPORT);\n  client = clntudp_create (addr, PMAPPROG, PMAPVERS, timeout, &socket);\n  if (client != (CLIENT *) NULL)\n    {\n      a.prog = prog;\n      a.vers = vers;\n      a.proc = proc;\n      a.args_ptr = argsp;\n      a.xdr_args = xdrargs;\n      r.port_ptr = port_ptr;\n      r.results_ptr = resp;\n      r.xdr_results = xdrres;\n      stat = CLNT_CALL (client, PMAPPROC_CALLIT,\n\t\t\t(xdrproc_t)xdr_rmtcall_args,\n\t\t\t(caddr_t)&a, (xdrproc_t)xdr_rmtcallres,\n\t\t\t(caddr_t)&r, tout);\n      CLNT_DESTROY (client);\n    }\n  else\n    {\n      stat = RPC_FAILED;\n    }\n  /* (void)__close(socket); CLNT_DESTROY already closed it */\n  addr->sin_port = 0;\n  return stat;\n}",
    "clnt_broadcast(u_long, u_long, u_long, int, caddr_t, int, caddr_t, int)": "enum clnt_stat\nclnt_broadcast (/* program number */\n\t\tu_long prog,\n\t\t/* version number */\n\t\tu_long vers,\n\t\t/* procedure number */\n\t\tu_long proc,\n\t\t/* xdr routine for args */\n\t\txdrproc_t xargs,\n\t\t/* pointer to args */\n\t\tcaddr_t argsp,\n\t\t/* xdr routine for results */\n\t\txdrproc_t xresults,\n\t\t/* pointer to results */\n\t\tcaddr_t resultsp,\n\t\t/* call with each result obtained */\n\t\tresultproc_t eachresult)\n{\n  enum clnt_stat stat = RPC_FAILED;\n  AUTH *unix_auth = authunix_create_default ();\n  XDR xdr_stream;\n  XDR *xdrs = &xdr_stream;\n  struct timeval t;\n  int outlen, inlen, nets;\n  socklen_t fromlen;\n  int sock;\n  int on = 1;\n  struct pollfd fd;\n  int milliseconds;\n  int i;\n  bool_t done = FALSE;\n  u_long xid;\n  u_long port;\n  struct in_addr addrs[20];\n  struct sockaddr_in baddr, raddr;\t/* broadcast and response addresses */\n  struct rmtcallargs a;\n  struct rmtcallres r;\n  struct rpc_msg msg;\n  char outbuf[MAX_BROADCAST_SIZE], inbuf[UDPMSGSIZE];\n\n  /*\n   * initialization: create a socket, a broadcast address, and\n   * preserialize the arguments into a send buffer.\n   */\n  if ((sock = __socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)\n    {\n      perror (_(\"Cannot create socket for broadcast rpc\"));\n      stat = RPC_CANTSEND;\n      goto done_broad;\n    }\n#ifdef SO_BROADCAST\n  if (__setsockopt (sock, SOL_SOCKET, SO_BROADCAST, &on, sizeof (on)) < 0)\n    {\n      perror (_(\"Cannot set socket option SO_BROADCAST\"));\n      stat = RPC_CANTSEND;\n      goto done_broad;\n    }\n#endif /* def SO_BROADCAST */\n  fd.fd = sock;\n  fd.events = POLLIN;\n  nets = getbroadcastnets (addrs, sizeof (addrs) / sizeof (addrs[0]));\n  memset ((char *) &baddr, 0, sizeof (baddr));\n  baddr.sin_family = AF_INET;\n  baddr.sin_port = htons (PMAPPORT);\n  baddr.sin_addr.s_addr = htonl (INADDR_ANY);\n/*      baddr.sin_addr.S_un.S_addr = htonl(INADDR_ANY); */\n  msg.rm_xid = xid = _create_xid ();\n  t.tv_usec = 0;\n  msg.rm_direction = CALL;\n  msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;\n  msg.rm_call.cb_prog = PMAPPROG;\n  msg.rm_call.cb_vers = PMAPVERS;\n  msg.rm_call.cb_proc = PMAPPROC_CALLIT;\n  msg.rm_call.cb_cred = unix_auth->ah_cred;\n  msg.rm_call.cb_verf = unix_auth->ah_verf;\n  a.prog = prog;\n  a.vers = vers;\n  a.proc = proc;\n  a.xdr_args = xargs;\n  a.args_ptr = argsp;\n  r.port_ptr = &port;\n  r.xdr_results = xresults;\n  r.results_ptr = resultsp;\n  xdrmem_create (xdrs, outbuf, MAX_BROADCAST_SIZE, XDR_ENCODE);\n  if ((!xdr_callmsg (xdrs, &msg))\n      || (!xdr_rmtcall_args (xdrs, &a)))\n    {\n      stat = RPC_CANTENCODEARGS;\n      goto done_broad;\n    }\n  outlen = (int) xdr_getpos (xdrs);\n  xdr_destroy (xdrs);\n  /*\n   * Basic loop: broadcast a packet and wait a while for response(s).\n   * The response timeout grows larger per iteration.\n   */\n  for (t.tv_sec = 4; t.tv_sec <= 14; t.tv_sec += 2)\n    {\n      for (i = 0; i < nets; i++)\n\t{\n\t  baddr.sin_addr = addrs[i];\n\t  if (__sendto (sock, outbuf, outlen, 0,\n\t\t\t(struct sockaddr *) &baddr,\n\t\t\tsizeof (struct sockaddr)) != outlen)\n\t    {\n\t      perror (_(\"Cannot send broadcast packet\"));\n\t      stat = RPC_CANTSEND;\n\t      goto done_broad;\n\t    }\n\t}\n      if (eachresult == NULL)\n\t{\n\t  stat = RPC_SUCCESS;\n\t  goto done_broad;\n\t}\n    recv_again:\n      msg.acpted_rply.ar_verf = _null_auth;\n      msg.acpted_rply.ar_results.where = (caddr_t) & r;\n      msg.acpted_rply.ar_results.proc = (xdrproc_t) xdr_rmtcallres;\n      milliseconds = t.tv_sec * 1000 + t.tv_usec / 1000;\n      switch (__poll(&fd, 1, milliseconds))\n\t{\n\n\tcase 0:\t\t/* timed out */\n\t  stat = RPC_TIMEDOUT;\n\t  continue;\n\n\tcase -1:\t\t/* some kind of error */\n\t  if (errno == EINTR)\n\t    goto recv_again;\n\t  perror (_(\"Broadcast poll problem\"));\n\t  stat = RPC_CANTRECV;\n\t  goto done_broad;\n\n\t}\t\t\t/* end of poll results switch */\n    try_again:\n      fromlen = sizeof (struct sockaddr);\n      inlen = __recvfrom (sock, inbuf, UDPMSGSIZE, 0,\n\t\t\t  (struct sockaddr *) &raddr, &fromlen);\n      if (inlen < 0)\n\t{\n\t  if (errno == EINTR)\n\t    goto try_again;\n\t  perror (_(\"Cannot receive reply to broadcast\"));\n\t  stat = RPC_CANTRECV;\n\t  goto done_broad;\n\t}\n      if ((size_t) inlen < sizeof (u_long))\n\tgoto recv_again;\n      /*\n       * see if reply transaction id matches sent id.\n       * If so, decode the results.\n       */\n      xdrmem_create (xdrs, inbuf, (u_int) inlen, XDR_DECODE);\n      if (xdr_replymsg (xdrs, &msg))\n\t{\n\t  if (((uint32_t) msg.rm_xid == (uint32_t) xid) &&\n\t      (msg.rm_reply.rp_stat == MSG_ACCEPTED) &&\n\t      (msg.acpted_rply.ar_stat == SUCCESS))\n\t    {\n\t      raddr.sin_port = htons ((u_short) port);\n\t      done = (*eachresult) (resultsp, &raddr);\n\t    }\n\t  /* otherwise, we just ignore the errors ... */\n\t}\n      else\n\t{\n#ifdef notdef\n\t  /* some kind of deserialization problem ... */\n\t  if ((uint32_t) msg.rm_xid == (uint32_t) xid)\n\t    fprintf (stderr, \"Broadcast deserialization problem\");\n\t  /* otherwise, just random garbage */\n#endif\n\t}\n      xdrs->x_op = XDR_FREE;\n      msg.acpted_rply.ar_results.proc = (xdrproc_t)xdr_void;\n      (void) xdr_replymsg (xdrs, &msg);\n      (void) (*xresults) (xdrs, resultsp);\n      xdr_destroy (xdrs);\n      if (done)\n\t{\n\t  stat = RPC_SUCCESS;\n\t  goto done_broad;\n\t}\n      else\n\t{\n\t  goto recv_again;\n\t}\n    }\ndone_broad:\n  (void) __close (sock);\n  AUTH_DESTROY (unix_auth);\n  return stat;\n}",
    "getpublickey(const char *, char *)": "int\ngetpublickey (const char *name, char *key)\n{\n  nss_action_list nip;\n  union\n  {\n    public_function f;\n    void *ptr;\n  } fct;\n  enum nss_status status = NSS_STATUS_UNAVAIL;\n  int no_more;\n\n  no_more = __nss_publickey_lookup2 (&nip, \"getpublickey\", NULL, &fct.ptr);\n\n  while (! no_more)\n    {\n      status = (*fct.f) (name, key, &errno);\n\n      no_more = __nss_next2 (&nip, \"getpublickey\", NULL, &fct.ptr, status, 0);\n    }\n\n  return status == NSS_STATUS_SUCCESS;\n}",
    "xdr_callmsg(int *, struct rpc_msg *)": "bool_t\nxdr_callmsg (XDR *xdrs, struct rpc_msg *cmsg)\n{\n  int32_t *buf;\n  struct opaque_auth *oa;\n\n  if (xdrs->x_op == XDR_ENCODE)\n    {\n      if (cmsg->rm_call.cb_cred.oa_length > MAX_AUTH_BYTES)\n\t{\n\t  return (FALSE);\n\t}\n      if (cmsg->rm_call.cb_verf.oa_length > MAX_AUTH_BYTES)\n\t{\n\t  return (FALSE);\n\t}\n      buf = XDR_INLINE (xdrs, 8 * BYTES_PER_XDR_UNIT\n\t\t\t+ RNDUP (cmsg->rm_call.cb_cred.oa_length)\n\t\t\t+ 2 * BYTES_PER_XDR_UNIT\n\t\t\t+ RNDUP (cmsg->rm_call.cb_verf.oa_length));\n      if (buf != NULL)\n\t{\n\t  (void) IXDR_PUT_LONG (buf, cmsg->rm_xid);\n\t  (void) IXDR_PUT_ENUM (buf, cmsg->rm_direction);\n\t  if (cmsg->rm_direction != CALL)\n\t    return FALSE;\n\t  (void) IXDR_PUT_LONG (buf, cmsg->rm_call.cb_rpcvers);\n\t  if (cmsg->rm_call.cb_rpcvers != RPC_MSG_VERSION)\n\t    return FALSE;\n\t  (void) IXDR_PUT_LONG (buf, cmsg->rm_call.cb_prog);\n\t  (void) IXDR_PUT_LONG (buf, cmsg->rm_call.cb_vers);\n\t  (void) IXDR_PUT_LONG (buf, cmsg->rm_call.cb_proc);\n\t  oa = &cmsg->rm_call.cb_cred;\n\t  (void) IXDR_PUT_ENUM (buf, oa->oa_flavor);\n\t  (void) IXDR_PUT_INT32 (buf, oa->oa_length);\n\t  if (oa->oa_length)\n\t    {\n\t      memcpy ((caddr_t) buf, oa->oa_base, oa->oa_length);\n\t      buf = (int32_t *) ((char *) buf + RNDUP (oa->oa_length));\n\t    }\n\t  oa = &cmsg->rm_call.cb_verf;\n\t  (void) IXDR_PUT_ENUM (buf, oa->oa_flavor);\n\t  (void) IXDR_PUT_INT32 (buf, oa->oa_length);\n\t  if (oa->oa_length)\n\t    {\n\t      memcpy ((caddr_t) buf, oa->oa_base, oa->oa_length);\n\t      /* no real need....\n\t\t buf = (long *) ((char *) buf + RNDUP(oa->oa_length));\n\t       */\n\t    }\n\t  return TRUE;\n\t}\n    }\n  if (xdrs->x_op == XDR_DECODE)\n    {\n      buf = XDR_INLINE (xdrs, 8 * BYTES_PER_XDR_UNIT);\n      if (buf != NULL)\n\t{\n\t  cmsg->rm_xid = IXDR_GET_LONG (buf);\n\t  cmsg->rm_direction = IXDR_GET_ENUM (buf, enum msg_type);\n\t  if (cmsg->rm_direction != CALL)\n\t    {\n\t      return FALSE;\n\t    }\n\t  cmsg->rm_call.cb_rpcvers = IXDR_GET_LONG (buf);\n\t  if (cmsg->rm_call.cb_rpcvers != RPC_MSG_VERSION)\n\t    {\n\t      return FALSE;\n\t    }\n\t  cmsg->rm_call.cb_prog = IXDR_GET_LONG (buf);\n\t  cmsg->rm_call.cb_vers = IXDR_GET_LONG (buf);\n\t  cmsg->rm_call.cb_proc = IXDR_GET_LONG (buf);\n\t  oa = &cmsg->rm_call.cb_cred;\n\t  oa->oa_flavor = IXDR_GET_ENUM (buf, enum_t);\n\t  oa->oa_length = IXDR_GET_INT32 (buf);\n\t  if (oa->oa_length)\n\t    {\n\t      if (oa->oa_length > MAX_AUTH_BYTES)\n\t\treturn FALSE;\n\t      if (oa->oa_base == NULL)\n\t\t{\n\t\t  oa->oa_base = (caddr_t)\n\t\t    mem_alloc (oa->oa_length);\n\t\t}\n\t      buf = XDR_INLINE (xdrs, RNDUP (oa->oa_length));\n\t      if (buf == NULL)\n\t\t{\n\t\t  if (xdr_opaque (xdrs, oa->oa_base,\n\t\t\t\t  oa->oa_length) == FALSE)\n\t\t    return FALSE;\n\t\t}\n\t      else\n\t\t{\n\t\t  memcpy (oa->oa_base, (caddr_t) buf, oa->oa_length);\n\t\t  /* no real need....\n\t\t     buf = (long *) ((char *) buf\n\t\t     + RNDUP(oa->oa_length));\n\t\t   */\n\t\t}\n\t    }\n\t  oa = &cmsg->rm_call.cb_verf;\n\t  buf = XDR_INLINE (xdrs, 2 * BYTES_PER_XDR_UNIT);\n\t  if (buf == NULL)\n\t    {\n\t      if (xdr_enum (xdrs, &oa->oa_flavor) == FALSE ||\n\t\t  xdr_u_int (xdrs, &oa->oa_length) == FALSE)\n\t\t{\n\t\t  return FALSE;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      oa->oa_flavor = IXDR_GET_ENUM (buf, enum_t);\n\t      oa->oa_length = IXDR_GET_INT32 (buf);\n\t    }\n\t  if (oa->oa_length)\n\t    {\n\t      if (oa->oa_length > MAX_AUTH_BYTES)\n\t\treturn FALSE;\n\t      if (oa->oa_base == NULL)\n\t\t{\n\t\t  oa->oa_base = (caddr_t)\n\t\t    mem_alloc (oa->oa_length);\n\t\t}\n\t      buf = XDR_INLINE (xdrs, RNDUP (oa->oa_length));\n\t      if (buf == NULL)\n\t\t{\n\t\t  if (xdr_opaque (xdrs, oa->oa_base,\n\t\t\t\t  oa->oa_length) == FALSE)\n\t\t    return FALSE;\n\t\t}\n\t      else\n\t\t{\n\t\t  memcpy (oa->oa_base, (caddr_t) buf, oa->oa_length);\n\t\t  /* no real need...\n\t\t     buf = (long *) ((char *) buf\n\t\t     + RNDUP(oa->oa_length));\n\t\t   */\n\t\t}\n\t    }\n\t  return TRUE;\n\t}\n    }\n  if (\n       xdr_u_long (xdrs, &(cmsg->rm_xid)) &&\n       xdr_enum (xdrs, (enum_t *) & (cmsg->rm_direction)) &&\n       (cmsg->rm_direction == CALL) &&\n       xdr_u_long (xdrs, &(cmsg->rm_call.cb_rpcvers)) &&\n       (cmsg->rm_call.cb_rpcvers == RPC_MSG_VERSION) &&\n       xdr_u_long (xdrs, &(cmsg->rm_call.cb_prog)) &&\n       xdr_u_long (xdrs, &(cmsg->rm_call.cb_vers)) &&\n       xdr_u_long (xdrs, &(cmsg->rm_call.cb_proc)) &&\n       xdr_opaque_auth (xdrs, &(cmsg->rm_call.cb_cred)))\n    return xdr_opaque_auth (xdrs, &(cmsg->rm_call.cb_verf));\n  return FALSE;\n}",
    "_rpc_dtablesize()": "int\n_rpc_dtablesize (void)\n{\n  static int size;\n\n  if (size == 0)\n    size = __getdtablesize ();\n\n  return size;\n}",
    "xdr_opaque_auth(int *, struct opaque_auth *)": "bool_t\nxdr_opaque_auth (XDR *xdrs, struct opaque_auth *ap)\n{\n\n  if (xdr_enum (xdrs, &(ap->oa_flavor)))\n    return xdr_bytes (xdrs, &ap->oa_base,\n\t\t      &ap->oa_length, MAX_AUTH_BYTES);\n  return FALSE;\n}",
    "xdr_replymsg(int *, struct rpc_msg *)": "bool_t\nxdr_replymsg (XDR *xdrs, struct rpc_msg *rmsg)\n{\n  if (xdr_u_long (xdrs, &(rmsg->rm_xid)) &&\n      xdr_enum (xdrs, (enum_t *) & (rmsg->rm_direction)) &&\n      (rmsg->rm_direction == REPLY))\n    return xdr_union (xdrs, (enum_t *) & (rmsg->rm_reply.rp_stat),\n\t\t      (caddr_t) & (rmsg->rm_reply.ru), reply_dscrm,\n\t\t      NULL_xdrproc_t);\n  return FALSE;\n}",
    "__rpc_thread_svc_fdset()": "fd_set *\n__rpc_thread_svc_fdset (void)\n{\n\tstruct rpc_thread_variables *tvp;\n\n\ttvp = __rpc_thread_variables ();\n\tif (tvp == &__libc_tsd_RPC_VARS_mem)\n\t\treturn &svc_fdset;\n\treturn &tvp->svc_fdset_s;\n}",
    "rtime(struct sockaddr_in *, struct rpc_timeval *, struct rpc_timeval *)": "int\nrtime (struct sockaddr_in *addrp, struct rpc_timeval *timep,\n       struct rpc_timeval *timeout)\n{\n  int s;\n  struct pollfd fd;\n  int milliseconds;\n  int res;\n  /* RFC 868 says the time is transmitted as a 32-bit value.  */\n  uint32_t thetime;\n  struct sockaddr_in from;\n  socklen_t fromlen;\n  int type;\n\n  if (timeout == NULL)\n    type = SOCK_STREAM;\n  else\n    type = SOCK_DGRAM;\n\n  s = __socket (AF_INET, type, 0);\n  if (s < 0)\n    return (-1);\n\n  addrp->sin_family = AF_INET;\n  addrp->sin_port = htons (IPPORT_TIMESERVER);\n  if (type == SOCK_DGRAM)\n    {\n      res = __sendto (s, (char *) &thetime, sizeof (thetime), 0,\n\t\t      (struct sockaddr *) addrp, sizeof (*addrp));\n      if (res < 0)\n\t{\n\t  do_close (s);\n\t  return -1;\n\t}\n      milliseconds = (timeout->tv_sec * 1000) + (timeout->tv_usec / 1000);\n      fd.fd = s;\n      fd.events = POLLIN;\n      do\n\tres = __poll (&fd, 1, milliseconds);\n      while (res < 0 && errno == EINTR);\n      if (res <= 0)\n\t{\n\t  if (res == 0)\n\t    __set_errno (ETIMEDOUT);\n\t  do_close (s);\n\t  return (-1);\n\t}\n      fromlen = sizeof (from);\n      res = __recvfrom (s, (char *) &thetime, sizeof (thetime), 0,\n\t\t\t(struct sockaddr *) &from, &fromlen);\n      do_close (s);\n      if (res < 0)\n\treturn -1;\n    }\n  else\n    {\n      if (__connect (s, (struct sockaddr *) addrp, sizeof (*addrp)) < 0)\n\t{\n\t  do_close (s);\n\t  return -1;\n\t}\n      res = __read (s, (char *) &thetime, sizeof (thetime));\n      do_close (s);\n      if (res < 0)\n\treturn (-1);\n    }\n  if (res != sizeof (thetime))\n    {\n      __set_errno (EIO);\n      return -1;\n    }\n  thetime = ntohl (thetime);\n  timep->tv_sec = thetime - TOFFSET;\n  timep->tv_usec = 0;\n  return 0;\n}",
    "xprt_register(SVCXPRT *)": "void\nxprt_register (SVCXPRT *xprt)\n{\n  register int sock = xprt->xp_sock;\n  register int i;\n\n  if (xports == NULL)\n    {\n      xports = (SVCXPRT **) calloc (_rpc_dtablesize (), sizeof (SVCXPRT *));\n      if (xports == NULL) /* Don't add handle */\n\treturn;\n    }\n\n  if (sock < _rpc_dtablesize ())\n    {\n      struct pollfd *new_svc_pollfd;\n\n      xports[sock] = xprt;\n      if (sock < FD_SETSIZE)\n\tFD_SET (sock, &svc_fdset);\n\n      /* Check if we have an empty slot */\n      for (i = 0; i < svc_max_pollfd; ++i)\n\tif (svc_pollfd[i].fd == -1)\n\t  {\n\t    svc_pollfd[i].fd = sock;\n\t    svc_pollfd[i].events = (POLLIN | POLLPRI |\n\t\t\t\t    POLLRDNORM | POLLRDBAND);\n\t    return;\n\t  }\n\n      new_svc_pollfd = (struct pollfd *) realloc (svc_pollfd,\n\t\t\t\t\t\t  sizeof (struct pollfd)\n\t\t\t\t\t\t  * (svc_max_pollfd + 1));\n      if (new_svc_pollfd == NULL) /* Out of memory */\n\treturn;\n      svc_pollfd = new_svc_pollfd;\n      ++svc_max_pollfd;\n\n      svc_pollfd[svc_max_pollfd - 1].fd = sock;\n      svc_pollfd[svc_max_pollfd - 1].events = (POLLIN | POLLPRI |\n\t\t\t\t\t       POLLRDNORM | POLLRDBAND);\n    }\n}",
    "svc_register(SVCXPRT *, int, int, void (*)(struct svc_req *, SVCXPRT *), int)": "bool_t\nsvc_register (SVCXPRT * xprt, rpcprog_t prog, rpcvers_t vers,\n\t      void (*dispatch) (struct svc_req *, SVCXPRT *),\n\t      rpcproc_t protocol)\n{\n  struct svc_callout *prev;\n  register struct svc_callout *s;\n\n  if ((s = svc_find (prog, vers, &prev)) != NULL_SVC)\n    {\n      if (s->sc_dispatch == dispatch)\n\tgoto pmap_it;\t\t/* he is registering another xptr */\n      return FALSE;\n    }\n  s = (struct svc_callout *) mem_alloc (sizeof (struct svc_callout));\n  if (s == (struct svc_callout *) 0)\n    return FALSE;\n\n  s->sc_prog = prog;\n  s->sc_vers = vers;\n  s->sc_dispatch = dispatch;\n  s->sc_next = svc_head;\n  s->sc_mapped = FALSE;\n  svc_head = s;\n\npmap_it:\n  /* now register the information with the local binder service */\n  if (protocol)\n    {\n      if (! pmap_set (prog, vers, protocol, xprt->xp_port))\n\treturn FALSE;\n\n      s->sc_mapped = TRUE;\n    }\n\n  return TRUE;\n}",
    "_authenticate(struct svc_req *, struct rpc_msg *)": "enum auth_stat\n_authenticate (register struct svc_req *rqst, struct rpc_msg *msg)\n{\n  register int cred_flavor;\n\n  rqst->rq_cred = msg->rm_call.cb_cred;\n  rqst->rq_xprt->xp_verf.oa_flavor = _null_auth.oa_flavor;\n  rqst->rq_xprt->xp_verf.oa_length = 0;\n  cred_flavor = rqst->rq_cred.oa_flavor;\n  if ((cred_flavor <= AUTH_MAX) && (cred_flavor >= AUTH_NULL))\n    return (*(svcauthsw[cred_flavor].authenticator)) (rqst, msg);\n\n  return AUTH_REJECTEDCRED;\n}",
    "svcraw_create()": "SVCXPRT *\nsvcraw_create (void)\n{\n  struct svcraw_private_s *srp = svcraw_private;\n\n  if (srp == 0)\n    {\n      srp = (struct svcraw_private_s *) calloc (1, sizeof (*srp));\n      if (srp == 0)\n\treturn NULL;\n    }\n  srp->server.xp_sock = 0;\n  srp->server.xp_port = 0;\n  srp->server.xp_ops = (struct xp_ops *) &server_ops;\n  srp->server.xp_verf.oa_base = srp->verf_body;\n  xdrmem_create (&srp->xdr_stream, srp->_raw_buf, UDPMSGSIZE, XDR_FREE);\n  return &srp->server;\n}",
    "svc_exit()": "void\nsvc_exit (void)\n{\n  free (svc_pollfd);\n  svc_pollfd = NULL;\n  svc_max_pollfd = 0;\n}",
    "svctcp_create(int, u_int, u_int)": "SVCXPRT *\nsvctcp_create (int sock, u_int sendsize, u_int recvsize)\n{\n  bool_t madesock = FALSE;\n  SVCXPRT *xprt;\n  struct tcp_rendezvous *r;\n  struct sockaddr_in addr;\n  socklen_t len = sizeof (struct sockaddr_in);\n\n  if (sock == RPC_ANYSOCK)\n    {\n      if ((sock = __socket (AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)\n\t{\n\t  perror (_(\"svc_tcp.c - tcp socket creation problem\"));\n\t  return (SVCXPRT *) NULL;\n\t}\n      madesock = TRUE;\n    }\n  memset ((char *) &addr, 0, sizeof (addr));\n  addr.sin_family = AF_INET;\n  if (bindresvport (sock, &addr))\n    {\n      addr.sin_port = 0;\n      (void) __bind (sock, (struct sockaddr *) &addr, len);\n    }\n  if ((__getsockname (sock, (struct sockaddr *) &addr, &len) != 0) ||\n      (__listen (sock, SOMAXCONN) != 0))\n    {\n      perror (_(\"svc_tcp.c - cannot getsockname or listen\"));\n      if (madesock)\n\t(void) __close (sock);\n      return (SVCXPRT *) NULL;\n    }\n  r = (struct tcp_rendezvous *) mem_alloc (sizeof (*r));\n  xprt = (SVCXPRT *) mem_alloc (sizeof (SVCXPRT));\n  if (r == NULL || xprt == NULL)\n    {\n      (void) __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n      mem_free (r, sizeof (*r));\n      mem_free (xprt, sizeof (SVCXPRT));\n      return NULL;\n    }\n  r->sendsize = sendsize;\n  r->recvsize = recvsize;\n  xprt->xp_p2 = NULL;\n  xprt->xp_p1 = (caddr_t) r;\n  xprt->xp_verf = _null_auth;\n  xprt->xp_ops = &svctcp_rendezvous_op;\n  xprt->xp_port = ntohs (addr.sin_port);\n  xprt->xp_sock = sock;\n  xprt_register (xprt);\n  return xprt;\n}",
    "svcudp_bufcreate(int, u_int, u_int)": "SVCXPRT *\nsvcudp_bufcreate (int sock, u_int sendsz, u_int recvsz)\n{\n  bool_t madesock = FALSE;\n  SVCXPRT *xprt;\n  struct svcudp_data *su;\n  struct sockaddr_in addr;\n  socklen_t len = sizeof (struct sockaddr_in);\n  int pad;\n  void *buf;\n\n  if (sock == RPC_ANYSOCK)\n    {\n      if ((sock = __socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)\n\t{\n\t  perror (_(\"svcudp_create: socket creation problem\"));\n\t  return (SVCXPRT *) NULL;\n\t}\n      madesock = TRUE;\n    }\n  memset ((char *) &addr, 0, sizeof (addr));\n  addr.sin_family = AF_INET;\n  if (bindresvport (sock, &addr))\n    {\n      addr.sin_port = 0;\n      (void) __bind (sock, (struct sockaddr *) &addr, len);\n    }\n  if (__getsockname (sock, (struct sockaddr *) &addr, &len) != 0)\n    {\n      perror (_(\"svcudp_create - cannot getsockname\"));\n      if (madesock)\n\t(void) __close (sock);\n      return (SVCXPRT *) NULL;\n    }\n  xprt = (SVCXPRT *) mem_alloc (sizeof (SVCXPRT));\n  su = (struct svcudp_data *) mem_alloc (sizeof (*su));\n  buf = mem_alloc (((MAX (sendsz, recvsz) + 3) / 4) * 4);\n  if (xprt == NULL || su == NULL || buf == NULL)\n    {\n      (void) __fxprintf (NULL, \"%s: %s\",\n\t\t\t \"svcudp_create\",  _(\"out of memory\\n\"));\n      mem_free (xprt, sizeof (SVCXPRT));\n      mem_free (su, sizeof (*su));\n      mem_free (buf, ((MAX (sendsz, recvsz) + 3) / 4) * 4);\n      return NULL;\n    }\n  su->su_iosz = ((MAX (sendsz, recvsz) + 3) / 4) * 4;\n  rpc_buffer (xprt) = buf;\n  xdrmem_create (&(su->su_xdrs), rpc_buffer (xprt), su->su_iosz, XDR_DECODE);\n  su->su_cache = NULL;\n  xprt->xp_p2 = (caddr_t) su;\n  xprt->xp_verf.oa_base = su->su_verfbody;\n  xprt->xp_ops = &svcudp_op;\n  xprt->xp_port = ntohs (addr.sin_port);\n  xprt->xp_sock = sock;\n\n#ifdef IP_PKTINFO\n  if ((sizeof (struct iovec) + sizeof (struct msghdr)\n       + sizeof(struct cmsghdr) + sizeof (struct in_pktinfo))\n      > sizeof (xprt->xp_pad))\n    {\n      (void) __fxprintf (NULL,\"%s\", _(\"\\\nsvcudp_create: xp_pad is too small for IP_PKTINFO\\n\"));\n      return NULL;\n    }\n  pad = 1;\n  if (__setsockopt (sock, SOL_IP, IP_PKTINFO, (void *) &pad,\n\t\t    sizeof (pad)) == 0)\n    /* Set the padding to all 1s. */\n    pad = 0xff;\n  else\n#endif\n    /* Clear the padding. */\n    pad = 0;\n  memset (&xprt->xp_pad [0], pad, sizeof (xprt->xp_pad));\n\n  xprt_register (xprt);\n  return xprt;\n}",
    "svcudp_enablecache(int *, u_long)": "int\nsvcudp_enablecache (SVCXPRT *transp, u_long size)\n{\n  struct svcudp_data *su = su_data (transp);\n  struct udp_cache *uc;\n\n  if (su->su_cache != NULL)\n    {\n      CACHE_PERROR (_(\"enablecache: cache already enabled\"));\n      return 0;\n    }\n  uc = ALLOC (struct udp_cache, 1);\n  if (uc == NULL)\n    {\n      CACHE_PERROR (_(\"enablecache: could not allocate cache\"));\n      return 0;\n    }\n  uc->uc_size = size;\n  uc->uc_nextvictim = 0;\n  uc->uc_entries = CALLOC (cache_ptr, size * SPARSENESS);\n  if (uc->uc_entries == NULL)\n    {\n      mem_free (uc, sizeof (struct udp_cache));\n      CACHE_PERROR (_(\"enablecache: could not allocate cache data\"));\n      return 0;\n    }\n  uc->uc_fifo = CALLOC (cache_ptr, size);\n  if (uc->uc_fifo == NULL)\n    {\n      mem_free (uc->uc_entries, size * SPARSENESS);\n      mem_free (uc, sizeof (struct udp_cache));\n      CACHE_PERROR (_(\"enablecache: could not allocate cache fifo\"));\n      return 0;\n    }\n  su->su_cache = (char *) uc;\n  return 1;\n}",
    "svcunix_create(int, u_int, u_int, char *)": "SVCXPRT *\nsvcunix_create (int sock, u_int sendsize, u_int recvsize, char *path)\n{\n  bool_t madesock = FALSE;\n  SVCXPRT *xprt;\n  struct unix_rendezvous *r;\n  struct sockaddr_un addr;\n  socklen_t len = sizeof (addr);\n\n  if (__sockaddr_un_set (&addr, path) < 0)\n    return NULL;\n\n  if (sock == RPC_ANYSOCK)\n    {\n      if ((sock = __socket (AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t{\n\t  perror (_(\"svc_unix.c - AF_UNIX socket creation problem\"));\n\t  return (SVCXPRT *) NULL;\n\t}\n      madesock = TRUE;\n    }\n  __bind (sock, (struct sockaddr *) &addr, len);\n\n  if (__getsockname (sock, (struct sockaddr *) &addr, &len) != 0\n      || __listen (sock, SOMAXCONN) != 0)\n    {\n      perror (_(\"svc_unix.c - cannot getsockname or listen\"));\n      if (madesock)\n\t__close (sock);\n      return (SVCXPRT *) NULL;\n    }\n\n  r = (struct unix_rendezvous *) mem_alloc (sizeof (*r));\n  xprt = (SVCXPRT *) mem_alloc (sizeof (SVCXPRT));\n  if (r == NULL || xprt == NULL)\n    {\n      __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n      mem_free (r, sizeof (*r));\n      mem_free (xprt, sizeof (SVCXPRT));\n      return NULL;\n    }\n  r->sendsize = sendsize;\n  r->recvsize = recvsize;\n  xprt->xp_p2 = NULL;\n  xprt->xp_p1 = (caddr_t) r;\n  xprt->xp_verf = _null_auth;\n  xprt->xp_ops = &svcunix_rendezvous_op;\n  xprt->xp_port = -1;\n  xprt->xp_sock = sock;\n  xprt_register (xprt);\n  return xprt;\n}",
    "authdes_getucred(const struct authdes_cred *, uid_t *, gid_t *, short *, gid_t *)": "int\nauthdes_getucred (const struct authdes_cred *adc, uid_t * uid, gid_t * gid,\n\t\t  short *grouplen, gid_t * groups)\n{\n  unsigned sid;\n  register int i;\n  uid_t i_uid;\n  gid_t i_gid;\n  int i_grouplen;\n  struct bsdcred *cred;\n\n  sid = adc->adc_nickname;\n  if (sid >= AUTHDES_CACHESZ)\n    {\n      debug (\"invalid nickname\");\n      return 0;\n    }\n  cred = (struct bsdcred *) authdes_cache[sid].localcred;\n  if (cred == NULL || cred->grouplen == INVALID)\n    {\n      /*\n       * not in cache: lookup\n       */\n      if (!netname2user (adc->adc_fullname.name, &i_uid, &i_gid,\n\t\t\t &i_grouplen, groups))\n\t{\n\t  debug (\"unknown netname\");\n\t  if (cred != NULL)\n\t    cred->grouplen = UNKNOWN;\t/* mark as lookup up, but not found */\n\t  return 0;\n\t}\n\n      if (cred != NULL && cred->grouplen_max < i_grouplen)\n\t{\n\t  /* We already have an allocated data structure.  But it is\n\t     too small.  */\n\t  free (cred);\n\t  authdes_cache[sid].localcred = NULL;\n\t  cred = NULL;\n\t}\n\n      if (cred == NULL)\n\t{\n\t  /* We should allocate room for at least NGROUPS groups.  */\n\t  int ngroups_max = MAX (i_grouplen, NGROUPS);\n\n\t  cred = (struct bsdcred *) mem_alloc (sizeof (struct bsdcred)\n\t\t\t\t\t       + ngroups_max * sizeof (gid_t));\n\t  if (cred == NULL)\n\t    return 0;\n\n\t  authdes_cache[sid].localcred = (char *) cred;\n\t  cred->grouplen = INVALID;\n\t  cred->grouplen_max = ngroups_max;\n\t}\n\n      debug (\"missed ucred cache\");\n      *uid = cred->uid = i_uid;\n      *gid = cred->gid = i_gid;\n      cred->grouplen = i_grouplen;\n      for (i = i_grouplen - 1; i >= 0; --i)\n\tcred->groups[i] = groups[i];\n      /* Make sure no too large values are reported.  */\n      *grouplen = MIN (SHRT_MAX, i_grouplen);\n      return 1;\n    }\n  else if (cred->grouplen == UNKNOWN)\n    {\n      /*\n       * Already lookup up, but no match found\n       */\n      return 0;\n    }\n\n  /*\n   * cached credentials\n   */\n  *uid = cred->uid;\n  *gid = cred->gid;\n\n  /* Another stupidity in the interface: *grouplen is of type short.\n     So we might have to cut the information passed up short.  */\n  int grouplen_copy = MIN (SHRT_MAX, cred->grouplen);\n  *grouplen = grouplen_copy;\n  for (i = grouplen_copy - 1; i >= 0; --i)\n    groups[i] = cred->groups[i];\n  return 1;\n}",
    "passwd2des(char *, char *)": "void passwd2des (char *pw, char *key)\n{\n  return passwd2des_internal (pw, key);\n}",
    "xencrypt(char *, char *)": "int\nxencrypt (char *secret, char *passwd)\n{\n  char key[8];\n  char ivec[8];\n  char *buf;\n  int err;\n  int len;\n\n  len = strlen (secret) / 2;\n  buf = malloc ((unsigned) len);\n  hex2bin (len, secret, buf);\n  passwd2des_internal (passwd, key);\n  memset (ivec, 0, 8);\n\n  err = cbc_crypt (key, buf, len, DES_ENCRYPT | DES_HW, ivec);\n  if (DES_FAILED (err))\n    {\n      free (buf);\n      return 0;\n    }\n  bin2hex (len, (unsigned char *) buf, secret);\n  free (buf);\n  return 1;\n}",
    "xdr_free(xdrproc_t, char *)": "void\nxdr_free (xdrproc_t proc, char *objp)\n{\n  XDR x;\n\n  x.x_op = XDR_FREE;\n  (*proc) (&x, objp);\n}",
    "xdr_array(XDR *, caddr_t *, u_int *, u_int, u_int, xdrproc_t)": "bool_t\nxdr_array (XDR *xdrs,\n\t   /* array pointer */\n\t   caddr_t *addrp,\n\t   /* number of elements */\n\t   u_int *sizep,\n\t   /* max numberof elements */\n\t   u_int maxsize,\n\t   /* size in bytes of each element */\n\t   u_int elsize,\n\t   /* xdr routine to handle each element */\n\t   xdrproc_t elproc)\n{\n  u_int i;\n  caddr_t target = *addrp;\n  u_int c;\t\t/* the actual element count */\n  bool_t stat = TRUE;\n\n  /* like strings, arrays are really counted arrays */\n  if (!xdr_u_int (xdrs, sizep))\n    {\n      return FALSE;\n    }\n  c = *sizep;\n  /*\n   * XXX: Let the overflow possibly happen with XDR_FREE because mem_free()\n   * doesn't actually use its second argument anyway.\n   */\n  if ((c > maxsize || c > UINT_MAX / elsize) && (xdrs->x_op != XDR_FREE))\n    {\n      return FALSE;\n    }\n\n  /*\n   * if we are deserializing, we may need to allocate an array.\n   * We also save time by checking for a null array if we are freeing.\n   */\n  if (target == NULL)\n    switch (xdrs->x_op)\n      {\n      case XDR_DECODE:\n\tif (c == 0)\n\t  return TRUE;\n\t*addrp = target = calloc (c, elsize);\n\tif (target == NULL)\n\t  {\n\t    (void) __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n\t    return FALSE;\n\t  }\n\tbreak;\n\n      case XDR_FREE:\n\treturn TRUE;\n      default:\n\tbreak;\n      }\n\n  /*\n   * now we xdr each element of array\n   */\n  for (i = 0; (i < c) && stat; i++)\n    {\n      stat = (*elproc) (xdrs, target, LASTUNSIGNED);\n      target += elsize;\n    }\n\n  /*\n   * the array may need freeing\n   */\n  if (xdrs->x_op == XDR_FREE)\n    {\n      mem_free (*addrp, c * elsize);\n      *addrp = NULL;\n    }\n  return stat;\n}",
    "xdr_float(XDR *, float *)": "bool_t\nxdr_float (XDR *xdrs, float *fp)\n{\n#ifdef vax\n\tstruct ieee_single is;\n\tstruct vax_single vs, *vsp;\n\tstruct sgl_limits *lim;\n\tint i;\n#endif\n\tswitch (xdrs->x_op) {\n\n\tcase XDR_ENCODE:\n#ifdef vax\n\t\tvs = *((struct vax_single *)fp);\n\t\tfor (i = 0, lim = sgl_limits;\n\t\t\ti < sizeof(sgl_limits)/sizeof(struct sgl_limits);\n\t\t\ti++, lim++) {\n\t\t\tif ((vs.mantissa2 == lim->s.mantissa2) &&\n\t\t\t\t(vs.exp == lim->s.exp) &&\n\t\t\t\t(vs.mantissa1 == lim->s.mantissa1)) {\n\t\t\t\tis = lim->ieee;\n\t\t\t\tgoto shipit;\n\t\t\t}\n\t\t}\n\t\tis.exp = vs.exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;\n\t\tis.mantissa = (vs.mantissa1 << 16) | vs.mantissa2;\n\tshipit:\n\t\tis.sign = vs.sign;\n\t\treturn (XDR_PUTLONG(xdrs, (long *)&is));\n#else\n\t\tif (sizeof(float) == sizeof(long))\n\t\t\treturn (XDR_PUTLONG(xdrs, (long *)fp));\n\t\telse if (sizeof(float) == sizeof(int)) {\n\t\t\tlong tmp = *(int *)fp;\n\t\t\treturn (XDR_PUTLONG(xdrs, &tmp));\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase XDR_DECODE:\n#ifdef vax\n\t\tvsp = (struct vax_single *)fp;\n\t\tif (!XDR_GETLONG(xdrs, (long *)&is))\n\t\t\treturn (FALSE);\n\t\tfor (i = 0, lim = sgl_limits;\n\t\t\ti < sizeof(sgl_limits)/sizeof(struct sgl_limits);\n\t\t\ti++, lim++) {\n\t\t\tif ((is.exp == lim->ieee.exp) &&\n\t\t\t\t(is.mantissa == lim->ieee.mantissa)) {\n\t\t\t\t*vsp = lim->s;\n\t\t\t\tgoto doneit;\n\t\t\t}\n\t\t}\n\t\tvsp->exp = is.exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;\n\t\tvsp->mantissa2 = is.mantissa;\n\t\tvsp->mantissa1 = (is.mantissa >> 16);\n\tdoneit:\n\t\tvsp->sign = is.sign;\n\t\treturn (TRUE);\n#else\n\t\tif (sizeof(float) == sizeof(long))\n\t\t\treturn (XDR_GETLONG(xdrs, (long *)fp));\n\t\telse if (sizeof(float) == sizeof(int)) {\n\t\t\tlong tmp;\n\t\t\tif (XDR_GETLONG(xdrs, &tmp)) {\n\t\t\t\t*(int *)fp = tmp;\n\t\t\t\treturn (TRUE);\n\t\t\t}\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase XDR_FREE:\n\t\treturn (TRUE);\n\t}\n\treturn (FALSE);\n}",
    "xdr_int64_t(XDR *, int64_t *)": "bool_t\nxdr_int64_t (XDR *xdrs, int64_t *ip)\n{\n  int32_t t1, t2;\n\n  switch (xdrs->x_op)\n    {\n    case XDR_ENCODE:\n      t1 = (int32_t) ((*ip) >> 32);\n      t2 = (int32_t) (*ip);\n      return (XDR_PUTINT32(xdrs, &t1) && XDR_PUTINT32(xdrs, &t2));\n    case XDR_DECODE:\n      if (!XDR_GETINT32(xdrs, &t1) || !XDR_GETINT32(xdrs, &t2))\n\treturn FALSE;\n      *ip = ((int64_t) t1) << 32;\n      *ip |= (uint32_t) t2;\t/* Avoid sign extension.  */\n      return TRUE;\n    case XDR_FREE:\n      return TRUE;\n    default:\n      return FALSE;\n    }\n}",
    "xdrmem_create(int *, const caddr_t, u_int, enum xdr_op)": "void\nxdrmem_create (XDR *xdrs, const caddr_t addr, u_int size, enum xdr_op op)\n{\n  xdrs->x_op = op;\n  /* We have to add the const since the `struct xdr_ops' in `struct XDR'\n     is not `const'.  */\n  xdrs->x_ops = (struct xdr_ops *) &xdrmem_ops;\n  xdrs->x_private = xdrs->x_base = addr;\n  xdrs->x_handy = size;\n}",
    "xdrrec_create(int *, u_int, u_int, caddr_t, int (*)(char *, char *, int), int (*)(char *, char *, int))": "void\nxdrrec_create (XDR *xdrs, u_int sendsize,\n\t       u_int recvsize, caddr_t tcp_handle,\n\t       int (*readit) (char *, char *, int),\n\t       int (*writeit) (char *, char *, int))\n{\n  RECSTREAM *rstrm = (RECSTREAM *) mem_alloc (sizeof (RECSTREAM));\n  caddr_t tmp;\n  char *buf;\n\n  sendsize = fix_buf_size (sendsize);\n  recvsize = fix_buf_size (recvsize);\n  buf = mem_alloc (sendsize + recvsize + BYTES_PER_XDR_UNIT);\n\n  if (rstrm == NULL || buf == NULL)\n    {\n      (void) __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n      mem_free (rstrm, sizeof (RECSTREAM));\n      mem_free (buf, sendsize + recvsize + BYTES_PER_XDR_UNIT);\n      /*\n       *  This is bad.  Should rework xdrrec_create to\n       *  return a handle, and in this case return NULL\n       */\n      return;\n    }\n  /*\n   * adjust sizes and allocate buffer quad byte aligned\n   */\n  rstrm->sendsize = sendsize;\n  rstrm->recvsize = recvsize;\n  rstrm->the_buffer = buf;\n  tmp = rstrm->the_buffer;\n  if ((size_t)tmp % BYTES_PER_XDR_UNIT)\n    tmp += BYTES_PER_XDR_UNIT - (size_t)tmp % BYTES_PER_XDR_UNIT;\n  rstrm->out_base = tmp;\n  rstrm->in_base = tmp + sendsize;\n  /*\n   * now the rest ...\n   */\n  /* We have to add the cast since the `struct xdr_ops' in `struct XDR'\n     is not `const'.  */\n  xdrs->x_ops = (struct xdr_ops *) &xdrrec_ops;\n  xdrs->x_private = (caddr_t) rstrm;\n  rstrm->tcp_handle = tcp_handle;\n  rstrm->readit = readit;\n  rstrm->writeit = writeit;\n  rstrm->out_finger = rstrm->out_boundry = rstrm->out_base;\n  rstrm->frag_header = (uint32_t *) rstrm->out_base;\n  rstrm->out_finger += 4;\n  rstrm->out_boundry += sendsize;\n  rstrm->frag_sent = FALSE;\n  rstrm->in_size = recvsize;\n  rstrm->in_boundry = rstrm->in_base;\n  rstrm->in_finger = (rstrm->in_boundry += recvsize);\n  rstrm->fbtbc = 0;\n  rstrm->last_frag = TRUE;\n}",
    "xdrrec_skiprecord(int *)": "bool_t\nxdrrec_skiprecord (XDR *xdrs)\n{\n  RECSTREAM *rstrm = (RECSTREAM *) xdrs->x_private;\n\n  while (rstrm->fbtbc > 0 || (!rstrm->last_frag))\n    {\n      if (!skip_input_bytes (rstrm, rstrm->fbtbc))\n\treturn FALSE;\n      rstrm->fbtbc = 0;\n      if ((!rstrm->last_frag) && (!set_input_fragment (rstrm)))\n\treturn FALSE;\n    }\n  rstrm->last_frag = FALSE;\n  return TRUE;\n}",
    "xdr_reference(XDR *, caddr_t *, u_int, xdrproc_t)": "bool_t\nxdr_reference (XDR *xdrs,\n\t       /* the pointer to work on */\n\t       caddr_t *pp,\n\t       /* size of the object pointed to */\n\t       u_int size,\n\t       /* xdr routine to handle the object */\n\t       xdrproc_t proc)\n{\n  caddr_t loc = *pp;\n  bool_t stat;\n\n  if (loc == NULL)\n    switch (xdrs->x_op)\n      {\n      case XDR_FREE:\n\treturn TRUE;\n\n      case XDR_DECODE:\n\t*pp = loc = (caddr_t) calloc (1, size);\n\tif (loc == NULL)\n\t  {\n\t    (void) __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n\t    return FALSE;\n\t  }\n\tbreak;\n      default:\n\tbreak;\n      }\n\n  stat = (*proc) (xdrs, loc, LASTUNSIGNED);\n\n  if (xdrs->x_op == XDR_FREE)\n    {\n      mem_free (loc, size);\n      *pp = NULL;\n    }\n  return stat;\n}",
    "xdr_sizeof(xdrproc_t, void *)": "unsigned long\nxdr_sizeof (xdrproc_t func, void *data)\n{\n  XDR x;\n  struct xdr_ops ops;\n  bool_t stat;\n  /* to stop ANSI-C compiler from complaining */\n  typedef bool_t (*dummyfunc1) (XDR *, long *);\n  typedef bool_t (*dummyfunc2) (XDR *, caddr_t, u_int);\n  typedef bool_t (*dummyfunc3) (XDR *, int32_t *);\n\n  ops.x_putlong = x_putlong;\n  ops.x_putbytes = x_putbytes;\n  ops.x_inline = x_inline;\n  ops.x_getpostn = x_getpostn;\n  ops.x_setpostn = x_setpostn;\n  ops.x_destroy = x_destroy;\n  ops.x_putint32 = x_putint32;\n\n  /* the other harmless ones */\n  ops.x_getlong = (dummyfunc1) harmless;\n  ops.x_getbytes = (dummyfunc2) harmless;\n  ops.x_getint32 = (dummyfunc3) harmless;\n\n  x.x_op = XDR_ENCODE;\n  x.x_ops = &ops;\n  x.x_handy = 0;\n  x.x_private = (caddr_t) NULL;\n  x.x_base = (caddr_t) 0;\n\n  stat = func (&x, data);\n  free (x.x_private);\n  return stat == TRUE ? x.x_handy : 0;\n}",
    "xdrstdio_create(XDR *, FILE *, enum xdr_op)": "void\nxdrstdio_create (XDR *xdrs, FILE *file, enum xdr_op op)\n{\n  xdrs->x_op = op;\n  /* We have to add the const since the `struct xdr_ops' in `struct XDR'\n     is not `const'.  */\n  xdrs->x_ops = (struct xdr_ops *) &xdrstdio_ops;\n  xdrs->x_private = (caddr_t) file;\n  xdrs->x_handy = 0;\n  xdrs->x_base = 0;\n}",
    "feclearexcept(int)": "int\nfeclearexcept (int excepts)\n{\n  fenv_t temp;\n  unsigned int mxcsr;\n\n  /* Mask out unsupported bits/exceptions.  */\n  excepts &= FE_ALL_EXCEPT;\n\n  /* Bah, we have to clear selected exceptions.  Since there is no\n     `fldsw' instruction we have to do it the hard way.  */\n  __asm__ (\"fnstenv %0\" : \"=m\" (*&temp));\n\n  /* Clear the relevant bits.  */\n  temp.__status_word &= excepts ^ FE_ALL_EXCEPT;\n\n  /* Put the new data in effect.  */\n  __asm__ (\"fldenv %0\" : : \"m\" (*&temp));\n\n  /* And the same procedure for SSE.  */\n  __asm__ (\"stmxcsr %0\" : \"=m\" (*&mxcsr));\n\n  /* Clear the relevant bits.  */\n  mxcsr &= ~excepts;\n\n  /* And put them into effect.  */\n  __asm__ (\"ldmxcsr %0\" : : \"m\" (*&mxcsr));\n\n  /* Success.  */\n  return 0;\n}",
    "fegetexceptflag(fexcept_t *, int)": "int\nfegetexceptflag (fexcept_t *flagp, int excepts)\n{\n  fexcept_t temp;\n  unsigned int mxscr;\n\n  /* Get the current exceptions for the x87 FPU and SSE unit.  */\n  __asm__ (\"fnstsw %0\\n\"\n\t   \"stmxcsr %1\" : \"=m\" (*&temp), \"=m\" (*&mxscr));\n\n  *flagp = (temp | mxscr) & FE_ALL_EXCEPT & excepts;\n\n  /* Success.  */\n  return 0;\n}",
    "fesetexceptflag(const fexcept_t *, int)": "int\nfesetexceptflag (const fexcept_t *flagp, int excepts)\n{\n  /* The flags can be set in the 387 unit or in the SSE unit.\n     When we need to clear a flag, we need to do so in both units,\n     due to the way fetestexcept() is implemented.\n     When we need to set a flag, it is sufficient to do it in the SSE unit,\n     because that is guaranteed to not trap.  */\n\n  fenv_t temp;\n  unsigned int mxcsr;\n\n  excepts &= FE_ALL_EXCEPT;\n\n  /* Get the current x87 FPU environment.  We have to do this since we\n     cannot separately set the status word.  */\n  __asm__ (\"fnstenv %0\" : \"=m\" (*&temp));\n\n  /* Clear relevant flags.  */\n  temp.__status_word &= ~(excepts & ~ *flagp);\n\n  /* Store the new status word (along with the rest of the environment).  */\n  __asm__ (\"fldenv %0\" : : \"m\" (*&temp));\n\n  /* And now similarly for SSE.  */\n  __asm__ (\"stmxcsr %0\" : \"=m\" (*&mxcsr));\n\n  /* Clear or set relevant flags.  */\n  mxcsr ^= (mxcsr ^ *flagp) & excepts;\n\n  /* Put the new data in effect.  */\n  __asm__ (\"ldmxcsr %0\" : : \"m\" (*&mxcsr));\n\n  /* Success.  */\n  return 0;\n}",
    "__isnan(double)": "int\n__isnan (double x)\n{\n  return (_FCLASS (x) & _FCLASS_NAN) != 0;\n}",
    "__libc_unwind_link_get()": "static inline struct unwind_link *\n__libc_unwind_link_get (void)\n{\n  /* Return something that is not a null pointer, so that error checks\n     succeed.  */\n  return (struct unwind_link *) 1;\n}",
    "link()": "static struct unwind_link *\nlink (void)\n{\n  struct unwind_link *unwind_link = __libc_unwind_link_get ();\n  if (unwind_link == NULL)\n    __libc_fatal (LIBGCC_S_SO \" must be installed for unwinding to work\\n\");\n  return unwind_link;\n}",
    "__signbit(double)": "int\n__signbit (double x)\n{\n  return __builtin_signbit (x);\n}",
    "pthread_attr_getguardsize(const pthread_attr_t *, int *)": "int\npthread_attr_getguardsize (const pthread_attr_t *attr, size_t * guardsize)\n{\n  *guardsize = attr->__guardsize;\n  return 0;\n}",
    "pthread_attr_setguardsize(pthread_attr_t *, int)": "int\npthread_attr_setguardsize (pthread_attr_t *attr, size_t guardsize)\n{\n  attr->__guardsize = guardsize;\n  return 0;\n}",
    "pthread_barrier_destroy(pthread_barrier_t *)": "int\npthread_barrier_destroy (pthread_barrier_t *barrier)\n{\n  return 0;\n}",
    "pthread_barrier_init(pthread_barrier_t *, const pthread_barrierattr_t *, unsigned int)": "int\npthread_barrier_init (pthread_barrier_t *barrier,\n\t\t      const pthread_barrierattr_t *attr, unsigned count)\n{\n  ASSERT_TYPE_SIZE (pthread_barrier_t, __SIZEOF_PTHREAD_BARRIER_T);\n\n  if (count == 0)\n    return EINVAL;\n\n  memset (barrier, 0, sizeof *barrier);\n\n  barrier->__lock = PTHREAD_SPINLOCK_INITIALIZER;\n  barrier->__pending = count;\n  barrier->__count = count;\n\n  if (attr == NULL\n      || memcmp (attr, &__pthread_default_barrierattr, sizeof (*attr)) == 0)\n    /* Use the default attributes.  */\n    return 0;\n\n  /* Non-default attributes.  */\n\n  barrier->__attr = malloc (sizeof *attr);\n  if (barrier->__attr == NULL)\n    return ENOMEM;\n\n  *barrier->__attr = *attr;\n  return 0;\n}",
    "pthread_barrier_wait(pthread_barrier_t *)": "int\npthread_barrier_wait (pthread_barrier_t *barrier)\n{\n  __pthread_spin_wait (&barrier->__lock);\n  if (--barrier->__pending == 0)\n    {\n      barrier->__pending = barrier->__count;\n\n      if (barrier->__count == 1)\n\t__pthread_spin_unlock (&barrier->__lock);\n      else\n\t{\n\t  struct __pthread *wakeup;\n\t  unsigned n = 0;\n\n\t  __pthread_queue_iterate (barrier->__queue, wakeup)\n\t    n++;\n\n\t  {\n\t    struct __pthread *wakeups[n];\n\t    unsigned i = 0;\n\n\t    __pthread_dequeuing_iterate (barrier->__queue, wakeup)\n\t      wakeups[i++] = wakeup;\n\n\t    barrier->__queue = NULL;\n\t    __pthread_spin_unlock (&barrier->__lock);\n\n\t    for (i = 0; i < n; i++)\n\t      __pthread_wakeup (wakeups[i]);\n\t  }\n\t}\n\n      return PTHREAD_BARRIER_SERIAL_THREAD;\n    }\n  else\n    {\n      struct __pthread *self = _pthread_self ();\n\n      /* Add ourselves to the list of waiters.  */\n      __pthread_enqueue (&barrier->__queue, self);\n      __pthread_spin_unlock (&barrier->__lock);\n\n      __pthread_block (self);\n      return 0;\n    }\n}",
    "pthread_barrierattr_destroy(pthread_barrierattr_t *)": "int\npthread_barrierattr_destroy (pthread_barrierattr_t *attr)\n{\n  return 0;\n}",
    "pthread_barrierattr_getpshared(const pthread_barrierattr_t *, int *)": "int\npthread_barrierattr_getpshared (const pthread_barrierattr_t *attr,\n\t\t\t\tint *pshared)\n{\n  *pshared = attr->__pshared;\n  return 0;\n}",
    "pthread_barrierattr_init(pthread_barrierattr_t *)": "int\npthread_barrierattr_init (pthread_barrierattr_t *attr)\n{\n  ASSERT_TYPE_SIZE (pthread_barrierattr_t, __SIZEOF_PTHREAD_BARRIERATTR_T);\n\n  *attr = __pthread_default_barrierattr;\n  return 0;\n}",
    "pthread_barrierattr_setpshared(pthread_barrierattr_t *, int)": "int\npthread_barrierattr_setpshared (pthread_barrierattr_t *attr, int pshared)\n{\n  switch (pshared)\n    {\n    case PTHREAD_PROCESS_PRIVATE:\n      attr->__pshared = pshared;\n      return 0;\n\n    case PTHREAD_PROCESS_SHARED:\n      return ENOTSUP;\n\n    default:\n      return EINVAL;\n    }\n}",
    "pthread_condattr_getclock(const pthread_condattr_t *, clockid_t *)": "int\npthread_condattr_getclock (const pthread_condattr_t *attr, clockid_t * clock)\n{\n  *clock = attr->__clock;\n  return 0;\n}",
    "pthread_condattr_getpshared(const pthread_condattr_t *, int *)": "int\npthread_condattr_getpshared (const pthread_condattr_t *attr, int *pshared)\n{\n  *pshared = attr->__pshared;\n  return 0;\n}",
    "pthread_condattr_setclock(pthread_condattr_t *, clockid_t)": "int\npthread_condattr_setclock (pthread_condattr_t *attr, clockid_t clock)\n{\n  /* Only a few clocks are allowed.  CLOCK_REALTIME is always allowed.\n     CLOCK_MONOTONIC only if the kernel has the necessary support.  */\n  if (clock == CLOCK_MONOTONIC)\n    {\n      /* Check whether the clock is available.  */\n      static int avail;\n\n      if (avail == 0)\n\t{\n\t  struct timespec ts;\n\t  int res;\n\n\t  res = clock_gettime (CLOCK_MONOTONIC, &ts);\n\t  avail = res < 0 ? -1 : 1;\n\t}\n\n      if (avail < 0)\n\t/* Not available.  */\n\treturn EINVAL;\n    }\n  else if (clock != CLOCK_REALTIME)\n    return EINVAL;\n\n  attr->__clock = clock;\n\n  return 0;\n}",
    "pthread_condattr_setpshared(pthread_condattr_t *, int)": "int\npthread_condattr_setpshared (pthread_condattr_t *attr, int pshared)\n{\n  switch (pshared)\n    {\n    case PTHREAD_PROCESS_PRIVATE:\n      attr->__pshared = pshared;\n      return 0;\n\n    case PTHREAD_PROCESS_SHARED:\n      return ENOTSUP;\n\n    default:\n      return EINVAL;\n    }\n}",
    "pthread_getconcurrency()": "int\npthread_getconcurrency (void)\n{\n  return __pthread_concurrency;\n}",
    "pthread_getcpuclockid(pthread_t, clockid_t *)": "int\npthread_getcpuclockid (pthread_t thread, clockid_t *clock)\n{\n#ifdef CLOCK_THREAD_CPUTIME_ID\n  *clock = CLOCK_THREAD_CPUTIME_ID;\n  return 0;\n#else\n  return ENOSYS;\n#endif\n}",
    "__pthread_getspecific(pthread_key_t)": "void *\n__pthread_getspecific (pthread_key_t key)\n{\n  struct __pthread *self;\n\n  if (key < 0 || key >= __pthread_key_count)\n    return NULL;\n\n  self = _pthread_self ();\n\n  if (self->thread_specifics == NULL)\n    {\n      if (key >= PTHREAD_STATIC_KEYS)\n\treturn NULL;\n      return self->static_thread_specifics[key];\n    }\n\n  if (key >= self->thread_specifics_size)\n    return 0;\n\n  return self->thread_specifics[key];\n}",
    "__pthread_once(pthread_once_t *, void (*)(void))": "int\n__pthread_once (pthread_once_t *once_control, void (*init_routine) (void))\n{\n  ASSERT_TYPE_SIZE (pthread_once_t, __SIZEOF_PTHREAD_ONCE_T);\n\n  atomic_full_barrier ();\n  if (once_control->__run == 0)\n    {\n      __pthread_spin_wait (&once_control->__lock);\n\n      if (once_control->__run == 0)\n\t{\n\t  pthread_cleanup_push (clear_once_control, once_control);\n\t  init_routine ();\n\t  pthread_cleanup_pop (0);\n\n\t  atomic_full_barrier ();\n\t  once_control->__run = 1;\n\t}\n\n      __pthread_spin_unlock (&once_control->__lock);\n    }\n\n  return 0;\n}",
    "__pthread_rwlock_rdlock(struct __pthread_rwlock *)": "int\n__pthread_rwlock_rdlock (struct __pthread_rwlock *rwlock)\n{\n  return __pthread_rwlock_timedrdlock_internal (rwlock, -1, 0);\n}",
    "pthread_rwlock_tryrdlock(struct __pthread_rwlock *)": "int\npthread_rwlock_tryrdlock (struct __pthread_rwlock *rwlock)\n{\n  __pthread_spin_wait (&rwlock->__lock);\n  if (__pthread_spin_trylock (&rwlock->__held) == 0)\n    /* Successfully acquired the lock.  */\n    {\n      assert (rwlock->__readerqueue == 0);\n      assert (rwlock->__writerqueue == 0);\n      assert (rwlock->__readers == 0);\n\n      rwlock->__readers = 1;\n      __pthread_spin_unlock (&rwlock->__lock);\n      return 0;\n    }\n  else\n    /* Lock is held, but is held by a reader?  */\n  if (rwlock->__readers > 0)\n    {\n      assert (rwlock->__readerqueue == 0);\n      rwlock->__readers++;\n      __pthread_spin_unlock (&rwlock->__lock);\n      return 0;\n    }\n\n  /* The lock is busy.  */\n\n  __pthread_spin_unlock (&rwlock->__lock);\n\n  return EBUSY;\n}",
    "pthread_rwlock_trywrlock(struct __pthread_rwlock *)": "int\npthread_rwlock_trywrlock (struct __pthread_rwlock *rwlock)\n{\n  __pthread_spin_wait (&rwlock->__lock);\n  if (__pthread_spin_trylock (&rwlock->__held) == 0)\n    /* Successfully acquired the lock.  */\n    {\n      assert (rwlock->__readerqueue == 0);\n      assert (rwlock->__writerqueue == 0);\n      assert (rwlock->__readers == 0);\n\n      __pthread_spin_unlock (&rwlock->__lock);\n      return 0;\n    }\n\n  /* The lock is busy.  */\n\n  __pthread_spin_unlock (&rwlock->__lock);\n\n  return EBUSY;\n}",
    "__pthread_rwlock_unlock(pthread_rwlock_t *)": "int\n__pthread_rwlock_unlock (pthread_rwlock_t *rwlock)\n{\n  struct __pthread *wakeup;\n\n  __pthread_spin_wait (&rwlock->__lock);\n\n  assert (__pthread_spin_trylock (&rwlock->__held) == EBUSY);\n\n  if (rwlock->__readers > 1)\n    /* There are other readers.  */\n    {\n      rwlock->__readers--;\n      __pthread_spin_unlock (&rwlock->__lock);\n      return 0;\n    }\n\n  if (rwlock->__readers == 1)\n    /* Last reader.  */\n    rwlock->__readers = 0;\n\n\n  /* Wake someone else up.  Try the writer queue first, then the\n     reader queue if that is empty.  */\n\n  if (rwlock->__writerqueue)\n    {\n      wakeup = rwlock->__writerqueue;\n      __pthread_dequeue (wakeup);\n\n      /* We do not unlock RWLOCK->held: we are transferring the ownership\n         to the thread that we are waking up.  */\n\n      __pthread_spin_unlock (&rwlock->__lock);\n      __pthread_wakeup (wakeup);\n\n      return 0;\n    }\n\n  if (rwlock->__readerqueue)\n    {\n      unsigned n = 0;\n\n      __pthread_queue_iterate (rwlock->__readerqueue, wakeup)\n\tn++;\n\n      {\n\tstruct __pthread *wakeups[n];\n\tunsigned i = 0;\n\n\t__pthread_dequeuing_iterate (rwlock->__readerqueue, wakeup)\n\t  wakeups[i++] = wakeup;\n\n\trwlock->__readers += n;\n\trwlock->__readerqueue = 0;\n\n\t__pthread_spin_unlock (&rwlock->__lock);\n\n\tfor (i = 0; i < n; i++)\n\t  __pthread_wakeup (wakeups[i]);\n      }\n\n      return 0;\n    }\n\n\n  /* No one is waiting.  Just unlock it.  */\n\n  __pthread_spin_unlock (&rwlock->__held);\n  __pthread_spin_unlock (&rwlock->__lock);\n  return 0;\n}",
    "__pthread_rwlock_wrlock(struct __pthread_rwlock *)": "int\n__pthread_rwlock_wrlock (struct __pthread_rwlock *rwlock)\n{\n  return __pthread_rwlock_timedwrlock_internal (rwlock, -1, 0);\n}",
    "pthread_rwlockattr_destroy(pthread_rwlockattr_t *)": "int\npthread_rwlockattr_destroy (pthread_rwlockattr_t *attr)\n{\n  return 0;\n}",
    "pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *, int *)": "int\npthread_rwlockattr_getpshared (const pthread_rwlockattr_t *attr, int *pshared)\n{\n  *pshared = attr->__pshared;\n  return 0;\n}",
    "pthread_rwlockattr_init(pthread_rwlockattr_t *)": "int\npthread_rwlockattr_init (pthread_rwlockattr_t *attr)\n{\n  ASSERT_TYPE_SIZE (pthread_rwlockattr_t, __SIZEOF_PTHREAD_RWLOCKATTR_T);\n\n  *attr = __pthread_default_rwlockattr;\n  return 0;\n}",
    "pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int)": "int\npthread_rwlockattr_setpshared (pthread_rwlockattr_t *attr, int pshared)\n{\n  switch (pshared)\n    {\n    case PTHREAD_PROCESS_PRIVATE:\n      attr->__pshared = pshared;\n      return 0;\n\n    case PTHREAD_PROCESS_SHARED:\n      return ENOTSUP;\n\n    default:\n      return EINVAL;\n    }\n}",
    "pthread_setconcurrency(int)": "int\npthread_setconcurrency (int new_level)\n{\n  if (new_level < 0)\n    return EINVAL;\n\n  __pthread_concurrency = new_level;\n\n  return 0;\n}",
    "pthread_setschedprio(pthread_t, int)": "int\npthread_setschedprio (pthread_t thread, int prio)\n{\n  return ENOSYS;\n}",
    "__pthread_setspecific(pthread_key_t, const void *)": "int\n__pthread_setspecific (pthread_key_t key, const void *value)\n{\n  struct __pthread *self = _pthread_self ();\n\n  if (key < 0 || key >= __pthread_key_count)\n    return EINVAL;\n\n  if (self->thread_specifics == NULL)\n    {\n      if (key < PTHREAD_STATIC_KEYS)\n\t{\n\t  self->static_thread_specifics[key] = (void *) value;\n\t  return 0;\n\t}\n    }\n\n  if (key >= self->thread_specifics_size)\n    {\n      /* Amortize reallocation cost.  */\n      int newsize = 2 * key + 1;\n      void **new;\n\n      if (self->thread_specifics == NULL)\n\t{\n\t  self->thread_specifics_size = PTHREAD_STATIC_KEYS;\n\t  new = malloc (newsize * sizeof (new[0]));\n\t  if (new != NULL)\n\t    memcpy (new, self->static_thread_specifics,\n\t\t    PTHREAD_STATIC_KEYS * sizeof (new[0]));\n\t}\n      else\n\t{\n\t  new = realloc (self->thread_specifics,\n\t\t\t newsize * sizeof (new[0]));\n\t}\n      if (new == NULL)\n\treturn ENOMEM;\n\n      memset (&new[self->thread_specifics_size], 0,\n\t      (newsize - self->thread_specifics_size) * sizeof (new[0]));\n      self->thread_specifics = new;\n      self->thread_specifics_size = newsize;\n    }\n\n  self->thread_specifics[key] = (void *) value;\n  return 0;\n}",
    "init_module()": "static void\ninit_module (void)\n{\n  int i;\n\n  INIT_LIST_HEAD (&timer_free_list);\n  INIT_LIST_HEAD (&thread_free_list);\n  INIT_LIST_HEAD (&thread_active_list);\n\n  for (i = 0; i < TIMER_MAX; ++i)\n    {\n      list_append (&timer_free_list, &__timer_array[i].links);\n      __timer_array[i].inuse = TIMER_FREE;\n    }\n\n  for (i = 0; i < THREAD_MAXNODES; ++i)\n    list_append (&thread_free_list, &thread_array[i].links);\n\n  thread_init (&__timer_signal_thread_rclk, 0, CLOCK_REALTIME);\n}",
    "strlen(const char *)": "size_t\nstrlen (const char *str)\n{\n  int cnt;\n\n  asm(\"cld\\n\"\t\t\t/* Search forward.  */\n      /* Some old versions of gas need `repne' instead of `repnz'.  */\n      \"repnz\\n\"\t\t\t/* Look for a zero byte.  */\n      \"scasb\" /* %0, %1, %3 */ :\n      \"=c\" (cnt) : \"D\" (str), \"0\" (-1), \"a\" (0));\n\n  return -2 - cnt;\n}",
    "__isinfl(long double)": "int\n__CONCATX(__,FUNC) (float_type x)\n{\n  return __m81_u(__CONCATX(__,FUNC))(x);\n}",
    "__finite(double)": "int\n__finite (double x)\n{\n  return _FCLASS (x) & ~(_FCLASS_INF | _FCLASS_NAN);\n}",
    "__fpclassify(double)": "int\n__fpclassify (double x)\n{\n  int cls = _FCLASS (x);\n  if (__builtin_expect (cls & _FCLASS_NORM, _FCLASS_NORM))\n    return FP_NORMAL;\n  if (__builtin_expect (cls & _FCLASS_ZERO, _FCLASS_ZERO))\n    return FP_ZERO;\n  if (__builtin_expect (cls & _FCLASS_SUBNORM, _FCLASS_SUBNORM))\n    return FP_SUBNORMAL;\n  if (__builtin_expect (cls & _FCLASS_INF, _FCLASS_INF))\n    return FP_INFINITE;\n  return FP_NAN;\n}",
    "__isinf(double)": "int\n__isinf (double x)\n{\n  int cls = _FCLASS (x);\n  return -((cls & _FCLASS_MINF) ? 1 : 0) | ((cls & _FCLASS_PINF) ? 1 : 0);\n}",
    "__issignaling(double)": "int\n__issignaling (double x)\n{\n  return (_FCLASS (x) & _FCLASS_SNAN) != 0;\n}",
    "__finitef128(int)": "int __finitel(_Float128 x)\n{\n\tint64_t hx;\n\tGET_LDOUBLE_MSW64(hx,x);\n\treturn (int)((uint64_t)((hx&0x7fff000000000000LL)\n\t\t\t\t-0x7fff000000000000LL)>>63);\n}",
    "__fpclassifyf128(int)": "int\n__fpclassifyl (_Float128 x)\n{\n  uint64_t hx, lx;\n  int retval = FP_NORMAL;\n\n  GET_LDOUBLE_WORDS64 (hx, lx, x);\n  lx |= (hx & 0x0000ffffffffffffLL);\n  hx &= 0x7fff000000000000LL;\n  if ((hx | lx) == 0)\n    retval = FP_ZERO;\n  else if (hx == 0)\n    retval = FP_SUBNORMAL;\n  else if (hx == 0x7fff000000000000LL)\n    retval = lx != 0 ? FP_NAN : FP_INFINITE;\n\n  return retval;\n}",
    "__isinff128(int)": "int\n__isinfl (_Float128 x)\n{\n\tint64_t hx,lx;\n\tGET_LDOUBLE_WORDS64(hx,lx,x);\n\tlx |= (hx & 0x7fffffffffffffffLL) ^ 0x7fff000000000000LL;\n\tlx |= -lx;\n\treturn ~(lx >> 63) & (hx >> 62);\n}",
    "__isnanf128(int)": "int __isnanl(_Float128 x)\n{\n\tint64_t hx,lx;\n\tGET_LDOUBLE_WORDS64(hx,lx,x);\n\thx &= 0x7fffffffffffffffLL;\n\thx |= (uint64_t)(lx|(-lx))>>63;\n\thx = 0x7fff000000000000LL - hx;\n\treturn (int)((uint64_t)hx>>63);\n}",
    "__issignalingf128(int)": "int\n__issignalingl (_Float128 x)\n{\n  uint64_t hxi, lxi __attribute__ ((unused));\n  GET_LDOUBLE_WORDS64 (hxi, lxi, x);\n#if HIGH_ORDER_BIT_IS_SET_FOR_SNAN\n  /* We only have to care about the high-order bit of x's significand, because\n     having it set (sNaN) already makes the significand different from that\n     used to designate infinity.  */\n  return ((hxi & UINT64_C (0x7fff800000000000))\n          == UINT64_C (0x7fff800000000000));\n#else\n  /* To keep the following comparison simple, toggle the quiet/signaling bit,\n     so that it is set for sNaNs.  This is inverse to IEEE 754-2008 (as well as\n     common practice for IEEE 754-1985).  */\n  hxi ^= UINT64_C (0x0000800000000000);\n  /* If lxi != 0, then set any suitable bit of the significand in hxi.  */\n  hxi |= (lxi | -lxi) >> 63;\n  /* We have to compare for greater (instead of greater or equal), because x's\n     significand being all-zero designates infinity not NaN.  */\n  return (hxi & UINT64_C (0x7fffffffffffffff)) > UINT64_C (0x7fff800000000000);\n#endif\n}",
    "__signbitf128(int)": "int\n__signbitl (_Float128 x)\n{\n  return __builtin_signbitl (x);\n}",
    "__finitef(float)": "int\n__finitef (float x)\n{\n  return _FCLASS (x) & ~(_FCLASS_INF | _FCLASS_NAN);\n}",
    "__fpclassifyf(float)": "int\n__fpclassifyf (float x)\n{\n  int cls = _FCLASS (x);\n  if (__builtin_expect (cls & _FCLASS_NORM, _FCLASS_NORM))\n    return FP_NORMAL;\n  if (__builtin_expect (cls & _FCLASS_ZERO, _FCLASS_ZERO))\n    return FP_ZERO;\n  if (__builtin_expect (cls & _FCLASS_SUBNORM, _FCLASS_SUBNORM))\n    return FP_SUBNORMAL;\n  if (__builtin_expect (cls & _FCLASS_INF, _FCLASS_INF))\n    return FP_INFINITE;\n  return FP_NAN;\n}",
    "__isinff(float)": "int\n__isinff (float x)\n{\n  int cls = _FCLASS (x);\n  return -((cls & _FCLASS_MINF) ? 1 : 0) | ((cls & _FCLASS_PINF) ? 1 : 0);\n}",
    "__isnanf(float)": "int\n__isnanf (float x)\n{\n  return (_FCLASS (x) & _FCLASS_NAN) != 0;\n}",
    "__issignalingf(float)": "int\n__issignalingf (float x)\n{\n  return (_FCLASS (x) & _FCLASS_SNAN) != 0;\n}",
    "__signbitf(float)": "int\n__signbitf (float x)\n{\n  return __builtin_signbitf (x);\n}",
    "__finitel(int)": "int __finitel(_Float128 x)\n{\n\tint64_t hx;\n\tGET_LDOUBLE_MSW64(hx,x);\n\treturn (int)((uint64_t)((hx&0x7fff000000000000LL)\n\t\t\t\t-0x7fff000000000000LL)>>63);\n}",
    "__fpclassifyl(int)": "int\n__fpclassifyl (_Float128 x)\n{\n  uint64_t hx, lx;\n  int retval = FP_NORMAL;\n\n  GET_LDOUBLE_WORDS64 (hx, lx, x);\n  lx |= (hx & 0x0000ffffffffffffLL);\n  hx &= 0x7fff000000000000LL;\n  if ((hx | lx) == 0)\n    retval = FP_ZERO;\n  else if (hx == 0)\n    retval = FP_SUBNORMAL;\n  else if (hx == 0x7fff000000000000LL)\n    retval = lx != 0 ? FP_NAN : FP_INFINITE;\n\n  return retval;\n}",
    "__isinfl(int)": "int\n__isinfl (_Float128 x)\n{\n\tint64_t hx,lx;\n\tGET_LDOUBLE_WORDS64(hx,lx,x);\n\tlx |= (hx & 0x7fffffffffffffffLL) ^ 0x7fff000000000000LL;\n\tlx |= -lx;\n\treturn ~(lx >> 63) & (hx >> 62);\n}",
    "__isnanl(int)": "int __isnanl(_Float128 x)\n{\n\tint64_t hx,lx;\n\tGET_LDOUBLE_WORDS64(hx,lx,x);\n\thx &= 0x7fffffffffffffffLL;\n\thx |= (uint64_t)(lx|(-lx))>>63;\n\thx = 0x7fff000000000000LL - hx;\n\treturn (int)((uint64_t)hx>>63);\n}",
    "__issignalingl(int)": "int\n__issignalingl (_Float128 x)\n{\n  uint64_t hxi, lxi __attribute__ ((unused));\n  GET_LDOUBLE_WORDS64 (hxi, lxi, x);\n#if HIGH_ORDER_BIT_IS_SET_FOR_SNAN\n  /* We only have to care about the high-order bit of x's significand, because\n     having it set (sNaN) already makes the significand different from that\n     used to designate infinity.  */\n  return ((hxi & UINT64_C (0x7fff800000000000))\n          == UINT64_C (0x7fff800000000000));\n#else\n  /* To keep the following comparison simple, toggle the quiet/signaling bit,\n     so that it is set for sNaNs.  This is inverse to IEEE 754-2008 (as well as\n     common practice for IEEE 754-1985).  */\n  hxi ^= UINT64_C (0x0000800000000000);\n  /* If lxi != 0, then set any suitable bit of the significand in hxi.  */\n  hxi |= (lxi | -lxi) >> 63;\n  /* We have to compare for greater (instead of greater or equal), because x's\n     significand being all-zero designates infinity not NaN.  */\n  return (hxi & UINT64_C (0x7fffffffffffffff)) > UINT64_C (0x7fff800000000000);\n#endif\n}",
    "__signbitl(int)": "int\n__signbitl (_Float128 x)\n{\n  return __builtin_signbitl (x);\n}",
    "__iscanonicall(long double)": "int\n__iscanonicall (long double x)\n{\n  uint32_t se, i0, i1 __attribute__ ((unused));\n\n  GET_LDOUBLE_WORDS (se, i0, i1, x);\n  int32_t ix = se & 0x7fff;\n  bool mant_high = (i0 & 0x80000000) != 0;\n\n  if (LDBL_MIN_EXP == -16381)\n    /* Intel variant: the high mantissa bit should have a value\n       determined by the exponent.  */\n    return ix > 0 ? mant_high : !mant_high;\n  else\n    /* M68K variant: both values of the high bit are valid for the\n       greatest and smallest exponents, while other exponents require\n       the high bit to be set.  */\n    return ix == 0 || ix == 0x7fff || mant_high;\n}",
    "__issignalingl(long double)": "int\n__issignalingl (long double x)\n{\n  uint32_t exi, hxi, lxi;\n  GET_LDOUBLE_WORDS (exi, hxi, lxi, x);\n\n  /* By default we do not recognize a pseudo NaN as sNaN.  However on 80387 and\n     later all pseudo numbers including pseudo NaNs result in a signal and are\n     hence recognized as signaling.  */\n  int ret = is_pseudo_signaling (exi, hxi);\n\n#if HIGH_ORDER_BIT_IS_SET_FOR_SNAN\n# error not implemented\n#else\n  /* To keep the following comparison simple, toggle the quiet/signaling bit,\n     so that it is set for sNaNs.  This is inverse to IEEE 754-2008 (as well as\n     common practice for IEEE 754-1985).  */\n  hxi ^= 0x40000000;\n  /* If lxi != 0, then set any suitable bit of the significand in hxi.  */\n  hxi |= (lxi | -lxi) >> 31;\n  /* We have to compare for greater (instead of greater or equal), because x's\n     significand being all-zero designates infinity not NaN.  */\n  return ret || (((exi & 0x7fff) == 0x7fff) && (hxi > 0xc0000000));\n#endif\n}",
    "__signbitl(long double)": "int\n__signbitl (long double x)\n{\n  return __builtin_signbitl (x);\n}",
    "__asprintf(char **, const char *, ...)": "attribute_hidden\nint\n__asprintf (char **string_ptr, const char *fmt, ...)\n{\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl_vasprintf (string_ptr, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__asprintf_chk(char **, int, const char *, ...)": "attribute_hidden\nint\n__asprintf_chk (char **string_ptr, int flag, const char *fmt, ...)\n{\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___vasprintf_chk (string_ptr, flag, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "dprintf(int, const char *, ...)": "attribute_hidden\nint\ndprintf (int d, const char *fmt, ...)\n{\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl_vdprintf (d, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "fprintf(FILE *, const char *, ...)": "attribute_hidden\nint\nfprintf (FILE *stream, const char *fmt, ...)\n{\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl_vfprintf (stream, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "qecvt(double, int, int *restrict, int *restrict)": "attribute_hidden\nchar *\nqecvt (double val, int ndigit, int *__restrict decpt, int *__restrict sign)\n{\n  return ecvt (val, ndigit, decpt, sign);\n}",
    "qfcvt(double, int, int *restrict, int *restrict)": "attribute_hidden\nchar *\nqfcvt (double val, int ndigit, int *__restrict decpt, int *__restrict sign)\n{\n  return fcvt (val, ndigit, decpt, sign);\n}",
    "qgcvt(double, int, char *)": "attribute_hidden\nchar *\nqgcvt (double val, int ndigit, char *buf)\n{\n  return gcvt (val, ndigit, buf);\n}",
    "vsyslog(int, const char *, va_list)": "attribute_hidden\nvoid\nvsyslog (int pri, const char *fmt, va_list ap)\n{\n  __nldbl_vsyslog (pri, fmt, ap);\n}",
    "__finitel(long double)": "int\n__CONCATX(__,FUNC) (float_type x)\n{\n  return __m81_u(__CONCATX(__,FUNC))(x);\n}",
    "__fpclassifyl(long double)": "int\n__fpclassifyl (long double x)\n{\n  uint32_t ex, hx, lx;\n  int retval = FP_NORMAL;\n\n  GET_LDOUBLE_WORDS (ex, hx, lx, x);\n  ex &= 0x7fff;\n  if ((ex | lx | hx) == 0)\n    retval = FP_ZERO;\n  else if (ex == 0 && (hx & 0x80000000) == 0)\n    retval = FP_SUBNORMAL;\n  /* Pseudo-normals, i.e. pseudo-zero, pseudo-infinity and un-normals.  They\n     behave like NaNs, so categorize them as such.  */\n  else if ((hx & 0x80000000) == 0)\n    retval = FP_NAN;\n  else if (ex == 0x7fff)\n    retval = ((hx & 0x7fffffff) | lx) != 0 ? FP_NAN : FP_INFINITE;\n\n  return retval;\n}",
    "__isnanl(long double)": "int __isnanl(long double x)\n{\n\tint32_t se,hx,lx,pn;\n\tGET_LDOUBLE_WORDS(se,hx,lx,x);\n\tse = (se & 0x7fff) << 1;\n\t/* Detect pseudo-normal numbers, i.e. exponent is non-zero and the top\n\t   bit of the significand is not set.   */\n\tpn = (uint32_t)((~hx & 0x80000000) & (se|(-se)))>>31;\n\t/* Clear the significand bit when computing mantissa.  */\n\tlx |= hx & 0x7fffffff;\n\tse |= (uint32_t)(lx|(-lx))>>31;\n\tse = 0xfffe - se;\n\n\treturn (int)(((uint32_t)(se)) >> 16) | pn;\n}",
    "__clock_gettime(clockid_t, struct timespec *)": "int\n__clock_gettime (clockid_t clock_id, struct timespec *tp)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "clock()": "clock_t\nclock (void)\n{\n  __set_errno (ENOSYS);\n  return (clock_t) -1;\n}",
    "__close_nocancel(int)": "int\n__close_nocancel (int fd)\n{\n  return INLINE_SYSCALL_CALL (close, fd);\n}",
    "fstatvfs(int, struct statvfs *)": "int\nfstatvfs (int fd, struct statvfs *buf)\n{\n  /* `struct statvfs' is in fact identical to `struct statfs' so we\n     can simply call fstatfs.  */\n  return __fstatfs (fd, (struct statfs *)buf);\n}",
    "fstatvfs64(int, struct statvfs64 *)": "int\nfstatvfs64 (int fd, struct statvfs64 *buf)\n{\n  /* `struct statvfs64' is in fact identical to `struct statfs64' so\n     we can simply call fstatfs64.  */\n  return __fstatfs64 (fd, (struct statfs64 *)buf);\n}",
    "__open_nocancel(const char *, int, ...)": "int\n__open_nocancel (const char *file, int oflag, ...)\n{\n  mode_t mode;\n  io_t port;\n\n  if (__OPEN_NEEDS_MODE (oflag))\n    {\n      va_list arg;\n      va_start (arg, oflag);\n      mode = va_arg (arg, mode_t);\n      va_end (arg);\n    }\n  else\n    mode = 0;\n\n  port = __file_name_lookup (file, oflag, mode);\n  if (port == MACH_PORT_NULL)\n    return -1;\n\n  return _hurd_intern_fd (port, oflag, 1);\n}",
    "__pread64_nocancel(int, void *, int, int)": "ssize_t\n__pread64_nocancel (int fd, void *buf, size_t count, off64_t offset)\n{\n  return INLINE_SYSCALL_CALL (pread64, fd, buf, count, SYSCALL_LL64_PRW (offset));\n}",
    "__read_nocancel(int, void *, int)": "ssize_t\n__read_nocancel (int fd, void *buf, size_t nbytes)\n{\n  return INLINE_SYSCALL_CALL (read, fd, buf, nbytes);\n}",
    "setegid(gid_t)": "int\nsetegid (gid_t gid)\n{\n  int result;\n\n  if (gid == (gid_t) ~0)\n    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);\n\n#ifdef __NR_setresgid32\n  result = INLINE_SETXID_SYSCALL (setresgid32, 3, -1, gid, -1);\n#else\n  result = INLINE_SETXID_SYSCALL (setresgid, 3, -1, gid, -1);\n#endif\n\n  return result;\n}",
    "seteuid(uid_t)": "int\nseteuid (uid_t uid)\n{\n  int result;\n\n  if (uid == (uid_t) ~0)\n    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);\n\n#ifdef __NR_setresuid32\n  result = INLINE_SETXID_SYSCALL (setresuid32, 3, -1, uid, -1);\n#else\n  result = INLINE_SETXID_SYSCALL (setresuid, 3, -1, uid, -1);\n#endif\n\n  return result;\n}",
    "__setpgid(pid_t, pid_t)": "int\n__setpgid (pid_t pid, pid_t pgid)\n{\n  error_t err;\n  unsigned int stamp;\n\n  stamp = _hurd_pids_changed_stamp; /* Atomic fetch.  */\n\n  if (err = __USEPORT (PROC, __proc_setpgrp (port, pid, pgid)))\n    return __hurd_fail (err);\n\n  if (pid == 0 || pid == _hurd_pid)\n    /* Synchronize with the signal thread to make sure we have\n       received and processed proc_newids before returning to the user.  */\n    while (_hurd_pids_changed_stamp == stamp)\n      lll_wait (_hurd_pids_changed_stamp, stamp, 0);\n\n  return 0;\n\n}",
    "sigpending(int *)": "int\nsigpending (sigset_t *set)\n{\n  struct hurd_sigstate *ss;\n  sigset_t pending;\n\n  if (set == NULL)\n    return __hurd_fail (EINVAL);\n\n  ss = _hurd_self_sigstate ();\n  _hurd_sigstate_lock (ss);\n  pending = _hurd_sigstate_pending (ss);\n  _hurd_sigstate_unlock (ss);\n\n  *set = pending;\n  return 0;\n}",
    "__sigsuspend(const int *)": "int\n__sigsuspend (const sigset_t *set)\n{\n  struct hurd_sigstate *ss;\n  sigset_t newmask, oldmask, pending;\n  mach_port_t wait;\n  mach_msg_header_t msg;\n  int cancel_oldtype;\n\n  if (set != NULL)\n    /* Crash before locking.  */\n    newmask = *set;\n\n  /* Get a fresh port we will wait on.  */\n  wait = __mach_reply_port ();\n\n  ss = _hurd_self_sigstate ();\n\n  _hurd_sigstate_lock (ss);\n\n  oldmask = ss->blocked;\n  if (set != NULL)\n    /* Change to the new blocked signal mask.  */\n    ss->blocked = newmask & ~_SIG_CANT_MASK;\n\n  /* Notice if any pending signals just became unblocked.  */\n  pending = _hurd_sigstate_pending (ss) & ~ss->blocked;\n\n  /* Tell the signal thread to message us when a signal arrives.  */\n  ss->suspended = wait;\n  _hurd_sigstate_unlock (ss);\n\n  if (pending)\n    /* Tell the signal thread to check for pending signals.  */\n    __msg_sig_post (_hurd_msgport, 0, 0, __mach_task_self ());\n\n  /* Wait for the signal thread's message.  */\n\n  cancel_oldtype = LIBC_CANCEL_ASYNC();\n  __mach_msg (&msg, MACH_RCV_MSG, 0, sizeof (msg), wait,\n\t      MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);\n  LIBC_CANCEL_RESET (cancel_oldtype);\n  __mach_port_destroy (__mach_task_self (), wait);\n\n  /* Restore the old mask and check for pending signals again.  */\n  _hurd_sigstate_lock (ss);\n  ss->blocked = oldmask;\n  pending = _hurd_sigstate_pending(ss) & ~ss->blocked;\n  _hurd_sigstate_unlock (ss);\n\n  if (pending)\n    /* Tell the signal thread to check for pending signals.  */\n    __msg_sig_post (_hurd_msgport, 0, 0, __mach_task_self ());\n\n  /* We've been interrupted!  And a good thing, too.\n     Otherwise we'd never return.\n     That's right; this function always returns an error.  */\n  return __hurd_fail (EINTR);\n}",
    "__sigtimedwait(const int *, int *, const struct timespec *)": "int\n__sigtimedwait (const sigset_t *set, siginfo_t *info,\n\t\tconst struct timespec *timeout)\n{\n  struct hurd_sigstate *ss;\n  sigset_t mask, ready, blocked;\n  int signo = 0;\n  struct hurd_signal_preemptor preemptor;\n  jmp_buf buf;\n  mach_port_t wait;\n  mach_msg_header_t msg;\n  int cancel_oldtype;\n  mach_msg_option_t option = 0;\n  mach_msg_timeout_t ms = MACH_MSG_TIMEOUT_NONE;\n\n  sighandler_t\n    preempt_fun (struct hurd_signal_preemptor *pe,\n\t\t struct hurd_sigstate *ss,\n\t\t int *sigp,\n\t\t struct hurd_signal_detail *detail)\n    {\n      if (signo)\n\t/* We've already been run; don't interfere. */\n\treturn SIG_ERR;\n\n      signo = *sigp;\n\n      if (info)\n\t{\n\t  info->si_signo = signo;\n\t  info->si_errno = detail->error;\n\t  info->si_code = detail->code;\n\n\t  /* XXX */\n\t  info->si_pid = -1;\n\t  info->si_uid = -1;\n\t  info->si_addr = (void *) NULL;\n\t  info->si_status = 0;\n\t  info->si_band = 0;\n\t  info->si_value.sival_int = 0;\n\t}\n\n      /* Make sure this is all kosher */\n      assert (__sigismember (&mask, signo));\n\n      /* Restore the blocking mask. */\n      ss->blocked = blocked;\n\n      return pe->handler;\n    }\n\n  void\n    handler (int sig)\n    {\n      assert (sig == signo);\n      longjmp (buf, 1);\n    }\n\n  wait = __mach_reply_port ();\n\n  if (set != NULL)\n    /* Crash before locking */\n    mask = *set;\n  else\n    __sigemptyset (&mask);\n\n  ss = _hurd_self_sigstate ();\n  cancel_oldtype = LIBC_CANCEL_ASYNC();\n  _hurd_sigstate_lock (ss);\n\n  /* See if one of these signals is currently pending.  */\n  sigset_t pending = _hurd_sigstate_pending (ss);\n  __sigandset (&ready, &pending, &mask);\n  if (! __sigisemptyset (&ready))\n    {\n      for (signo = 1; signo < NSIG; signo++)\n\tif (__sigismember (&ready, signo))\n\t  {\n\t    __sigdelset (&ready, signo);\n\t    goto all_done;\n\t  }\n      /* Huh?  Where'd it go? */\n      abort ();\n    }\n\n  /* Wait for one of them to show up.  */\n\n  if (!setjmp (buf))\n    {\n      /* Make the preemptor */\n      preemptor.signals = mask;\n      preemptor.first = 0;\n      preemptor.last = -1;\n      preemptor.preemptor = preempt_fun;\n      preemptor.handler = handler;\n\n      /* Install this preemptor */\n      preemptor.next = ss->preemptors;\n      ss->preemptors = &preemptor;\n\n      /* Unblock the expected signals */\n      blocked = ss->blocked;\n      ss->blocked &= ~mask;\n\n      _hurd_sigstate_unlock (ss);\n\n      if (timeout)\n\t{\n\t  option |= MACH_RCV_TIMEOUT,\n\t  ms = timeout->tv_sec * 1000\n\t     + (timeout->tv_nsec + 999999) / 1000000;\n\t}\n\n      /* Wait.  */\n      __mach_msg (&msg, MACH_RCV_MSG | option, 0, sizeof (msg), wait,\n\t\t  ms, MACH_PORT_NULL);\n\n      if (!(option & MACH_RCV_TIMEOUT))\n        abort ();\n\n      /* Timed out.  */\n      signo = __hurd_fail (EAGAIN);\n    }\n  else\n    {\n      assert (signo);\n\n      _hurd_sigstate_lock (ss);\n\n      /* Delete our preemptor. */\n      assert (ss->preemptors == &preemptor);\n      ss->preemptors = preemptor.next;\n    }\n\n\nall_done:\n  _hurd_sigstate_unlock (ss);\n  LIBC_CANCEL_RESET (cancel_oldtype);\n\n  __mach_port_destroy (__mach_task_self (), wait);\n  return signo;\n}",
    "statvfs(const char *, struct statvfs *)": "int\nstatvfs (const char *file, struct statvfs *buf)\n{\n  /* `struct statvfs' is in fact identical to `struct statfs' so we\n     can simply call statfs.  */\n  return __statfs (file, (struct statfs *)buf);\n}",
    "statvfs64(const char *, struct statvfs64 *)": "int\nstatvfs64 (const char *file, struct statvfs64 *buf)\n{\n  /* `struct statvfs64' is in fact identical to `struct statfs64' so\n     we can simply call statfs64.  */\n  return __statfs64 (file, (struct statfs64 *)buf);\n}",
    "__write_nocancel(int, const void *, int)": "ssize_t\n__write_nocancel (int fd, const void *buf, size_t nbytes)\n{\n  return INLINE_SYSCALL_CALL (write, fd, buf, nbytes);\n}",
    "pthread_mutex_consistent(pthread_mutex_t *)": "int\npthread_mutex_consistent (pthread_mutex_t *mtxp)\n{\n  int ret = EINVAL;\n  unsigned int val = mtxp->__lock;\n\n  if ((mtxp->__flags & PTHREAD_MUTEX_ROBUST) != 0\n      && (val & LLL_DEAD_OWNER) != 0\n      && atomic_compare_and_exchange_bool_acq (&mtxp->__lock,\n\t\t\t\t\t       __getpid () | LLL_WAITERS,\n\t\t\t\t\t       val) == 0)\n    {\n      /* The mutex is now ours, and it's consistent. */\n      mtxp->__owner_id = _pthread_self ()->thread;\n      mtxp->__cnt = 1;\n      ret = 0;\n    }\n\n  return ret;\n}",
    "__pthread_mutex_destroy(pthread_mutex_t *)": "int\n__pthread_mutex_destroy (pthread_mutex_t *mtxp)\n{\n  atomic_read_barrier ();\n  if (*(volatile unsigned int *) &mtxp->__lock != 0)\n    return EBUSY;\n\n  mtxp->__type = -1;\n  return 0;\n}",
    "pthread_mutex_getprioceiling(const pthread_mutex_t *, int *)": "int\npthread_mutex_getprioceiling (const pthread_mutex_t *mtxp, int *clp)\n{\n  (void) mtxp;\n  (void) clp;\n  return ENOSYS;\n}",
    "__pthread_mutex_init(pthread_mutex_t *, const pthread_mutexattr_t *)": "int\n__pthread_mutex_init (pthread_mutex_t *mtxp, const pthread_mutexattr_t *attrp)\n{\n  ASSERT_TYPE_SIZE (pthread_mutex_t, __SIZEOF_PTHREAD_MUTEX_T);\n\n  if (attrp == NULL)\n    attrp = &dfl_attr;\n\n  mtxp->__flags = (attrp->__pshared == PTHREAD_PROCESS_SHARED\n\t\t   ? GSYNC_SHARED : 0) | ((attrp->__prioceiling\n\t\t\t\t\t   & PTHREAD_MUTEX_ROBUST)\n\t\t\t\t\t  ? PTHREAD_MUTEX_ROBUST : 0);\n\n  mtxp->__type = (attrp->__mutex_type\n\t\t  + (attrp->__mutex_type != __PTHREAD_MUTEX_TIMED));\n\n  mtxp->__owner_id = 0;\n  mtxp->__shpid = 0;\n  mtxp->__cnt = 0;\n  mtxp->__lock = 0;\n\n  return 0;\n}",
    "__pthread_mutex_lock(pthread_mutex_t *)": "int\n__pthread_mutex_lock (pthread_mutex_t *mtxp)\n{\n  struct __pthread *self;\n  int flags = mtxp->__flags & GSYNC_SHARED;\n  int ret = 0;\n\n  switch (MTX_TYPE (mtxp))\n    {\n    case PT_MTX_NORMAL:\n      lll_lock (mtxp->__lock, flags);\n      break;\n\n    case PT_MTX_RECURSIVE:\n      self = _pthread_self ();\n      if (mtx_owned_p (mtxp, self, flags))\n\t{\n\t  if (__glibc_unlikely (mtxp->__cnt + 1 == 0))\n\t    return EAGAIN;\n\n\t  ++mtxp->__cnt;\n\t  return ret;\n\t}\n\n      lll_lock (mtxp->__lock, flags);\n      mtx_set_owner (mtxp, self, flags);\n      mtxp->__cnt = 1;\n      break;\n\n    case PT_MTX_ERRORCHECK:\n      self = _pthread_self ();\n      if (mtx_owned_p (mtxp, self, flags))\n\treturn EDEADLK;\n\n      lll_lock (mtxp->__lock, flags);\n      mtx_set_owner (mtxp, self, flags);\n      break;\n\n    case PT_MTX_NORMAL | PTHREAD_MUTEX_ROBUST:\n    case PT_MTX_RECURSIVE | PTHREAD_MUTEX_ROBUST:\n    case PT_MTX_ERRORCHECK | PTHREAD_MUTEX_ROBUST:\n      self = _pthread_self ();\n      ROBUST_LOCK (self, mtxp, lll_robust_lock, flags);\n      break;\n\n    default:\n      ret = EINVAL;\n      break;\n    }\n\n  return ret;\n}",
    "pthread_mutex_setprioceiling(pthread_mutex_t *, int, int *)": "int\npthread_mutex_setprioceiling (pthread_mutex_t *mtxp, int cl, int *prp)\n{\n  (void) mtxp;\n  (void) cl;\n  (void) prp;\n  return ENOSYS;\n}",
    "__pthread_mutex_trylock(pthread_mutex_t *)": "int\n__pthread_mutex_trylock (pthread_mutex_t *mtxp)\n{\n  struct __pthread *self;\n  int ret;\n\n  switch (MTX_TYPE (mtxp))\n    {\n    case PT_MTX_NORMAL:\n      ret = lll_trylock (mtxp->__lock);\n      if (ret)\n\tret = EBUSY;\n      break;\n\n    case PT_MTX_RECURSIVE:\n      self = _pthread_self ();\n      if (mtx_owned_p (mtxp, self, mtxp->__flags))\n\t{\n\t  if (__glibc_unlikely (mtxp->__cnt + 1 == 0))\n\t    return EAGAIN;\n\n\t  ++mtxp->__cnt;\n\t  ret = 0;\n\t}\n      else if ((ret = lll_trylock (mtxp->__lock)) == 0)\n\t{\n\t  mtx_set_owner (mtxp, self, mtxp->__flags);\n\t  mtxp->__cnt = 1;\n\t}\n      else\n\tret = EBUSY;\n\n      break;\n\n    case PT_MTX_ERRORCHECK:\n      self = _pthread_self ();\n      if ((ret = lll_trylock (mtxp->__lock)) == 0)\n\tmtx_set_owner (mtxp, self, mtxp->__flags);\n      else\n\tret = EBUSY;\n      break;\n\n    case PT_MTX_NORMAL | PTHREAD_MUTEX_ROBUST:\n    case PT_MTX_RECURSIVE | PTHREAD_MUTEX_ROBUST:\n    case PT_MTX_ERRORCHECK | PTHREAD_MUTEX_ROBUST:\n      self = _pthread_self ();\n      ROBUST_LOCK (self, mtxp, lll_robust_trylock);\n      break;\n\n    default:\n      ret = EINVAL;\n      break;\n    }\n\n  return ret;\n}",
    "__pthread_mutex_unlock(pthread_mutex_t *)": "int\n__pthread_mutex_unlock (pthread_mutex_t *mtxp)\n{\n  struct __pthread *self;\n  int ret = 0, flags = mtxp->__flags & GSYNC_SHARED;\n\n  switch (MTX_TYPE (mtxp))\n    {\n    case PT_MTX_NORMAL:\n      lll_unlock (mtxp->__lock, flags);\n      break;\n\n    case PT_MTX_RECURSIVE:\n      self = _pthread_self ();\n      if (!mtx_owned_p (mtxp, self, flags))\n\tret = EPERM;\n      else if (--mtxp->__cnt == 0)\n\t{\n\t  mtxp->__owner_id = mtxp->__shpid = 0;\n\t  lll_unlock (mtxp->__lock, flags);\n\t}\n\n      break;\n\n    case PT_MTX_ERRORCHECK:\n      self = _pthread_self ();\n      if (!mtx_owned_p (mtxp, self, flags))\n\tret = EPERM;\n      else\n\t{\n\t  mtxp->__owner_id = mtxp->__shpid = 0;\n\t  lll_unlock (mtxp->__lock, flags);\n\t}\n\n      break;\n\n    case PT_MTX_NORMAL | PTHREAD_MUTEX_ROBUST:\n    case PT_MTX_RECURSIVE | PTHREAD_MUTEX_ROBUST:\n    case PT_MTX_ERRORCHECK | PTHREAD_MUTEX_ROBUST:\n      self = _pthread_self ();\n      if (mtxp->__owner_id == NOTRECOVERABLE_ID)\n\t;\t\t\t/* Nothing to do. */\n      else if (mtxp->__owner_id != self->thread\n\t       || (int) (mtxp->__lock & LLL_OWNER_MASK) != __getpid ())\n\tret = EPERM;\n      else if (--mtxp->__cnt == 0)\n\t{\n\t  /* Release the lock. If it's in an inconsistent\n\t   * state, mark it as irrecoverable. */\n\t  mtxp->__owner_id = ((mtxp->__lock & LLL_DEAD_OWNER)\n\t\t\t      ? NOTRECOVERABLE_ID : 0);\n\t  lll_robust_unlock (mtxp->__lock, flags);\n\t}\n\n      break;\n\n    default:\n      ret = EINVAL;\n      break;\n    }\n\n  return ret;\n}",
    "__pthread_mutexattr_destroy(pthread_mutexattr_t *)": "int\n__pthread_mutexattr_destroy (pthread_mutexattr_t *attrp)\n{\n  (void) attrp;\n  return 0;\n}",
    "pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *, int *)": "int\npthread_mutexattr_getprioceiling (const pthread_mutexattr_t *ap, int *clp)\n{\n  (void) ap;\n  (void) clp;\n  return ENOSYS;\n}",
    "pthread_mutexattr_getprotocol(const pthread_mutexattr_t *, int *)": "int\npthread_mutexattr_getprotocol (const pthread_mutexattr_t *attrp, int *ptp)\n{\n  *ptp = attrp->__protocol;\n  return 0;\n}",
    "pthread_mutexattr_getpshared(const pthread_mutexattr_t *, int *)": "int\npthread_mutexattr_getpshared (const pthread_mutexattr_t *attrp, int *outp)\n{\n  *outp = attrp->__pshared;\n  return 0;\n}",
    "pthread_mutexattr_getrobust(const pthread_mutexattr_t *, int *)": "int\npthread_mutexattr_getrobust (const pthread_mutexattr_t *attrp, int *outp)\n{\n  *outp = ((attrp->__prioceiling & PTHREAD_MUTEX_ROBUST)\n\t   ? PTHREAD_MUTEX_ROBUST : PTHREAD_MUTEX_STALLED);\n  return 0;\n}",
    "pthread_mutexattr_gettype(const pthread_mutexattr_t *, int *)": "int\npthread_mutexattr_gettype (const pthread_mutexattr_t *attrp, int *outp)\n{\n  *outp = attrp->__mutex_type;\n  return 0;\n}",
    "__pthread_mutexattr_init(pthread_mutexattr_t *)": "int\n__pthread_mutexattr_init (pthread_mutexattr_t *attrp)\n{\n  ASSERT_TYPE_SIZE (pthread_mutexattr_t, __SIZEOF_PTHREAD_MUTEXATTR_T);\n\n  *attrp = dfl_attr;\n  return 0;\n}",
    "pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int)": "int\npthread_mutexattr_setprioceiling (pthread_mutexattr_t *attrp, int cl)\n{\n  (void) attrp;\n  (void) cl;\n  return ENOSYS;\n}",
    "pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int)": "int\npthread_mutexattr_setprotocol (pthread_mutexattr_t *attrp, int proto)\n{\n  (void) attrp;\n  return (proto == PTHREAD_PRIO_NONE\n\t  ? 0\n\t  : (proto != PTHREAD_PRIO_INHERIT\n\t     && proto != PTHREAD_PRIO_PROTECT) ? EINVAL : ENOTSUP);\n}",
    "pthread_mutexattr_setpshared(pthread_mutexattr_t *, int)": "int\npthread_mutexattr_setpshared (pthread_mutexattr_t *attrp, int pshared)\n{\n  if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED)\n    return EINVAL;\n\n  attrp->__pshared = pshared;\n  return 0;\n}",
    "pthread_mutexattr_setrobust(pthread_mutexattr_t *, int)": "int\npthread_mutexattr_setrobust (pthread_mutexattr_t *attrp, int robust)\n{\n  if (robust != PTHREAD_MUTEX_ROBUST && robust != PTHREAD_MUTEX_STALLED)\n    return EINVAL;\n\n  attrp->__prioceiling |= robust;\n  return 0;\n}",
    "__pthread_mutexattr_settype(pthread_mutexattr_t *, int)": "int\n__pthread_mutexattr_settype (pthread_mutexattr_t *attrp, int type)\n{\n  if (type < 0 || type > __PTHREAD_MUTEX_RECURSIVE)\n    return EINVAL;\n\n  attrp->__mutex_type = type;\n  return 0;\n}",
    "ioperm(unsigned long, unsigned long, int)": "int\nioperm (unsigned long int from, unsigned long int num, int turn_on)\n{\n#if ! HAVE_I386_IO_PERM_MODIFY\n  return __hurd_fail (ENOSYS);\n#else\n  error_t err;\n  device_t devmaster;\n\n  /* With the device master port we get a capability that represents\n     this range of io ports.  */\n  err = __get_privileged_ports (NULL, &devmaster);\n  if (! err)\n    {\n      io_perm_t perm;\n      err = __i386_io_perm_create (devmaster, from, from + num - 1, &perm);\n      __mach_port_deallocate (__mach_task_self (), devmaster);\n      if (! err)\n\t{\n\t  /* Now we add or remove that set from our task's bitmap.  */\n\t  err = __i386_io_perm_modify (__mach_task_self (), perm, turn_on);\n\t  __mach_port_deallocate (__mach_task_self (), perm);\n\t}\n\n      if (err == MIG_BAD_ID)\t/* Old kernels don't have these RPCs.  */\n\terr = ENOSYS;\n    }\n\n  return err ? __hurd_fail (err) : 0;\n#endif\n}",
    "euidaccess(const char *, int)": "int\neuidaccess (const char *path, int mode)\n{\n  struct __stat64_t64 stats;\n  int granted;\n\n#ifdef\t_LIBC\n  uid_t euid;\n  gid_t egid;\n#else\n  if (have_ids == 0)\n    {\n      have_ids = 1;\n      uid = getuid ();\n      gid = getgid ();\n      euid = geteuid ();\n      egid = getegid ();\n    }\n\n  if (uid == euid && gid == egid)\n    /* If we are not set-uid or set-gid, access does the same.  */\n    return access (path, mode);\n#endif\n\n  if (__stat64_time64 (path, &stats))\n    return -1;\n\n  mode &= (X_OK | W_OK | R_OK);\t/* Clear any bogus bits. */\n#if R_OK != S_IROTH || W_OK != S_IWOTH || X_OK != S_IXOTH\n  ?error Oops, portability assumptions incorrect.\n#endif\n\n  if (mode == F_OK)\n    return 0;\t\t\t/* The file exists. */\n\n#ifdef\t_LIBC\n  /* Now we need the IDs.  */\n  euid = __geteuid ();\n  egid = __getegid ();\n\n  if (__getuid () == euid && __getgid () == egid)\n    /* If we are not set-uid or set-gid, access does the same.  */\n    return __access (path, mode);\n#endif\n\n  /* The super-user can read and write any file, and execute any file\n     that anyone can execute. */\n  if (euid == 0 && ((mode & X_OK) == 0\n\t\t    || (stats.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))))\n    return 0;\n\n  if (euid == stats.st_uid)\n    granted = (unsigned int) (stats.st_mode & (mode << 6)) >> 6;\n  else if (egid == stats.st_gid || group_member (stats.st_gid))\n    granted = (unsigned int) (stats.st_mode & (mode << 3)) >> 3;\n  else\n    granted = (stats.st_mode & mode);\n  /* XXX Add support for ACLs.  */\n  if (granted == mode)\n    return 0;\n  __set_errno (EACCESS);\n  return -1;\n}",
    "cnd_timedwait(cnd_t *restrict, mtx_t *restrict, const struct timespec *restrict)": "int\ncnd_timedwait (cnd_t *restrict cond, mtx_t *restrict mutex,\n\t       const struct timespec* restrict time_point)\n{\n  int err_code = __pthread_cond_timedwait ((pthread_cond_t *) cond,\n\t\t\t\t\t   (pthread_mutex_t *) mutex,\n\t\t\t\t\t   time_point);\n  return thrd_err_map (err_code);\n}",
    "mtx_timedlock(mtx_t *restrict, const struct timespec *restrict)": "int\nmtx_timedlock (mtx_t *restrict mutex,\n\t       const struct timespec *restrict time_point)\n{\n  int err_code = __pthread_mutex_timedlock ((pthread_mutex_t *)mutex,\n\t\t\t\t\t    time_point);\n  return thrd_err_map (err_code);\n}",
    "thrd_equal(thrd_t, thrd_t)": "int\nthrd_equal (thrd_t lhs, thrd_t rhs)\n{\n  return lhs == rhs;\n}",
    "thrd_sleep(const struct timespec *, struct timespec *)": "int\nthrd_sleep (const struct timespec* time_point, struct timespec* remaining)\n{\n  int ret = __clock_nanosleep (CLOCK_REALTIME, 0, time_point, remaining);\n  /* C11 states thrd_sleep function returns -1 if it has been interrupted\n     by a signal, or a negative value if it fails.  */\n  switch (ret)\n  {\n     case 0:      return 0;\n     case EINTR:  return -1;\n     default:     return -2;\n  }\n}",
    "tcflow(int, int)": "int\ntcflow (int fd, int action)\n{\n  if (fd < 0)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  switch (action)\n    {\n    case TCOOFF:\n    case TCOON:\n    case TCIOFF:\n    case TCION:\n      break;\n\n    default:\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "tcflush(int, int)": "int\ntcflush (int fd, int queue_selector)\n{\n  switch (queue_selector)\n    {\n    case TCIFLUSH:\n    case TCOFLUSH:\n    case TCIOFLUSH:\n      break;\n\n    default:\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "tcgetpgrp(int)": "pid_t\ntcgetpgrp (int fd)\n{\n  if (fd < 0)\n    {\n      __set_errno (EBADF);\n      return (pid_t) -1;\n    }\n\n  __set_errno (ENOSYS);\n  return (pid_t) -1;\n}",
    "tcsendbreak(int, int)": "int\ntcsendbreak (int fd, int duration)\n{\n  if (fd < 0)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "tcsetattr(int, int, const struct termios *)": "int\ntcsetattr (int fd, int optional_actions, const struct termios *termios_p)\n{\n  if (fd < 0)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n  if (termios_p == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  switch (optional_actions)\n    {\n    case TCSANOW:\n    case TCSADRAIN:\n    case TCSAFLUSH:\n      break;\n    default:\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (bad_speed(termios_p->__ospeed)\n      || bad_speed(termios_p->__ispeed == 0\n\t\t   ? termios_p->__ospeed : termios_p->__ispeed))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__cmsg_nxthdr(struct msghdr *, struct cmsghdr *)": "struct cmsghdr *\n__cmsg_nxthdr (struct msghdr *mhdr, struct cmsghdr *cmsg)\n{\n  /* We may safely assume that cmsg lies between mhdr->msg_control and\n     mhdr->msg_controllen because the user is required to obtain the first\n     cmsg via CMSG_FIRSTHDR, set its length, then obtain subsequent cmsgs\n     via CMSG_NXTHDR, setting lengths along the way.  However, we don't yet\n     trust the value of cmsg->cmsg_len and therefore do not use it in any\n     pointer arithmetic until we check its value.  */\n\n  unsigned char * msg_control_ptr = (unsigned char *) mhdr->msg_control;\n  unsigned char * cmsg_ptr = (unsigned char *) cmsg;\n\n  size_t size_needed = sizeof (struct cmsghdr)\n                       + __CMSG_PADDING (cmsg->cmsg_len);\n\n  /* The current header is malformed, too small to be a full header.  */\n  if ((size_t) cmsg->cmsg_len < sizeof (struct cmsghdr))\n    return (struct cmsghdr *) 0;\n\n  /* There isn't enough space between cmsg and the end of the buffer to\n  hold the current cmsg *and* the next one.  */\n  if (((size_t)\n         (msg_control_ptr + mhdr->msg_controllen - cmsg_ptr)\n       < size_needed)\n      || ((size_t)\n            (msg_control_ptr + mhdr->msg_controllen - cmsg_ptr\n             - size_needed)\n          < cmsg->cmsg_len))\n\n    return (struct cmsghdr *) 0;\n\n  /* Now, we trust cmsg_len and can use it to find the next header.  */\n  cmsg = (struct cmsghdr *) ((unsigned char *) cmsg\n\t\t\t     + CMSG_ALIGN (cmsg->cmsg_len));\n  return cmsg;\n}",
    "openat64(int, const char *, int, ...)": "int\nopenat64 (int dfd, const char *file, int oflag, ...)\n{\n  assert (!__OPEN_NEEDS_MODE (oflag));\n\n  return INLINE_SYSCALL (openat, 3, dfd, file, oflag | O_LARGEFILE);\n}",
    "eventfd_read(int, eventfd_t *)": "int\neventfd_read (int fd, eventfd_t *value)\n{\n  return __read (fd, value, sizeof (eventfd_t)) != sizeof (eventfd_t) ? -1 : 0;\n}",
    "eventfd_write(int, eventfd_t)": "int\neventfd_write (int fd, eventfd_t value)\n{\n  return __write (fd, &value,\n\t\t  sizeof (eventfd_t)) != sizeof (eventfd_t) ? -1 : 0;\n}",
    "execveat(int, const char *, char *const *, char *const *, int)": "int\nexecveat (int dirfd, const char *path, char *const argv[], char *const envp[],\n          int flags)\n{\n  /* Avoid implicit array coercion in syscall macros.  */\n  return INLINE_SYSCALL_CALL (execveat, dirfd, path, &argv[0], &envp[0],\n\t\t\t      flags);\n}",
    "listen(int, int)": "int\nlisten (int fd, int backlog)\n{\n#ifdef __ASSUME_LISTEN_SYSCALL\n  return INLINE_SYSCALL_CALL (listen, fd, backlog);\n#else\n  return SOCKETCALL (listen, fd, backlog);\n#endif\n}",
    "mlock2(const void *, int, unsigned int)": "int\nmlock2 (const void *addr, size_t length, unsigned int flags)\n{\n#ifdef __ASSUME_MLOCK2\n  return INLINE_SYSCALL_CALL (mlock2, addr, length, flags);\n#else\n  if (flags == 0)\n    return INLINE_SYSCALL_CALL (mlock, addr, length);\n  int ret = INLINE_SYSCALL_CALL (mlock2, addr, length, flags);\n  if (ret == 0 || errno != ENOSYS)\n    return ret;\n  /* Treat the missing system call as an invalid (non-zero) flag\n     argument.  */\n  __set_errno (EINVAL);\n  return -1;\n#endif /* __ASSUME_MLOCK2 */\n}",
    "msgget(key_t, int)": "int\nmsgget (key_t key, int msgflg)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__netlink_assert_response(int, ssize_t)": "void\n__netlink_assert_response (int fd, ssize_t result)\n{\n  if (result < 0)\n    {\n      /* Check if the error is unexpected.  */\n      bool terminate = false;\n      int error_code = errno;\n      int family = get_address_family (fd);\n      if (family != AF_NETLINK)\n        /* If the address family does not match (or getsockname\n           failed), report the original error.  */\n        terminate = true;\n      else if (error_code == EBADF\n          || error_code == ENOTCONN\n          || error_code == ENOTSOCK\n          || error_code == ECONNREFUSED)\n        /* These errors indicate that the descriptor is not a\n           connected socket.  */\n        terminate = true;\n      else if (error_code == EAGAIN || error_code == EWOULDBLOCK)\n        {\n          /* The kernel might return EAGAIN for other reasons than a\n             non-blocking socket.  But if the socket is not blocking,\n             it is not ours, so report the error.  */\n          int mode = __fcntl (fd, F_GETFL, 0);\n          if (mode < 0 || (mode & O_NONBLOCK) != 0)\n            terminate = true;\n        }\n      if (terminate)\n        {\n          char message[200];\n          if (family < 0)\n            __snprintf (message, sizeof (message),\n                        \"Unexpected error %d on netlink descriptor %d.\\n\",\n                        error_code, fd);\n          else\n            __snprintf (message, sizeof (message),\n                        \"Unexpected error %d on netlink descriptor %d\"\n                        \" (address family %d).\\n\",\n                        error_code, fd, family);\n          __libc_fatal (message);\n        }\n      else\n        /* Restore original errno value.  */\n        __set_errno (error_code);\n    }\n  else if (result < sizeof (struct nlmsghdr))\n    {\n      char message[200];\n      int family = get_address_family (fd);\n      if (family < 0)\n          __snprintf (message, sizeof (message),\n                      \"Unexpected netlink response of size %zd\"\n                      \" on descriptor %d\\n\",\n                      result, fd);\n      else\n          __snprintf (message, sizeof (message),\n                      \"Unexpected netlink response of size %zd\"\n                      \" on descriptor %d (address family %d)\\n\",\n                      result, fd, family);\n      __libc_fatal (message);\n    }\n}",
    "__open64_nocancel(const char *, int, ...)": "int\n__open64_nocancel (const char *file, int oflag, ...)\n{\n  int mode = 0;\n\n  if (__OPEN_NEEDS_MODE (oflag))\n    {\n      va_list arg;\n      va_start (arg, oflag);\n      mode = va_arg (arg, int);\n      va_end (arg);\n    }\n\n  return INLINE_SYSCALL_CALL (openat, AT_FDCWD, file, oflag | O_LARGEFILE,\n\t\t\t      mode);\n}",
    "pidfd_getpid(int)": "pid_t\npidfd_getpid (int fd)\n{\n  if (__glibc_unlikely (fd < 0))\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  char fdinfoname[FDINFO_FILENAME_LEN];\n\n  char *p = mempcpy (fdinfoname, FDINFO_TO_FILENAME_PREFIX,\n\t\t     strlen (FDINFO_TO_FILENAME_PREFIX));\n  *_fitoa_word (fd, p, 10, 0) = '\\0';\n\n  struct parse_fdinfo_t fdinfo = { .found = false, .pid = -1 };\n  if (!procutils_read_file (fdinfoname, parse_fdinfo, &fdinfo))\n    /* The fdinfo contains an invalid 'Pid:' value.  */\n    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EBADF);\n\n  /* The FD does not have a 'Pid:' entry associated.  */\n  if (!fdinfo.found)\n    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EBADF);\n\n  /* The pidfd cannot be resolved because it is in a separate pid\n     namespace.  */\n  if (fdinfo.pid == 0)\n    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EREMOTE);\n\n  /* A negative value means the process is terminated.  */\n  if (fdinfo.pid < 0)\n    return INLINE_SYSCALL_ERROR_RETURN_VALUE (ESRCH);\n\n  return fdinfo.pid;\n}",
    "pidfd_spawn(int *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const *, char *const *)": "int\npidfd_spawn (int *pidfd, const char *path,\n\t     const posix_spawn_file_actions_t *file_actions,\n\t     const posix_spawnattr_t *attrp, char *const argv[],\n\t     char *const envp[])\n{\n  return __spawni (pidfd, path, file_actions, attrp, argv, envp,\n\t\t   SPAWN_XFLAGS_RET_PIDFD);\n}",
    "pidfd_spawnp(int *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const *, char *const *)": "int\npidfd_spawnp (int *pidfd, const char *path,\n\t      const posix_spawn_file_actions_t *file_actions,\n\t      const posix_spawnattr_t *attrp, char *const argv[],\n\t      char *const envp[])\n{\n  return __spawni (pidfd, path, file_actions, attrp, argv, envp,\n\t\t   SPAWN_XFLAGS_USE_PATH | SPAWN_XFLAGS_RET_PIDFD);\n}",
    "pkey_get(int)": "int\npkey_get (int key)\n{\n  if (key < 0 || key > 15)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  unsigned int pkru = pkey_read ();\n  return (pkru >> (2 * key)) & 3;\n  return 0;\n}",
    "pkey_mprotect(void *, int, int, int)": "int\npkey_mprotect (void *addr, size_t len, int prot, int pkey)\n{\n  if (pkey == -1)\n    /* If the key is -1, the system call is precisely equivalent to\n       mprotect.  */\n    return __mprotect (addr, len, prot);\n  return INLINE_SYSCALL_CALL (pkey_mprotect, addr, len, prot, pkey);\n}",
    "pkey_set(int, unsigned int)": "int\npkey_set (int key, unsigned int rights)\n{\n  if (key < 0 || key > 15 || rights > 3)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  unsigned int mask = 3 << (2 * key);\n  unsigned int pkru = pkey_read ();\n  pkru = (pkru & ~mask) | (rights << (2 * key));\n  pkey_write (pkru);\n  return 0;\n}",
    "process_vm_readv(pid_t, const struct iovec *, unsigned long, const struct iovec *, unsigned long, unsigned long)": "ssize_t\nprocess_vm_readv (pid_t pid, const struct iovec *local_iov,\n\t\t  unsigned long int liovcnt,\n\t\t  const struct iovec *remote_iov,\n\t\t  unsigned long int riovcnt, unsigned long int flags)\n{\n  return INLINE_SYSCALL_CALL (process_vm_readv, pid, local_iov,\n\t\t\t      liovcnt, remote_iov, riovcnt, flags);\n}",
    "process_vm_writev(pid_t, const struct iovec *, unsigned long, const struct iovec *, unsigned long, unsigned long)": "ssize_t\nprocess_vm_writev (pid_t pid, const struct iovec *local_iov,\n\t\t   unsigned long int liovcnt,\n\t\t   const struct iovec *remote_iov,\n\t\t   unsigned long int riovcnt, unsigned long int flags)\n{\n  return INLINE_SYSCALL_CALL (process_vm_writev, pid, local_iov,\n\t\t\t      liovcnt, remote_iov, riovcnt, flags);\n}",
    "sched_getcpu()": "int\nsched_getcpu (void)\n{\n  return vsyscall_sched_getcpu ();\n}",
    "semget(key_t, int, int)": "int\nsemget (key_t key, int nsems, int semflg)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "semop(int, struct sembuf *, int)": "int\nsemop (int semid, struct sembuf *sops, size_t nsops)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "shmat(int, const void *, int)": "void *\nshmat (int shmid, const void *shmaddr, int shmflg)\n{\n  __set_errno (ENOSYS);\n  return (void *) -1;\n}",
    "shmdt(const void *)": "int\nshmdt (const void *shmaddr)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "shmget(key_t, int, int)": "int\nshmget (key_t key, size_t size, int shmflg)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "signalfd(int, const sigset_t *, int)": "int\nsignalfd (int fd, const sigset_t *mask, int flags)\n{\n  return INLINE_SYSCALL (signalfd4, 4, fd, mask, __NSIG_BYTES, flags);\n}",
    "__sigismember(const sigset_t *, int)": "static inline int\n__sigismember (const sigset_t *set, int sig)\n{\n  unsigned long int mask = __sigmask (sig);\n  unsigned long int word = __sigword (sig);\n  return set->__val[word] & mask ? 1 : 0;\n}",
    "__sigaddset(sigset_t *, int)": "static inline void\n__sigaddset (sigset_t *set, int sig)\n{\n  unsigned long int mask = __sigmask (sig);\n  unsigned long int word = __sigword (sig);\n  set->__val[word] |= mask;\n}",
    "__sigdelset(sigset_t *, int)": "static inline void\n__sigdelset (sigset_t *set, int sig)\n{\n  unsigned long int mask = __sigmask (sig);\n  unsigned long int word = __sigword (sig);\n  set->__val[word] &= ~mask;\n}",
    "posix_spawnattr_getcgroup_np(const posix_spawnattr_t *, int *)": "int\nposix_spawnattr_getcgroup_np (const posix_spawnattr_t *attr,\n\t\t\t      int *cgroup)\n{\n  *cgroup = attr->__cgroup;\n\n  return 0;\n}",
    "posix_spawnattr_setcgroup_np(posix_spawnattr_t *, int)": "int\nposix_spawnattr_setcgroup_np (posix_spawnattr_t *attr, int cgroup)\n{\n  attr->__cgroup = cgroup;\n\n  return 0;\n}",
    "cfgetospeed(const struct termios *)": "speed_t\ncfgetospeed (const struct termios *termios_p)\n{\n  return termios_p->__ospeed;\n}",
    "cfgetispeed(const struct termios *)": "speed_t\ncfgetispeed (const struct termios *termios_p)\n{\n  return termios_p->__ispeed;\n}",
    "cfsetospeed(struct termios *, speed_t)": "int\ncfsetospeed (struct termios *termios_p, speed_t speed)\n{\n  if (termios_p == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  termios_p->__ospeed = speed;\n  return 0;\n}",
    "__fxstat64(int, int, struct stat64 *)": "int\n__fxstat64 (int vers, int fd, struct stat64 *buf)\n{\n  struct kernel_stat kbuf;\n  int r = INLINE_SYSCALL_CALL (fstat, fd, &kbuf);\n  return r ?: __xstat64_conv (vers, &kbuf, buf);\n\n}",
    "__fxstatat64(int, int, const char *, struct stat64 *, int)": "int\n__fxstatat64 (int vers, int fd, const char *file, struct stat64 *st, int flag)\n{\n  if (vers == _STAT_VER_LINUX)\n    {\n      struct kernel_stat kst;\n      int r = INLINE_SYSCALL_CALL (newfstatat, fd, file, &kst, flag);;\n      return r ?: __xstat64_conv (vers, &kst, st);\n    }\n  return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);\n}",
    "__lxstat64(int, const char *, struct stat64 *)": "int\n__lxstat64 (int vers, const char *name, struct stat64 *buf)\n{\n  struct kernel_stat kbuf;\n  int r = INLINE_SYSCALL_CALL (lstat, name, &kbuf);\n  return r ?: __xstat64_conv (vers, &kbuf, buf);\n}",
    "__xstat64(int, const char *, struct stat64 *)": "int\n__xstat64 (int vers, const char *name, struct stat64 *buf)\n{\n  struct kernel_stat kbuf;\n  int r = INLINE_SYSCALL_CALL (stat, name, &kbuf);\n  return r ?: __xstat64_conv (vers, &kbuf, buf);\n}",
    "__fxstat(int, int, struct stat *)": "int\n__fxstat (int vers, int fd, struct stat *buf)\n{\n  switch (vers)\n    {\n    case _STAT_VER_KERNEL:\n      return INLINE_SYSCALL_CALL (fstat, fd, buf);\n\n    default:\n      {\n\tstruct kernel_stat kbuf;\n\tint r = INTERNAL_SYSCALL_CALL (fstat, fd, &kbuf);\n\tif (r == 0)\n\t  return  __xstat_conv (vers, &kbuf, buf);\n\treturn INLINE_SYSCALL_ERROR_RETURN_VALUE (-r);\n      }\n    }\n}",
    "__lxstat(int, const char *, struct stat *)": "int\n__lxstat (int vers, const char *name, struct stat *buf)\n{\n  switch (vers)\n    {\n    case _STAT_VER_KERNEL:\n      return INLINE_SYSCALL_CALL (lstat, name, buf);\n\n    default:\n      {\n\tstruct kernel_stat kbuf;\n\tint r = INTERNAL_SYSCALL_CALL (lstat, name, &kbuf);\n\tif (r == 0)\n\t  return  __xstat_conv (vers, &kbuf, buf);\n\treturn INLINE_SYSCALL_ERROR_RETURN_VALUE (-r);\n      }\n    }\n}",
    "__xstat(int, const char *, struct stat *)": "int\n__xstat (int vers, const char *name, struct stat *buf)\n{\n  switch (vers)\n    {\n    case _STAT_VER_KERNEL:\n      return INLINE_SYSCALL_CALL (stat, name, buf);\n\n    default:\n      {\n\tstruct kernel_stat kbuf;\n\tint r = INTERNAL_SYSCALL_CALL (stat, name, &kbuf);\n\tif (r == 0)\n\t  return  __xstat_conv (vers, &kbuf, buf);\n\treturn INLINE_SYSCALL_ERROR_RETURN_VALUE (-r);\n      }\n    }\n}",
    "__fxstatat(int, int, const char *, struct stat *, int)": "int\n__fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)\n{\n  struct kernel_stat kst;\n  int r = INLINE_SYSCALL_CALL (newfstatat, fd, file, &kst, flag);\n  return r ?: __xstat_conv (vers, &kst, st);\n}",
    "__lseek(int, off_t, int)": "off_t\n__lseek (int fd, off_t offset, int whence)\n{\n  off64_t res = __lseek64 (fd, offset, whence);\n  if (res != (off_t) res)\n    {\n      __set_errno (EOVERFLOW);\n      return (off_t) -1;\n    }\n  return (off_t) res;\n}",
    "__clone(int (*)(void *), void *, int, void *, ...)": "int\n__clone (int (*fn)(void *), void *child_stack,\n\t int flags, void *arg, ...\n\t /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */ )\n{\n  void *ptid;\n  void *tls;\n  void *ctid;\n  va_list ap;\n  int err;\n\n  va_start (ap, arg);\n  ptid = va_arg (ap, void *);\n  tls = va_arg (ap, void *);\n  ctid = va_arg (ap, void *);\n  va_end (ap);\n\n  /* Sanity check the arguments */\n  err = -EINVAL;\n  if (!fn)\n    goto syscall_error;\n  if (!child_stack)\n    goto syscall_error;\n\n  return __or1k_clone (fn, child_stack, flags, arg, ptid, tls, ctid);\n\nsyscall_error:\n  __set_errno (-err);\n  return -1;\n}",
    "syscall(long, long, long, long, long, long, long, long)": "long int\nsyscall (long int syscall_number, long int arg1, long int arg2, long int arg3,\n\t long int arg4, long int arg5, long int arg6, long int arg7)\n{\n  long int ret;\n\n  ret = INTERNAL_SYSCALL_NCS_CALL (syscall_number, arg1, arg2, arg3, arg4,\n\t\t\t\t   arg5, arg6, arg7);\n\n  if (INTERNAL_SYSCALL_ERROR_P (ret))\n    return __syscall_error (ret);\n\n  return ret;\n}",
    "__arch_prctl(int, uintptr_t *)": "int\n__arch_prctl (int code, uintptr_t *addr)\n{\n  int res;\n  uint64_t addr64;\n  void *prctl_arg = addr;\n\n  switch (code)\n    {\n    case ARCH_GET_FS:\n    case ARCH_GET_GS:\n      prctl_arg = &addr64;\n      break;\n    }\n\n  res = INLINE_SYSCALL (arch_prctl, 2, code, prctl_arg);\n  if (res == 0)\n    switch (code)\n      {\n      case ARCH_GET_FS:\n      case ARCH_GET_GS:\n\t /* Check for a large value that overflows.  */\n\tif ((uintptr_t) addr64 != addr64)\n\t  {\n\t    __set_errno (EOVERFLOW);\n\t    return -1;\n\t  }\n\t*addr = (uintptr_t) addr64;\n\tbreak;\n      }\n\n  return res;\n}",
    "__x86_get_cpuid_feature_leaf(unsigned int)": "const struct cpuid_feature *\n__x86_get_cpuid_feature_leaf (unsigned int leaf)\n{\n  static const struct cpuid_feature feature = {};\n  if (leaf < CPUID_INDEX_MAX)\n    return ((const struct cpuid_feature *)\n\t    &GLRO(dl_x86_cpu_features).features[leaf]);\n  else\n    return &feature;\n}",
    "ftok(const char *, int)": "key_t\nftok (const char *pathname, int proj_id)\n{\n  struct __stat64_t64 st;\n  key_t key;\n\n  if (__stat64_time64 (pathname, &st) < 0)\n    return (key_t) -1;\n\n  key = ((st.st_ino & 0xffff) | ((st.st_dev & 0xff) << 16)\n\t | ((proj_id & 0xff) << 24));\n\n  return key;\n}",
    "msgctl(int, int, struct msqid_ds *)": "int\nmsgctl (int msqid, int cmd, struct msqid_ds *buf)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "msgrcv(int, void *, int, long, int)": "ssize_t\nmsgrcv (int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "msgsnd(int, const void *, int, int)": "int\nmsgsnd (int msqid, const void *msgp, size_t msgsz, int msgflg)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "semctl(int, int, int, ...)": "int\nsemctl (int semid, int semnum, int cmd, ...)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "shmctl(int, int, struct shmid_ds *)": "int\nshmctl (int shmid, int cmd, struct shmid_ds *buf)\n{\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "cfmakeraw(struct termios *)": "void\ncfmakeraw (struct termios *t)\n{\n  t->c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL|IXON);\n  t->c_oflag &= ~OPOST;\n  t->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);\n  t->c_cflag &= ~(CSIZE|PARENB);\n  t->c_cflag |= CS8;\n  t->c_cc[VMIN] = 1;\t\t/* read returns when one char is available.  */\n  t->c_cc[VTIME] = 0;\n}",
    "cfsetspeed(struct termios *, speed_t)": "int\ncfsetspeed (struct termios *termios_p, speed_t speed)\n{\n  size_t cnt;\n\n  for (cnt = 0; cnt < sizeof (speeds) / sizeof (speeds[0]); ++cnt)\n    if (speed == speeds[cnt].internal)\n      {\n\tcfsetispeed (termios_p, speed);\n\tcfsetospeed (termios_p, speed);\n\treturn 0;\n      }\n    else if (speed == speeds[cnt].value)\n      {\n\tcfsetispeed (termios_p, speeds[cnt].internal);\n\tcfsetospeed (termios_p, speeds[cnt].internal);\n\treturn 0;\n      }\n\n  __set_errno (EINVAL);\n\n  return -1;\n}",
    "tcgetsid(int)": "pid_t\ntcgetsid (int fd)\n{\n  pid_t pgrp;\n  pid_t sid;\n#ifdef TIOCGSID\n  static int tiocgsid_does_not_work;\n\n  if (! tiocgsid_does_not_work)\n    {\n      int serrno = errno;\n      int sid;\n\n      if (__ioctl (fd, TIOCGSID, &sid) < 0)\n\t{\n\t  if (errno == EINVAL)\n\t    {\n\t      tiocgsid_does_not_work = 1;\n\t      __set_errno (serrno);\n\t    }\n\t  else\n\t    return (pid_t) -1;\n\t}\n      else\n\treturn (pid_t) sid;\n    }\n#endif\n\n  pgrp = tcgetpgrp (fd);\n  if (pgrp == -1)\n    return (pid_t) -1;\n\n  sid = getsid (pgrp);\n  if (sid == -1 && errno == ESRCH)\n    __set_errno (ENOTTY);\n\n  return sid;\n}",
    "dysize(int)": "int\ndysize (int year)\n{\n  return __isleap (year) ? 366 : 365;\n}",
    "ftime(struct timeb *)": "int\nftime (struct timeb *timebuf)\n{\n  struct timespec ts;\n  __clock_gettime (CLOCK_REALTIME, &ts);\n\n  timebuf->time = ts.tv_sec;\n  timebuf->millitm = ts.tv_nsec / 1000000;\n  timebuf->timezone = 0;\n  timebuf->dstflag = 0;\n  return 0;\n}",
    "strftime(char *, int, const char *, const struct tm *)": "size_t\nmy_strftime (CHAR_T *s, size_t maxsize, const CHAR_T *format,\n\t     const struct tm *tp ut_argument_spec LOCALE_PARAM)\n{\n#if !defined _LIBC && HAVE_TZNAME && HAVE_TZSET\n  /* Solaris 2.5 tzset sometimes modifies the storage returned by localtime.\n     Work around this bug by copying *tp before it might be munged.  */\n  struct tm tmcopy;\n  tmcopy = *tp;\n  tp = &tmcopy;\n#endif\n  bool tzset_called = false;\n  return __strftime_internal (s, maxsize, format, tp, 0, &tzset_called\n\t\t\t      ut_argument LOCALE_ARG);\n}",
    "strptime(const char *, const char *, struct tm *)": "char *\nstrptime (const char *buf, const char *format, struct tm *tm LOCALE_PARAM)\n{\n  return __strptime_internal (buf, format, tm, NULL LOCALE_ARG);\n}",
    "time(time_t *)": "time_t\ntime (time_t *timer)\n{\n  struct timespec ts;\n  __clock_gettime (TIME_CLOCK_GETTIME_CLOCKID, &ts);\n\n  if (timer)\n    *timer = ts.tv_sec;\n  return ts.tv_sec;\n}",
    "timegm(struct tm *)": "__time64_t\n__timegm64 (struct tm *tmp)\n{\n  static mktime_offset_t gmtime_offset;\n  tmp->tm_isdst = 0;\n  return __mktime_internal (tmp, __gmtime64_r, &gmtime_offset);\n}",
    "timespec_get(struct timespec *, int)": "int\ntimespec_get (struct timespec *ts, int base)\n{\n  if (base == TIME_UTC)\n    {\n      __clock_gettime (CLOCK_REALTIME, ts);\n      return base;\n    }\n  return 0;\n}",
    "timespec_getres(struct timespec *, int)": "int\ntimespec_getres (struct timespec *ts, int base)\n{\n  if (base == TIME_UTC)\n    {\n      __clock_getres (CLOCK_REALTIME, ts);\n      return base;\n    }\n  return 0;\n}",
    "wcsftime(int *, int, const int *, const struct tm *)": "size_t\nmy_strftime (CHAR_T *s, size_t maxsize, const CHAR_T *format,\n\t     const struct tm *tp ut_argument_spec LOCALE_PARAM)\n{\n#if !defined _LIBC && HAVE_TZNAME && HAVE_TZSET\n  /* Solaris 2.5 tzset sometimes modifies the storage returned by localtime.\n     Work around this bug by copying *tp before it might be munged.  */\n  struct tm tmcopy;\n  tmcopy = *tp;\n  tp = &tmcopy;\n#endif\n  bool tzset_called = false;\n  return __strftime_internal (s, maxsize, format, tp, 0, &tzset_called\n\t\t\t      ut_argument LOCALE_ARG);\n}",
    "error(const char *const, ...)": "static void ATTRIBUTE_FORMAT((printf, 1, 2))\nerror(const char *const string, ...)\n{\n\tva_list args;\n\tva_start(args, string);\n\tverror(string, args);\n\tva_end(args);\n\terrors = true;\n}",
    "c16rtomb(char *, char16_t, mbstate_t *)": "size_t\nc16rtomb (char *s, char16_t c16, mbstate_t *ps)\n{\n  wchar_t wc = c16;\n\n  if (ps == NULL)\n    ps = &state;\n\n  if (s == NULL)\n    {\n      /* Reset any state relating to surrogate pairs.  */\n      ps->__count &= 0x7fffffff;\n      ps->__value.__wch = 0;\n      wc = 0;\n    }\n\n  if (ps->__count & 0x80000000)\n    {\n      /* The previous call passed in the first surrogate of a\n\t surrogate pair.  */\n      ps->__count &= 0x7fffffff;\n      if (wc >= 0xdc00 && wc < 0xe000)\n\twc = (0x10000\n\t      + ((ps->__value.__wch & 0x3ff) << 10)\n\t      + (wc & 0x3ff));\n      else\n\t/* This is not a low surrogate; ensure an EILSEQ error by\n\t   trying to decode the high surrogate as a wide character on\n\t   its own.  */\n\twc = ps->__value.__wch;\n      ps->__value.__wch = 0;\n    }\n  else if (wc >= 0xd800 && wc < 0xdc00)\n    {\n      /* The high part of a surrogate pair.  */\n      ps->__count |= 0x80000000;\n      ps->__value.__wch = wc;\n      return 0;\n    }\n\n  return wcrtomb (s, wc, ps);\n}",
    "c32rtomb(char *, char32_t, mbstate_t *)": "size_t\nc32rtomb (char *s, char32_t c32, mbstate_t *ps)\n{\n  if (ps == NULL)\n    ps = &state;\n  return wcrtomb (s, c32, ps);\n}",
    "c8rtomb(char *, int, mbstate_t *)": "size_t\nc8rtomb (char *s, char8_t c8, mbstate_t *ps)\n{\n  /* This implementation depends on the converter invoked by wcrtomb not\n     needing to retain state in either the top most bit of ps->__count or\n     in ps->__value between invocations.  This implementation uses the\n     top most bit of ps->__count to indicate that trailing code units are\n     expected and uses ps->__value to store previously seen code units.  */\n\n  wchar_t wc;\n\n  if (ps == NULL)\n    ps = &state;\n\n  if (s == NULL)\n    {\n      /* if 's' is a null pointer, behave as if u8'\\0' was passed as 'c8'.  If\n         this occurs for an incomplete code unit sequence, then an error will\n         be reported below.  */\n      c8 = u8\"\"[0];\n    }\n\n  if (! (ps->__count & 0x80000000))\n    {\n      /* Initial state.  */\n      if ((c8 >= 0x80 && c8 <= 0xC1) || c8 >= 0xF5)\n\t{\n\t  /* An invalid lead code unit.  */\n\t  __set_errno (EILSEQ);\n\t  return -1;\n\t}\n      if (c8 >= 0xC2)\n\t{\n\t  /* A valid lead code unit.  */\n\t  ps->__count |= 0x80000000;\n\t  ps->__value.__wchb[0] = c8;\n\t  ps->__value.__wchb[3] = 1;\n\t  return 0;\n\t}\n      /* A single byte (ASCII) code unit.  */\n      wc = c8;\n    }\n  else\n    {\n      char8_t cu1 = ps->__value.__wchb[0];\n      if (ps->__value.__wchb[3] == 1)\n\t{\n\t  /* A single lead code unit was previously seen.  */\n\t  if ((c8 < 0x80 || c8 > 0xBF)\n              || (cu1 == 0xE0 && c8 < 0xA0)\n              || (cu1 == 0xED && c8 > 0x9F)\n              || (cu1 == 0xF0 && c8 < 0x90)\n              || (cu1 == 0xF4 && c8 > 0x8F))\n\t    {\n\t      /* An invalid second code unit.  */\n\t      __set_errno (EILSEQ);\n\t      return -1;\n\t    }\n\t  if (cu1 >= 0xE0)\n\t    {\n\t      /* A three or four code unit sequence.  */\n\t      ps->__value.__wchb[1] = c8;\n\t      ++ps->__value.__wchb[3];\n\t      return 0;\n\t    }\n\t  wc = ((cu1 & 0x1F) << 6)\n\t       + (c8 & 0x3F);\n\t}\n      else\n\t{\n\t  char8_t cu2 = ps->__value.__wchb[1];\n\t  /* A three or four byte code unit sequence.  */\n\t  if (c8 < 0x80 || c8 > 0xBF)\n\t    {\n\t      /* An invalid third or fourth code unit.  */\n\t      __set_errno (EILSEQ);\n\t      return -1;\n\t    }\n\t  if (ps->__value.__wchb[3] == 2 && cu1 >= 0xF0)\n\t    {\n\t      /* A four code unit sequence.  */\n\t      ps->__value.__wchb[2] = c8;\n\t      ++ps->__value.__wchb[3];\n\t      return 0;\n\t    }\n\t  if (cu1 < 0xF0)\n\t    {\n\t      wc = ((cu1 & 0x0F) << 12)\n\t\t   + ((cu2 & 0x3F) << 6)\n\t\t   + (c8 & 0x3F);\n\t    }\n\t  else\n\t    {\n\t      char8_t cu3 = ps->__value.__wchb[2];\n\t      wc = ((cu1 & 0x07) << 18)\n\t\t   + ((cu2 & 0x3F) << 12)\n\t\t   + ((cu3 & 0x3F) << 6)\n\t\t   + (c8 & 0x3F);\n\t    }\n\t}\n      ps->__count &= 0x7fffffff;\n      ps->__value.__wch = 0;\n    }\n\n  return wcrtomb (s, wc, ps);\n}",
    "__isoc23_fwscanf(FILE *, const int *, ...)": "int\n__isoc23_fwscanf (FILE *stream, const wchar_t *format, ...)\n{\n  va_list arg;\n  int done;\n\n  va_start (arg, format);\n  done = __vfwscanf_internal (stream, format, arg,\n\t\t\t      SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc23_swscanf(const int *, const int *, ...)": "int\n__isoc23_swscanf (const wchar_t *s, const wchar_t *format, ...)\n{\n  va_list arg;\n  int done;\n  _IO_strfile sf;\n  struct _IO_wide_data wd;\n  FILE *f = _IO_strfile_readw (&sf, &wd, s);\n\n  va_start (arg, format);\n  done = __vfwscanf_internal (f, format, arg,\n\t\t\t      SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc23_vfwscanf(FILE *, const int *, va_list)": "int\n__isoc23_vfwscanf (FILE *stream, const wchar_t *format, va_list args)\n{\n  return __vfwscanf_internal (stream, format, args,\n\t\t\t      SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n}",
    "__isoc23_vswscanf(const int *, const int *, va_list)": "int\n__isoc23_vswscanf (const wchar_t *string, const wchar_t *format, va_list args)\n{\n  _IO_strfile sf;\n  struct _IO_wide_data wd;\n  FILE *f = _IO_strfile_readw (&sf, &wd, string);\n  return __vfwscanf_internal (f, format, args,\n\t\t\t      SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n}",
    "__isoc23_vwscanf(const int *, va_list)": "int\n__isoc23_vwscanf (const wchar_t *format, va_list args)\n{\n  return __vfwscanf_internal (stdin, format, args,\n\t\t\t      SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n}",
    "__isoc23_wscanf(const int *, ...)": "int\n__isoc23_wscanf (const wchar_t *format, ...)\n{\n  va_list arg;\n  int done;\n\n  va_start (arg, format);\n  done = __vfwscanf_internal (stdin, format, arg,\n\t\t\t      SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc99_fwscanf(FILE *, const int *, ...)": "int\n__isoc99_fwscanf (FILE *stream, const wchar_t *format, ...)\n{\n  va_list arg;\n  int done;\n\n  va_start (arg, format);\n  done = __vfwscanf_internal (stream, format, arg, SCANF_ISOC99_A);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc99_swscanf(const int *, const int *, ...)": "int\n__isoc99_swscanf (const wchar_t *s, const wchar_t *format, ...)\n{\n  va_list arg;\n  int done;\n  _IO_strfile sf;\n  struct _IO_wide_data wd;\n  FILE *f = _IO_strfile_readw (&sf, &wd, s);\n\n  va_start (arg, format);\n  done = __vfwscanf_internal (f, format, arg, SCANF_ISOC99_A);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc99_vfwscanf(FILE *, const int *, va_list)": "int\n__isoc99_vfwscanf (FILE *stream, const wchar_t *format, va_list args)\n{\n  return __vfwscanf_internal (stream, format, args, SCANF_ISOC99_A);\n}",
    "__isoc99_vswscanf(const int *, const int *, va_list)": "int\n__isoc99_vswscanf (const wchar_t *string, const wchar_t *format, va_list args)\n{\n  _IO_strfile sf;\n  struct _IO_wide_data wd;\n  FILE *f = _IO_strfile_readw (&sf, &wd, string);\n  return __vfwscanf_internal (f, format, args, SCANF_ISOC99_A);\n}",
    "__isoc99_vwscanf(const int *, va_list)": "int\n__isoc99_vwscanf (const wchar_t *format, va_list args)\n{\n  return __vfwscanf_internal (stdin, format, args, SCANF_ISOC99_A);\n}",
    "__isoc99_wscanf(const int *, ...)": "int\n__isoc99_wscanf (const wchar_t *format, ...)\n{\n  va_list arg;\n  int done;\n\n  va_start (arg, format);\n  done = __vfwscanf_internal (stdin, format, arg, SCANF_ISOC99_A);\n  va_end (arg);\n\n  return done;\n}",
    "__mbrlen(const char *, int, mbstate_t *)": "size_t\n__mbrlen (const char *s, size_t n, mbstate_t *ps)\n{\n  return __mbrtowc (NULL, s, n, ps ?: &internal);\n}",
    "mbrtoc16(char16_t *, const char *, int, mbstate_t *)": "size_t\nmbrtoc16 (char16_t *pc16, const char *s, size_t n, mbstate_t *ps)\n{\n  if (ps == NULL)\n    ps = &state;\n\n  /* The standard text does not say that S being NULL means the state\n     is reset even if the second half of a surrogate still have to be\n     returned.  In fact, the error code description indicates\n     otherwise.  Therefore always first try to return a second\n     half.  */\n  if (ps->__count & 0x80000000)\n    {\n      /* We have to return the second word for a surrogate.  */\n      ps->__count &= 0x7fffffff;\n      *pc16 = ps->__value.__wch;\n      ps->__value.__wch = L'\\0';\n      return (size_t) -3;\n    }\n\n  wchar_t wc;\n  struct __gconv_step_data data;\n  int status;\n  size_t result;\n  size_t dummy;\n  const unsigned char *inbuf, *endbuf;\n  unsigned char *outbuf = (unsigned char *) &wc;\n  const struct gconv_fcts *fcts;\n\n  /* Set information for this step.  */\n  data.__invocation_counter = 0;\n  data.__internal_use = 1;\n  data.__flags = __GCONV_IS_LAST;\n  data.__statep = ps;\n\n  /* A first special case is if S is NULL.  This means put PS in the\n     initial state.  */\n  if (s == NULL)\n    {\n      pc16 = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t) -2;\n\n  /* Tell where we want the result.  */\n  data.__outbuf = outbuf;\n  data.__outbufend = outbuf + sizeof (wchar_t);\n\n  /* Get the conversion functions.  */\n  fcts = get_gconv_fcts (_NL_CURRENT_DATA (LC_CTYPE));\n\n  /* Do a normal conversion.  */\n  inbuf = (const unsigned char *) s;\n  endbuf = inbuf + n;\n  if (__glibc_unlikely (endbuf < inbuf))\n    {\n      endbuf = (const unsigned char *) ~(uintptr_t) 0;\n      if (endbuf == inbuf)\n\tgoto ilseq;\n    }\n  __gconv_fct fct = fcts->towc->__fct;\n  if (fcts->towc->__shlib_handle != NULL)\n    PTR_DEMANGLE (fct);\n\n  status = DL_CALL_FCT (fct, (fcts->towc, &data, &inbuf, endbuf,\n\t\t\t      NULL, &dummy, 0, 1));\n\n  /* There must not be any problems with the conversion but illegal input\n     characters.  The output buffer must be large enough, otherwise the\n     definition of MB_CUR_MAX is not correct.  All the other possible\n     errors also must not happen.  */\n  assert (status == __GCONV_OK || status == __GCONV_EMPTY_INPUT\n\t  || status == __GCONV_ILLEGAL_INPUT\n\t  || status == __GCONV_INCOMPLETE_INPUT\n\t  || status == __GCONV_FULL_OUTPUT);\n\n  if (status == __GCONV_OK || status == __GCONV_EMPTY_INPUT\n      || status == __GCONV_FULL_OUTPUT)\n    {\n      result = inbuf - (const unsigned char *) s;\n\n      if (wc < 0x10000)\n\t{\n\t  if (pc16 != NULL)\n\t    *pc16 = wc;\n\n\t  if (data.__outbuf != outbuf && wc == L'\\0')\n\t    {\n\t      /* The converted character is the NUL character.  */\n\t      assert (__mbsinit (data.__statep));\n\t      result = 0;\n\t    }\n\t}\n      else\n\t{\n\t  /* This is a surrogate.  */\n\t  if (pc16 != NULL)\n\t    *pc16 = 0xd7c0 + (wc >> 10);\n\n\t  ps->__count |= 0x80000000;\n\t  ps->__value.__wch = 0xdc00 + (wc & 0x3ff);\n\t}\n    }\n  else if (status == __GCONV_INCOMPLETE_INPUT)\n    result = (size_t) -2;\n  else\n    {\n    ilseq:\n      result = (size_t) -1;\n      __set_errno (EILSEQ);\n    }\n\n  return result;\n}",
    "mbrtoc32(char32_t *, const char *, int, mbstate_t *)": "size_t\nmbrtoc32 (char32_t *pc32, const char *s, size_t n, mbstate_t *ps)\n{\n  if (ps == NULL)\n    ps = &state;\n  return mbrtowc ((wchar_t *) pc32, s, n, ps);\n}",
    "mbrtoc8(int *, const char *, int, mbstate_t *)": "size_t\nmbrtoc8 (char8_t *pc8, const char *s, size_t n, mbstate_t *ps)\n{\n  /* This implementation depends on the converter invoked by mbrtowc not\n     needing to retain state in either the top most bit of ps->__count or\n     in ps->__value between invocations.  This implementation uses the\n     top most bit of ps->__count to indicate that trailing code units are\n     yet to be written and uses ps->__value to store those code units.  */\n\n  if (ps == NULL)\n    ps = &state;\n\n  /* If state indicates that trailing code units are yet to be written, write\n     those first regardless of whether 's' is a null pointer.  */\n  if (ps->__count & 0x80000000)\n    {\n      /* ps->__value.__wchb[3] stores the index of the next code unit to\n         write.  Code units are stored in reverse order.  */\n      size_t i = ps->__value.__wchb[3];\n      if (pc8 != NULL)\n\t{\n\t  *pc8 = ps->__value.__wchb[i];\n\t}\n      if (i == 0)\n\t{\n\t  ps->__count &= 0x7fffffff;\n\t  ps->__value.__wch = 0;\n\t}\n      else\n\t--ps->__value.__wchb[3];\n      return -3;\n    }\n\n  if (s == NULL)\n    {\n      /* if 's' is a null pointer, behave as if a null pointer was passed for\n         'pc8', an empty string was passed for 's', and 1 passed for 'n'.  */\n      pc8 = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  wchar_t wc;\n  size_t result;\n\n  result = mbrtowc (&wc, s, n, ps);\n  if (result <= n)\n    {\n      if (wc <= 0x7F)\n\t{\n\t  if (pc8 != NULL)\n\t    *pc8 = wc;\n\t}\n      else if (wc <= 0x7FF)\n\t{\n\t  if (pc8 != NULL)\n\t    *pc8 = 0xC0 + ((wc >> 6) & 0x1F);\n\t  ps->__value.__wchb[0] = 0x80 + (wc & 0x3F);\n\t  ps->__value.__wchb[3] = 0;\n\t  ps->__count |= 0x80000000;\n\t}\n      else if (wc <= 0xFFFF)\n\t{\n\t  if (pc8 != NULL)\n\t    *pc8 = 0xE0 + ((wc >> 12) & 0x0F);\n\t  ps->__value.__wchb[1] = 0x80 + ((wc >> 6) & 0x3F);\n\t  ps->__value.__wchb[0] = 0x80 + (wc & 0x3F);\n\t  ps->__value.__wchb[3] = 1;\n\t  ps->__count |= 0x80000000;\n\t}\n      else if (wc <= 0x10FFFF)\n\t{\n\t  if (pc8 != NULL)\n\t    *pc8 = 0xF0 + ((wc >> 18) & 0x07);\n\t  ps->__value.__wchb[2] = 0x80 + ((wc >> 12) & 0x3F);\n\t  ps->__value.__wchb[1] = 0x80 + ((wc >> 6) & 0x3F);\n\t  ps->__value.__wchb[0] = 0x80 + (wc & 0x3F);\n\t  ps->__value.__wchb[3] = 2;\n\t  ps->__count |= 0x80000000;\n\t}\n    }\n  if (result == 0 && wc != 0)\n    {\n      /* mbrtowc() never returns -3.  When a MB sequence converts to multiple\n         WCs, no input is consumed when writing the subsequent WCs resulting\n         in a result of 0 even if a null character wasn't written.  */\n      result = -3;\n    }\n\n  return result;\n}",
    "__mbrtowc(int *, const char *, int, mbstate_t *)": "size_t\n__mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  wchar_t buf[1];\n  struct __gconv_step_data data;\n  int status;\n  size_t result;\n  size_t dummy;\n  const unsigned char *inbuf, *endbuf;\n  unsigned char *outbuf = (unsigned char *) (pwc ?: buf);\n  const struct gconv_fcts *fcts;\n\n  /* Set information for this step.  */\n  data.__invocation_counter = 0;\n  data.__internal_use = 1;\n  data.__flags = __GCONV_IS_LAST;\n  data.__statep = ps ?: &state;\n\n  /* A first special case is if S is NULL.  This means put PS in the\n     initial state.  */\n  if (s == NULL)\n    {\n      outbuf = (unsigned char *) buf;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t) -2;\n\n  /* Tell where we want the result.  */\n  data.__outbuf = outbuf;\n  data.__outbufend = outbuf + sizeof (wchar_t);\n\n  /* Get the conversion functions.  */\n  fcts = get_gconv_fcts (_NL_CURRENT_DATA (LC_CTYPE));\n\n  /* Do a normal conversion.  */\n  inbuf = (const unsigned char *) s;\n  endbuf = inbuf + n;\n  if (__glibc_unlikely (endbuf < inbuf))\n    {\n      endbuf = (const unsigned char *) ~(uintptr_t) 0;\n      if (endbuf == inbuf)\n\tgoto ilseq;\n    }\n  __gconv_fct fct = fcts->towc->__fct;\n  if (fcts->towc->__shlib_handle != NULL)\n    PTR_DEMANGLE (fct);\n  status = DL_CALL_FCT (fct, (fcts->towc, &data, &inbuf, endbuf,\n\t\t\t      NULL, &dummy, 0, 1));\n\n  /* There must not be any problems with the conversion but illegal input\n     characters.  The output buffer must be large enough, otherwise the\n     definition of MB_CUR_MAX is not correct.  All the other possible\n     errors also must not happen.  */\n  assert (status == __GCONV_OK || status == __GCONV_EMPTY_INPUT\n\t  || status == __GCONV_ILLEGAL_INPUT\n\t  || status == __GCONV_INCOMPLETE_INPUT\n\t  || status == __GCONV_FULL_OUTPUT);\n\n  if (status == __GCONV_OK || status == __GCONV_EMPTY_INPUT\n      || status == __GCONV_FULL_OUTPUT)\n    {\n      if (data.__outbuf != (unsigned char *) outbuf\n\t  && *(wchar_t *) outbuf == L'\\0')\n\t{\n\t  /* The converted character is the NUL character.  */\n\t  assert (__mbsinit (data.__statep));\n\t  result = 0;\n\t}\n      else\n\tresult = inbuf - (const unsigned char *) s;\n    }\n  else if (status == __GCONV_INCOMPLETE_INPUT)\n    result = (size_t) -2;\n  else\n    {\n    ilseq:\n      result = (size_t) -1;\n      __set_errno (EILSEQ);\n    }\n\n  return result;\n}",
    "wcscasecmp(const int *, const int *)": "int\n__wcscasecmp (const wchar_t *s1, const wchar_t *s2 LOCALE_PARAM)\n{\n  wint_t c1, c2;\n\n  if (s1 == s2)\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*s1++);\n      c2 = TOLOWER (*s2++);\n      if (c1 == L'\\0')\n\tbreak;\n    }\n  while (c1 == c2);\n\n  return c1 - c2;\n}",
    "wcscasecmp(const int *, const int *, locale_t)": "int\n__wcscasecmp (const wchar_t *s1, const wchar_t *s2 LOCALE_PARAM)\n{\n  wint_t c1, c2;\n\n  if (s1 == s2)\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*s1++);\n      c2 = TOLOWER (*s2++);\n      if (c1 == L'\\0')\n\tbreak;\n    }\n  while (c1 == c2);\n\n  return c1 - c2;\n}",
    "__wcscoll_l(const int *, const int *, locale_t)": "int\nSTRCOLL (const STRING_TYPE *s1, const STRING_TYPE *s2, locale_t l)\n{\n  struct __locale_data *current = l->__locales[LC_COLLATE];\n  uint32_t nrules = current->values[_NL_ITEM_INDEX (_NL_COLLATE_NRULES)].word;\n  /* We don't assign the following values right away since it might be\n     unnecessary in case there are no rules.  */\n  const unsigned char *rulesets;\n  const int32_t *table;\n  const USTRING_TYPE *weights;\n  const USTRING_TYPE *extra;\n  const int32_t *indirect;\n\n  if (nrules == 0)\n    return STRCMP (s1, s2);\n\n  /* Catch empty strings.  */\n  if (__glibc_unlikely (*s1 == '\\0') || __glibc_unlikely (*s2 == '\\0'))\n    return (*s1 != '\\0') - (*s2 != '\\0');\n\n  rulesets = (const unsigned char *)\n    current->values[_NL_ITEM_INDEX (_NL_COLLATE_RULESETS)].string;\n  table = (const int32_t *)\n    current->values[_NL_ITEM_INDEX (CONCAT(_NL_COLLATE_TABLE,SUFFIX))].string;\n  weights = (const USTRING_TYPE *)\n    current->values[_NL_ITEM_INDEX (CONCAT(_NL_COLLATE_WEIGHT,SUFFIX))].string;\n  extra = (const USTRING_TYPE *)\n    current->values[_NL_ITEM_INDEX (CONCAT(_NL_COLLATE_EXTRA,SUFFIX))].string;\n  indirect = (const int32_t *)\n    current->values[_NL_ITEM_INDEX (CONCAT(_NL_COLLATE_INDIRECT,SUFFIX))].string;\n\n  assert (((uintptr_t) table) % __alignof__ (table[0]) == 0);\n  assert (((uintptr_t) weights) % __alignof__ (weights[0]) == 0);\n  assert (((uintptr_t) extra) % __alignof__ (extra[0]) == 0);\n  assert (((uintptr_t) indirect) % __alignof__ (indirect[0]) == 0);\n\n  int result = 0, rule = 0;\n\n  /* With GCC 7 when compiling with -Os the compiler warns that\n     seq1.back_us and seq2.back_us might be used uninitialized.\n     Sometimes this warning appears at locations in locale/weightwc.h\n     where the actual use is, but on architectures other than x86_64,\n     x86 and s390x, a warning appears at the definitions of seq1 and\n     seq2.  This uninitialized use is impossible for the same reason\n     as described in comments in locale/weightwc.h.  */\n  DIAG_PUSH_NEEDS_COMMENT;\n  DIAG_IGNORE_Os_NEEDS_COMMENT (7, \"-Wmaybe-uninitialized\");\n  coll_seq seq1, seq2;\n  DIAG_POP_NEEDS_COMMENT;\n  seq1.len = 0;\n  seq1.idxmax = 0;\n  seq1.rule = 0;\n  seq2.len = 0;\n  seq2.idxmax = 0;\n\n  for (int pass = 0; pass < nrules; ++pass)\n    {\n      seq1.idxcnt = 0;\n      seq1.idx = 0;\n      seq2.idx = 0;\n      seq1.backw_stop = ~0ul;\n      seq1.backw = ~0ul;\n      seq2.idxcnt = 0;\n      seq2.backw_stop = ~0ul;\n      seq2.backw = ~0ul;\n\n      /* We need the elements of the strings as unsigned values since they\n\t are used as indices.  */\n      seq1.us = (const USTRING_TYPE *) s1;\n      seq2.us = (const USTRING_TYPE *) s2;\n\n      /* We assume that if a rule has defined `position' in one section\n\t this is true for all of them.  Please note that the localedef programs\n\t makes sure that `position' is not used at the first level.  */\n\n      int position = rulesets[rule * nrules + pass] & sort_position;\n\n      while (1)\n\t{\n\t  get_next_seq (&seq1, nrules, rulesets, weights, table,\n\t\t\t\t    extra, indirect, pass);\n\t  get_next_seq (&seq2, nrules, rulesets, weights, table,\n\t\t\t\t    extra, indirect, pass);\n\t  /* See whether any or both strings are empty.  */\n\t  if (seq1.len == 0 || seq2.len == 0)\n\t    {\n\t      if (seq1.len == seq2.len)\n\t\t{\n\t\t  /* Both strings ended and are equal at this level.  Do a\n\t\t     byte-level comparison to ensure that we don't waste time\n\t\t     going through multiple passes for totally equal strings\n\t\t     before proceeding to subsequent passes.  */\n\t\t  if (pass == 0 && STRCMP (s1, s2) == 0)\n\t\t    return result;\n\t\t  else\n\t\t    break;\n\t        }\n\n\t      /* This means one string is shorter than the other.  Find out\n\t\t which one and return an appropriate value.  */\n\t      return seq1.len == 0 ? -1 : 1;\n\t    }\n\n\t  result = do_compare (&seq1, &seq2, position, weights);\n\t  if (result != 0)\n\t    return result;\n\t}\n\n      rule = seq1.rule;\n    }\n\n  return result;\n}",
    "wcscspn(const int *, const int *)": "size_t\nwcscspn (const wchar_t *wcs, const wchar_t *reject)\n{\n  size_t count = 0;\n\n  while (*wcs != L'\\0')\n    if (wcschr (reject, *wcs++) == NULL)\n      ++count;\n    else\n      return count;\n\n  return count;\n}",
    "wcsdup(const int *)": "wchar_t *\nwcsdup (const wchar_t *s)\n{\n  size_t len = (__wcslen (s) + 1) * sizeof (wchar_t);\n  void *new = malloc (len);\n\n  if (new == NULL)\n    return NULL;\n\n  return (wchar_t *) memcpy (new, (void *) s, len);\n}",
    "wcsncasecmp(const int *, const int *, int)": "int\n__wcsncasecmp (const wchar_t *s1, const wchar_t *s2, size_t n LOCALE_PARAM)\n{\n  wint_t c1, c2;\n\n  if (s1 == s2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = (wint_t) TOLOWER (*s1++);\n      c2 = (wint_t) TOLOWER (*s2++);\n      if (c1 == L'\\0' || c1 != c2)\n\treturn c1 - c2;\n    } while (--n > 0);\n\n  return c1 - c2;\n}",
    "wcsncasecmp(const int *, const int *, int, locale_t)": "int\n__wcsncasecmp (const wchar_t *s1, const wchar_t *s2, size_t n LOCALE_PARAM)\n{\n  wint_t c1, c2;\n\n  if (s1 == s2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = (wint_t) TOLOWER (*s1++);\n      c2 = (wint_t) TOLOWER (*s2++);\n      if (c1 == L'\\0' || c1 != c2)\n\treturn c1 - c2;\n    } while (--n > 0);\n\n  return c1 - c2;\n}",
    "wcsncat(int *, const int *, int)": "wchar_t *\nWCSNCAT (wchar_t *dest, const wchar_t *src, size_t n)\n{\n  wchar_t *ret = dest;\n\n  /* Find the end of dest.  */\n  dest += __wcslen (dest);\n\n  size_t ds = __wcsnlen (src, n);\n\n  dest[ds] = L'\\0';\n  __wmemcpy (dest, src, ds);\n\n  return ret;\n}",
    "wcsncmp(const int *, const int *, int)": "int\nWCSNCMP (const wchar_t *s1, const wchar_t *s2, size_t n)\n{\n  wchar_t c1 = L'\\0';\n  wchar_t c2 = L'\\0';\n\n  if (n >= 4)\n    {\n      size_t n4 = n >> 2;\n      do\n\t{\n\t  c1 = *s1++;\n\t  c2 = *s2++;\n\t  if (c1 == L'\\0' || c1 != c2)\n\t    return c1 > c2 ? 1 : (c1 < c2 ? -1 : 0);\n\t  c1 = *s1++;\n\t  c2 = *s2++;\n\t  if (c1 == L'\\0' || c1 != c2)\n\t    return c1 > c2 ? 1 : (c1 < c2 ? -1 : 0);\n\t  c1 = *s1++;\n\t  c2 = *s2++;\n\t  if (c1 == L'\\0' || c1 != c2)\n\t    return c1 > c2 ? 1 : (c1 < c2 ? -1 : 0);\n\t  c1 = *s1++;\n\t  c2 = *s2++;\n\t  if (c1 == L'\\0' || c1 != c2)\n\t    return c1 > c2 ? 1 : (c1 < c2 ? -1 : 0);\n\t} while (--n4 > 0);\n      n &= 3;\n    }\n\n  while (n > 0)\n    {\n      c1 = *s1++;\n      c2 = *s2++;\n      if (c1 == L'\\0' || c1 != c2)\n\treturn c1 > c2 ? 1 : (c1 < c2 ? -1 : 0);\n      n--;\n    }\n\n  return 0;\n}",
    "wcspbrk(const int *, const int *)": "wchar_t *\nwcspbrk (const wchar_t *wcs, const wchar_t *accept)\n{\n  while (*wcs != L'\\0')\n    if (wcschr (accept, *wcs) == NULL)\n      ++wcs;\n    else\n      return (wchar_t *) wcs;\n\n  return NULL;\n}",
    "wcsrchr(const int *, const int)": "wchar_t *\nWCSRCHR (const wchar_t *wcs, const wchar_t wc)\n{\n  wchar_t *retval = NULL;\n\n#define ITERATION(index)\t\t\\\n  ({\t\t\t\t\t\\\n    if (*wcs == wc)\t\t\t\\\n      retval = (wchar_t*) wcs;\t\t\\\n    *wcs++ != L'\\0';\t\\\n  })\n\n#ifndef UNROLL_NTIMES\n# define UNROLL_NTIMES 1\n#endif\n\n  while (1)\n    UNROLL_REPEAT (UNROLL_NTIMES, ITERATION);\n\n  return retval;\n}",
    "wcsspn(const int *, const int *)": "size_t\nwcsspn (const wchar_t *wcs, const wchar_t *accept)\n{\n  const wchar_t *p;\n  const wchar_t *a;\n  size_t count = 0;\n\n  for (p = wcs; *p != L'\\0'; ++p)\n    {\n      for (a = accept; *a != L'\\0'; ++a)\n\tif (*p == *a)\n\t  break;\n      if (*a == L'\\0')\n\treturn count;\n      else\n\t++count;\n    }\n\n  return count;\n}",
    "wcsstr(const int *, const int *)": "wchar_t *\nwcsstr (const wchar_t *haystack, const wchar_t *needle)\n{\n  wchar_t b, c;\n\n  if ((b = *needle) != L'\\0')\n    {\n      haystack--;\t\t\t\t/* possible ANSI violation */\n      do\n\tif ((c = *++haystack) == L'\\0')\n\t  goto ret0;\n      while (c != b);\n\n      if (!(c = *++needle))\n\tgoto foundneedle;\n      ++needle;\n      goto jin;\n\n      for (;;)\n\t{\n\t  wchar_t a;\n\t  const wchar_t *rhaystack, *rneedle;\n\n\t  do\n\t    {\n\t      if (!(a = *++haystack))\n\t\tgoto ret0;\n\t      if (a == b)\n\t\tbreak;\n\t      if ((a = *++haystack) == L'\\0')\n\t\tgoto ret0;\nshloop:\t      ;\n\t    }\n\t  while (a != b);\n\njin:\t  if (!(a = *++haystack))\n\t    goto ret0;\n\n\t  if (a != c)\n\t    goto shloop;\n\n\t  if (*(rhaystack = haystack-- + 1) == (a = *(rneedle = needle)))\n\t    do\n\t      {\n\t\tif (a == L'\\0')\n\t\t  goto foundneedle;\n\t\tif (*++rhaystack != (a = *++needle))\n\t\t  break;\n\t\tif (a == L'\\0')\n\t\t  goto foundneedle;\n\t      }\n\t    while (*++rhaystack == (a = *++needle));\n\n\t  needle = rneedle;\t\t  /* took the register-poor approach */\n\n\t  if (a == L'\\0')\n\t    break;\n\t}\n    }\nfoundneedle:\n  return (wchar_t*) haystack;\nret0:\n  return NULL;\n}",
    "wcstok(int *, const int *, int **)": "wchar_t *\nwcstok (wchar_t *wcs, const wchar_t *delim, wchar_t **save_ptr)\n{\n  wchar_t *result;\n\n  if (wcs == NULL)\n    {\n      if (*save_ptr == NULL)\n\t{\n\t  __set_errno (EINVAL);\n\t  return NULL;\n\t}\n      else\n\twcs = *save_ptr;\n    }\n\n  /* Scan leading delimiters.  */\n  wcs += wcsspn (wcs, delim);\n  if (*wcs == L'\\0')\n    {\n      *save_ptr = NULL;\n      return NULL;\n    }\n\n  /* Find the end of the token.\t */\n  result = wcs;\n  wcs = wcspbrk (result, delim);\n  if (wcs == NULL)\n    /* This token finishes the string.\t*/\n    *save_ptr = NULL;\n  else\n    {\n      /* Terminate the token and make *SAVE_PTR point past it.  */\n      *wcs = L'\\0';\n      *save_ptr = wcs + 1;\n    }\n  return result;\n}",
    "wcswidth(const int *, int)": "int\nwcswidth (const wchar_t *s, size_t n)\n{\n  int result = 0;\n\n  while (n-- > 0 && *s != L'\\0')\n    {\n      int now = internal_wcwidth (*s);\n      if (now == -1)\n\treturn -1;\n      result += now;\n      ++s;\n    }\n\n  return result;\n}",
    "wcsxfrm(int *, const int *, int)": "size_t\nSTRXFRM (STRING_TYPE *dest, const STRING_TYPE *src, size_t n)\n{\n  return STRXFRM_L (dest, src, n, _NL_CURRENT_LOCALE);\n}",
    "__wcsxfrm_l(int *, const int *, int, locale_t)": "size_t\nSTRXFRM (STRING_TYPE *dest, const STRING_TYPE *src, size_t n, locale_t l)\n{\n  locale_data_t l_data;\n  struct __locale_data *current = l->__locales[LC_COLLATE];\n  l_data.nrules = current->values[_NL_ITEM_INDEX (_NL_COLLATE_NRULES)].word;\n\n  /* Handle byte comparison case.  */\n  if (l_data.nrules == 0)\n    {\n      size_t srclen = STRLEN (src);\n\n      if (n != 0)\n\tSTPNCPY (dest, src, MIN (srclen + 1, n));\n\n      return srclen;\n    }\n\n  /* Handle an empty string, code hereafter relies on strlen (src) > 0.  */\n  if (*src == L('\\0'))\n    {\n      if (n != 0)\n\t*dest = L('\\0');\n      return 0;\n    }\n\n  /* Get the locale data.  */\n  l_data.rulesets = (unsigned char *)\n    current->values[_NL_ITEM_INDEX (_NL_COLLATE_RULESETS)].string;\n  l_data.table = (int32_t *)\n    current->values[_NL_ITEM_INDEX (CONCAT(_NL_COLLATE_TABLE,SUFFIX))].string;\n  l_data.weights = (USTRING_TYPE *)\n    current->values[_NL_ITEM_INDEX (CONCAT(_NL_COLLATE_WEIGHT,SUFFIX))].string;\n  l_data.extra = (USTRING_TYPE *)\n    current->values[_NL_ITEM_INDEX (CONCAT(_NL_COLLATE_EXTRA,SUFFIX))].string;\n  l_data.indirect = (int32_t *)\n    current->values[_NL_ITEM_INDEX (CONCAT(_NL_COLLATE_INDIRECT,SUFFIX))].string;\n\n  assert (((uintptr_t) l_data.table) % __alignof__ (l_data.table[0]) == 0);\n  assert (((uintptr_t) l_data.weights) % __alignof__ (l_data.weights[0]) == 0);\n  assert (((uintptr_t) l_data.extra) % __alignof__ (l_data.extra[0]) == 0);\n  assert (((uintptr_t) l_data.indirect) % __alignof__ (l_data.indirect[0]) == 0);\n\n  /* We need the elements of the string as unsigned values since they\n     are used as indices.  */\n  const USTRING_TYPE *usrc = (const USTRING_TYPE *) src;\n\n  /* Allocate cache for small strings on the stack and fill it with weight and\n     rule indices.  If the cache size is not sufficient, continue with the\n     uncached xfrm version.  */\n  size_t idxmax = 0;\n  const USTRING_TYPE *cur = usrc;\n  int32_t *idxarr = alloca (SMALL_STR_SIZE * sizeof (int32_t));\n  unsigned char *rulearr = alloca (SMALL_STR_SIZE + 1);\n\n  do\n    {\n      int32_t tmp = findidx (l_data.table, l_data.indirect, l_data.extra, &cur,\n\t\t\t     -1);\n      rulearr[idxmax] = tmp >> 24;\n      idxarr[idxmax] = tmp & 0xffffff;\n\n      ++idxmax;\n    }\n  while (*cur != L('\\0') && idxmax < SMALL_STR_SIZE);\n\n  /* This element is only read, the value never used but to determine\n     another value which then is ignored.  */\n  rulearr[idxmax] = '\\0';\n\n  /* Do the transformation.  */\n  if (*cur == L('\\0'))\n    return do_xfrm_cached (dest, n, &l_data, idxmax, idxarr, rulearr);\n  else\n    return do_xfrm (usrc, dest, n, &l_data);\n}",
    "wctob(wint_t)": "int\nwctob (wint_t c)\n{\n  unsigned char buf[MB_LEN_MAX];\n  struct __gconv_step_data data;\n  wchar_t inbuf[1];\n  wchar_t *inptr = inbuf;\n  size_t dummy;\n  int status;\n  const struct gconv_fcts *fcts;\n\n  if (c == WEOF)\n    return EOF;\n\n  /* We know that only ASCII compatible encodings are used for the\n     locale and that the wide character encoding is ISO 10646.  */\n  if (c >= L'\\0' && c <= L'\\x7f')\n    return (int) c;\n\n  /* Tell where we want the result.  */\n  data.__outbuf = buf;\n  data.__outbufend = buf + MB_LEN_MAX;\n  data.__invocation_counter = 0;\n  data.__internal_use = 1;\n  data.__flags = __GCONV_IS_LAST;\n  data.__statep = &data.__state;\n\n  /* Make sure we start in the initial state.  */\n  memset (&data.__state, '\\0', sizeof (mbstate_t));\n\n  /* Get the conversion functions.  */\n  fcts = get_gconv_fcts (_NL_CURRENT_DATA (LC_CTYPE));\n\n  /* Create the input string.  */\n  inbuf[0] = c;\n\n  const unsigned char *argptr = (const unsigned char *) inptr;\n  __gconv_fct fct = fcts->tomb->__fct;\n  if (fcts->tomb->__shlib_handle != NULL)\n    PTR_DEMANGLE (fct);\n  status = DL_CALL_FCT (fct,\n\t\t\t(fcts->tomb, &data, &argptr,\n\t\t\t argptr + sizeof (inbuf[0]), NULL, &dummy, 0, 1));\n\n  /* The conversion failed or the output is too long.  */\n  if ((status != __GCONV_OK && status != __GCONV_FULL_OUTPUT\n       && status != __GCONV_EMPTY_INPUT)\n      || data.__outbuf != (unsigned char *) (buf + 1))\n    return EOF;\n\n  return buf[0];\n}",
    "wcwidth(int)": "int\nwcwidth (wchar_t ch)\n{\n  return internal_wcwidth (ch);\n}",
    "__iswctype(wint_t, wctype_t)": "int\n__iswctype (wint_t wc, wctype_t desc)\n{\n  /* If the user passes in an invalid DESC valid (the one returned from\n     `wctype' in case of an error) simply return 0.  */\n  if (desc == (wctype_t) 0)\n    return 0;\n\n  return wctype_table_lookup ((const char *) desc, wc);\n}",
    "__iswctype_l(wint_t, wctype_t, locale_t)": "int\n__iswctype_l (wint_t wc, wctype_t desc, locale_t locale)\n{\n  /* If the user passes in an invalid DESC valid (the one returned from\n     `__wctype_l' in case of an error) simply return 0.  */\n  if (desc == (wctype_t) 0)\n    return 0;\n\n  return wctype_table_lookup ((const char *) desc, wc);\n}",
    "__towctrans(wint_t, wctrans_t)": "wint_t\n__towctrans (wint_t wc, wctrans_t desc)\n{\n  /* If the user passes in an invalid DESC valid (the one returned from\n     `wctrans' in case of an error) simply return the value.  */\n  if (desc == (wctrans_t) 0)\n    return wc;\n\n  return wctrans_table_lookup ((const char *) desc, wc);\n}",
    "__towctrans_l(wint_t, wctrans_t, locale_t)": "wint_t\n__towctrans_l (wint_t wc, wctrans_t desc, locale_t locale)\n{\n  /* If the user passes in an invalid DESC valid (the one returned from\n     `__wctrans_l' in case of an error) simply return the value.  */\n  if (desc == (wctrans_t) 0)\n    return wc;\n\n  return wctrans_table_lookup ((const char *) desc, wc);\n}",
    "__iswalnum_l(wint_t, locale_t)": "func (alnum_l, __ISwalnum)",
    "__wctrans_l(const char *, locale_t)": "wctrans_t\n__wctrans_l (const char *property, locale_t locale)\n{\n  const char *names;\n  size_t cnt;\n  size_t i;\n\n  names = locale->__locales[LC_CTYPE]->values[_NL_ITEM_INDEX (_NL_CTYPE_MAP_NAMES)].string;\n  cnt = 0;\n  while (names[0] != '\\0')\n    {\n      if (strcmp (property, names) == 0)\n\tbreak;\n\n      names = strchr (names, '\\0') + 1;\n      ++cnt;\n    }\n\n  if (names[0] == '\\0')\n    return 0;\n\n  i = locale->__locales[LC_CTYPE]->values[_NL_ITEM_INDEX (_NL_CTYPE_MAP_OFFSET)].word + cnt;\n  return (wctrans_t) locale->__locales[LC_CTYPE]->values[i].string;\n}",
    "__wctype_l(const char *, locale_t)": "wctype_t\n__wctype_l (const char *property, locale_t locale)\n{\n  const char *names;\n  unsigned int result;\n  size_t proplen = strlen (property);\n  size_t i;\n\n  names = locale->__locales[LC_CTYPE]->values[_NL_ITEM_INDEX (_NL_CTYPE_CLASS_NAMES)].string;\n  for (result = 0; ; result++)\n    {\n      size_t nameslen = strlen (names);\n\n      if (proplen == nameslen && memcmp (property, names, proplen) == 0)\n\tbreak;\n\n      names += nameslen + 1;\n      if (names[0] == '\\0')\n\treturn 0;\n    }\n\n  i = locale->__locales[LC_CTYPE]->values[_NL_ITEM_INDEX (_NL_CTYPE_CLASS_OFFSET)].word + result;\n  return (wctype_t) locale->__locales[LC_CTYPE]->values[i].string;\n}"
}
